<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Áº†ËÆ∫Âú®Á∫øÂàÜÊûêÁ≥ªÁªü - KLineChartÁâà</title>
    
    <!-- React & ReactDOM (must load first) -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <!-- Babel for JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- KLineChart - ‰ΩøÁî®Êú¨Âú∞ÁâàÊú¨(v10.0.0-alpha5) -->
    <script src="/static/lib/klinecharts.min.js"></script>
    
    <!-- Ant Design CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/antd@5.12.0/dist/reset.css">
    
    <!-- Ant Design JS -->
    <script src="https://cdn.jsdelivr.net/npm/dayjs@1.11.10/dayjs.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/antd@5.12.0/dist/antd.min.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: #f5f5f5;
        }

        .app-layout {
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .app-header {
            background: #001529;
            color: white;
            padding: 0 24px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            height: 64px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
        }

        .app-logo {
            display: flex;
            align-items: center;
            gap: 12px;
            font-size: 20px;
            font-weight: 600;
        }

        .app-logo span:first-child {
            font-size: 28px;
        }

        .app-header-actions {
            display: flex;
            gap: 16px;
            align-items: center;
        }

        .app-content {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        .sidebar {
            background: white;
            padding: 16px;
            overflow-y: auto;
            box-shadow: 2px 0 8px rgba(0,0,0,0.05);
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .sidebar-resizer {
            width: 6px;
            cursor: col-resize;
            background: transparent;
            position: relative;
        }

        .sidebar-resizer::after {
            content: "";
            position: absolute;
            top: 0;
            bottom: 0;
            left: 2px;
            width: 2px;
            background: rgba(0,0,0,0.1);
            border-radius: 1px;
        }

        .sidebar-resizer:hover::after,
        .sidebar-resizer.dragging::after {
            background: rgba(24, 144, 255, 0.5);
        }

        .sidebar .ant-tabs,
        .sidebar .ant-tabs-content-holder {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .sidebar .ant-tabs-content-holder .ant-tabs-content,
        .sidebar .ant-tabs-tabpane {
            flex: 1;
        }

        .sidebar .ant-tabs-tabpane {
            overflow-y: auto;
        }

        .left-sidebar {
            width: 280px;
        }

        .right-sidebar {
            width: 320px;
        }

        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-height: 0;
            padding: 16px;
            overflow: hidden;
            background: #f0f2f5;
        }

        .config-section {
            border: 1px solid #e8e8e8;
            border-radius: 8px;
            padding: 12px;
            background: #fafafa;
        }

        .config-section + .config-section {
            margin-top: 12px;
        }

        .config-section-title {
            font-weight: 600;
            margin-bottom: 8px;
            color: #262626;
        }

        .dark-theme .config-section {
            background: #141414;
            border-color: #333;
        }

        .config-hint {
            font-size: 11px;
            color: #999;
        }
        .dark-theme .config-hint {
            color: #bbb;
        }

        .config-grid {
            display: grid;
            gap: 12px 16px;
        }

        .config-grid--two {
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
        }

        .config-field {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .config-field > label {
            font-size: 12px;
            font-weight: 600;
            color: #555;
        }

        .config-field--full {
            grid-column: 1 / -1;
        }

        .dark-theme .config-field > label {
            color: #ddd;
        }

        .config-checkbox-group {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(190px, 1fr));
            gap: 8px 12px;
        }

        .config-checkbox-group--compact {
            grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
        }

        .config-checkbox-group .ant-checkbox-wrapper {
            font-size: 12px;
            color: #555;
        }

        .dark-theme .config-checkbox-group .ant-checkbox-wrapper {
            color: #ccc;
        }

        .config-collapse-body {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .strength-section {
            display: flex;
            flex-direction: column;
            gap: 8px;
            padding: 8px 0;
        }

        .strength-row {
            display: flex;
            flex-direction: column;
            gap: 4px;
            padding: 6px 8px;
            border-radius: 6px;
            background: rgba(33, 150, 243, 0.08);
        }

        .strength-row__title {
            font-size: 12px;
            font-weight: 600;
            color: #1a237e;
        }

        .strength-row__metrics {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            font-size: 12px;
        }

        .strength-pill {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 2px 8px;
            border-radius: 999px;
            background: #fff;
            border: 1px solid #1976d2;
            color: #0d47a1;
        }

        .strength-pill--weak {
            border-color: #f44336;
            color: #b71c1c;
            background: rgba(244, 67, 54, 0.1);
        }

        .strength-pill--strong {
            border-color: #43a047;
            color: #1b5e20;
            background: rgba(67, 160, 71, 0.12);
        }

        .level-overview {
            display: grid;
            gap: 6px;
            margin-top: 12px;
        }

        .level-overview__item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 4px 8px;
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.04);
            font-size: 12px;
        }

        .signal-filter {
            display: flex;
            flex-direction: column;
            gap: 6px;
            margin-top: 8px;
            font-size: 12px;
        }

        .signal-filter__row {
            display: flex;
            align-items: center;
            gap: 8px;
            flex-wrap: wrap;
        }

        .watchlist-overview {
            margin-top: 16px;
            padding: 12px;
            border: 1px solid #e8e8e8;
            border-radius: 8px;
            background: #fafafa;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .watchlist-overview__header {
            font-weight: 600;
            font-size: 14px;
            color: #444;
        }

        .watchlist-overview__stock {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .watchlist-overview__stock-name {
            font-size: 13px;
            font-weight: 600;
            color: #333;
        }

        .watchlist-overview__rows {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .watchlist-overview__row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 8px;
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.03);
            font-size: 12px;
        }

        .watchlist-overview__level-info {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .watchlist-overview__actions {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .dark-theme .watchlist-overview {
            background: #141414;
            border-color: #333;
        }

        .dark-theme .watchlist-overview__header {
            color: #ddd;
        }

        .dark-theme .watchlist-overview__stock-name {
            color: #f0f0f0;
        }

        .dark-theme .watchlist-overview__row {
            background: rgba(255, 255, 255, 0.05);
        }

        .dark-theme .strength-row__title {
            color: #90caf9;
        }

        .dark-theme .strength-pill {
            background: rgba(13, 71, 161, 0.18);
            border-color: #90caf9;
            color: #bbdefb;
        }

        .dark-theme .strength-pill--weak {
            background: rgba(244, 67, 54, 0.18);
            border-color: #ef9a9a;
            color: #ef9a9a;
        }

        .dark-theme .strength-pill--strong {
            background: rgba(67, 160, 71, 0.18);
            border-color: #a5d6a7;
            color: #c8e6c9;
        }

        .dark-theme .level-overview__item {
            background: rgba(255, 255, 255, 0.06);
        }



        /* Stock Manager Styles */
        .stock-manager {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .stock-manager-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            gap: 12px;
        }

        .stock-manager-title {
            font-size: 16px;
            font-weight: 600;
            color: #262626;
        }

        .stock-manager-subtitle {
            font-size: 12px;
            color: #8c8c8c;
            margin-top: 4px;
        }

        .stock-add-card {
            background: #fafafa;
            border: 1px solid #e8e8e8;
            border-radius: 10px;
            padding: 12px;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .stock-add-inputs {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .stock-add-inputs .ant-input {
            font-size: 13px;
        }

        .stock-add-hint {
            font-size: 12px;
            color: #999;
            line-height: 1.5;
        }

        .stock-quick-area {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .stock-quick-title {
            font-weight: 600;
            font-size: 13px;
            color: #262626;
        }

        .watchlist-empty {
            padding: 14px;
            border-radius: 10px;
            background: #fafafa;
            border: 1px dashed #d9d9d9;
            text-align: center;
            font-size: 12px;
            color: #999;
        }

        .watchlist-item {
            border: 1px solid #e8e8e8;
            border-radius: 10px;
            padding: 12px;
            margin-bottom: 12px;
            background: #fff;
            display: flex;
            flex-direction: column;
            gap: 12px;
            transition: box-shadow 0.2s ease, border-color 0.2s ease, transform 0.2s ease;
        }

        .watchlist-item:hover {
            border-color: #1890ff;
            box-shadow: 0 4px 12px rgba(24, 144, 255, 0.12);
            transform: translateY(-1px);
        }

        .watchlist-item--active {
            border-color: #1890ff;
            box-shadow: 0 4px 14px rgba(24, 144, 255, 0.12);
            background: rgba(24, 144, 255, 0.06);
        }

        .watchlist-item__header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 12px;
            flex-wrap: wrap;
        }

        .watchlist-item__info {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .watchlist-item__code {
            font-weight: 600;
            font-size: 14px;
            color: #262626;
        }

        .watchlist-item__meta {
            font-size: 12px;
            color: #9c9c9c;
        }

        .watchlist-item__body {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .watchlist-item__row {
            display: flex;
            align-items: center;
            gap: 8px;
            flex-wrap: wrap;
        }

        .watchlist-label {
            font-size: 12px;
            color: #888;
            min-width: 48px;
        }

        .watchlist-item__levels {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }

        .level-selector {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .level-selector-actions {
            display: flex;
            justify-content: flex-end;
            gap: 8px;
        }

        .dark-theme .stock-add-card,
        .dark-theme .watchlist-empty,
        .dark-theme .watchlist-item {
            background: #141414;
            border-color: #333;
        }

        .dark-theme .watchlist-item--active {
            border-color: #177ddc;
            background: rgba(64, 169, 255, 0.18);
            box-shadow: 0 6px 16px rgba(24, 144, 255, 0.2);
        }

        .dark-theme .stock-manager-title {
            color: #f0f0f0;
        }

        .dark-theme .stock-manager-subtitle,
        .dark-theme .stock-add-hint,
        .dark-theme .watchlist-item__meta,
        .dark-theme .watchlist-label {
            color: #bfbfbf;
        }

        .dark-theme .watchlist-item__code {
            color: #fafafa;
        }

        /* Chart Grid */
        .chart-grid {
            display: grid;
            gap: 16px;
            flex: 1;
            min-height: 0;
            grid-auto-rows: minmax(0, 1fr);
        }

        .chart-grid-1x1 {
            grid-template-columns: 1fr;
        }

        .chart-grid-2x1 {
            grid-template-columns: repeat(2, 1fr);
        }

        .chart-grid-2x2 {
            grid-template-columns: repeat(2, 1fr);
            grid-template-rows: repeat(2, minmax(600px, 1fr));
        }

        .chart-grid-3x2 {
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(2, minmax(600px, 1fr));
        }

        .chart-card {
            background: white;
            border-radius: 8px;
            padding: 16px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            display: flex;
            flex-direction: column;
            height: 100%;
            min-height: 520px;
        }

        .stock-chart-group {
            background: white;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.08);
            padding: 16px;
            display: flex;
            flex-direction: column;
            gap: 16px;
            flex: 1;
            min-height: 0;
        }

        .stock-chart-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .stock-chart-title {
            font-size: 18px;
            font-weight: 600;
            color: #262626;
        }

        .stock-chart-toolbar {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            align-items: center;
            margin-bottom: 8px;
        }

        .period-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .period-buttons .ant-btn {
            min-width: 48px;
        }

        .multi-mode-indicator {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 12px;
            color: #666;
        }

.stock-chart-panels {
    display: grid;
    flex: 1;
    min-height: 0;
    gap: 26px;
    overflow: auto;
    grid-auto-rows: minmax(680px, 1fr);
}

.stock-chart-panels.columns-1 {
    grid-template-columns: 1fr;
    grid-auto-rows: minmax(780px, auto);
}

        .stock-chart-panels.columns-2 {
            grid-template-columns: repeat(2, minmax(0, 1fr));
        }

        .stock-chart-panels.columns-3 {
            grid-template-columns: repeat(3, minmax(0, 1fr));
        }

.stock-chart-panels.columns-4 {
    grid-template-columns: repeat(2, minmax(0, 1fr));
    grid-auto-rows: minmax(460px, 1fr);
}

.stock-chart-panels.density-wide {
    gap: 32px;
    grid-auto-rows: minmax(780px, 1fr);
}

.stock-chart-panels.density-wide.columns-1 {
    grid-auto-rows: minmax(880px, auto);
}

.stock-chart-panels.density-ultra {
    gap: 40px;
    grid-auto-rows: minmax(900px, 1fr);
}

.stock-chart-panels.density-ultra.columns-1 {
    grid-auto-rows: minmax(1020px, auto);
}

.stock-chart-panels.density-mega {
    gap: 48px;
    grid-auto-rows: minmax(1040px, 1fr);
}

.stock-chart-panels.density-mega.columns-1 {
    grid-auto-rows: minmax(1180px, auto);
}

.stock-chart-panels .chart-card {
    min-height: 640px;
    padding: 20px;
}

.stock-chart-panels.density-wide .chart-card {
    min-height: 780px;
    padding: 24px;
}

.stock-chart-panels.density-ultra .chart-card {
    min-height: 900px;
    padding: 28px;
}

.stock-chart-panels.density-mega .chart-card {
    min-height: 1040px;
    padding: 32px;
}

        .chart-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
            padding-bottom: 12px;
            border-bottom: 1px solid #f0f0f0;
        }

        .chart-title {
            font-size: 16px;
            font-weight: 600;
            color: #262626;
        }

        .chart-wrapper {
            flex: 1;
            min-height: 320px;
        }

        .chart-container {
            width: 100%;
            height: 100%;
        }

        .chart-summary-wrapper {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 8px;
            margin-bottom: 6px;
            align-items: stretch;
        }

        .chart-summary-card,
        .chart-hover-card {
            background: #fafafa;
            border: 1px solid #e8e8e8;
            border-radius: 6px;
            padding: 8px;
        }

        .chart-hover-card {
            display: flex;
            flex-direction: column;
            min-height: 320px;
            max-height: 460px;
        }

        .chart-hover-card__body {
            flex: 1;
            overflow-y: auto;
            padding-right: 4px;
        }

        .chart-hover-card--collapsed {
            min-height: auto;
            max-height: none;
        }

        .chart-hover-card--collapsed .chart-hover-card__body {
            overflow: visible;
        }

        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 4px;
            margin-bottom: 4px;
        }

        .card-header .card-title {
            font-size: 11px;
            font-weight: 600;
            color: #666;
        }

        .hover-info-grid {
            display: grid;
            grid-template-columns: repeat(4, minmax(0, 1fr));
            column-gap: 6px;
            row-gap: 4px;
            font-size: 11px;
            color: #555;
        }

        .hover-info-cell {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 4px;
            line-height: 1.2;
        }

        .hover-info-label {
            color: #8c8c8c;
            white-space: nowrap;
        }

        .hover-info-value {
            font-weight: 600;
            color: #262626;
            white-space: nowrap;
        }

        .hover-info-cell--full {
            grid-column: 1 / -1;
        }

        .hover-structures {
            margin-top: 8px;
            padding-top: 6px;
            border-top: 1px dashed #e8e8e8;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .hover-structure-section {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .hover-structure-title {
            font-size: 11px;
            font-weight: 600;
            color: #666;
        }

        .hover-structure-row {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            font-size: 11px;
            color: #555;
            line-height: 1.4;
        }

        .hover-structure-metric {
            opacity: 0.85;
        }

        .dark-theme .hover-structures {
            border-top-color: #333;
        }

        .dark-theme .hover-structure-title {
            color: #bfbfbf;
        }

        .dark-theme .hover-structure-row {
            color: #ccc;
        }

        @media (max-width: 900px) {
            .chart-summary-wrapper {
                grid-template-columns: 1fr;
            }
        }

        @media (max-width: 680px) {
            .hover-info-grid {
                grid-template-columns: repeat(2, minmax(0, 1fr));
            }
        }

        .chart-signal-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 3px;
            margin-top: 4px;
        }

        .latest-signal-item,
        .hover-signal-item {
            display: flex;
            flex-direction: column;
            gap: 2px;
            min-width: 140px;
        }

        .signal-reason-text {
            font-size: 12px;
            color: #8c8c8c;
            line-height: 1.4;
            max-width: 320px;
        }

        .signal-reason-text--inline {
            max-width: 420px;
        }

        .dark-theme .signal-reason-text {
            color: #bfbfbf;
        }

        .chart-info-placeholder {
            color: #a6a6a6;
            font-size: 12px;
        }

        .chart-stats-grid {
            display: grid;
            grid-template-columns: repeat(3, minmax(60px, auto));
            gap: 8px 12px;
            font-size: 12px;
            color: #555;
        }

        .chart-stats-item {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .chart-stats-label {
            color: #8c8c8c;
        }

        .chart-stats-value {
            font-weight: 600;
            color: #262626;
        }

        .chart-bsp-types {
            margin-top: 8px;
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }

        .chart-type-chip {
            font-size: 11px;
            background: rgba(24, 144, 255, 0.12);
            color: #1890ff;
            padding: 2px 6px;
            border-radius: 999px;
        }

        .chart-type-chip--dir {
            background: rgba(0, 0, 0, 0.05);
            color: #595959;
        }

        .dark-theme .chart-summary-card,
        .dark-theme .chart-hover-card {
            background: #1f1f1f;
            border-color: #333;
        }

        .dark-theme .card-header .card-title {
            color: #bfbfbf;
        }

        .dark-theme .hover-info-label,
        .dark-theme .chart-stats-label {
            color: #a6a6a6;
        }

        .dark-theme .hover-info-value,
        .dark-theme .chart-stats-value {
            color: #f0f0f0;
        }

        .dark-theme .chart-type-chip {
            background: rgba(24, 144, 255, 0.2);
            color: #69c0ff;
        }

        .dark-theme .chart-type-chip--dir {
            background: rgba(255, 255, 255, 0.12);
            color: #d9d9d9;
        }

        /* Indicator Config */
        .indicator-section {
            margin-bottom: 16px;
        }

        .indicator-section-title {
            font-weight: 600;
            margin-bottom: 12px;
            color: #262626;
            font-size: 14px;
        }

        .indicator-item {
            margin-bottom: 8px;
        }

        /* Responsive */
        @media (max-width: 1400px) {
            .left-sidebar { width: 240px; }
            .right-sidebar { width: 280px; }
        }

        @media (max-width: 1200px) {
            .chart-grid-3x2 {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        @media (max-width: 768px) {
            .app-content {
                flex-direction: column;
            }
            .sidebar {
                width: 100% !important;
                max-height: 300px;
            }
            .chart-grid-2x1,
            .chart-grid-2x2,
            .chart-grid-3x2 {
                grid-template-columns: 1fr;
            }
        }

        /* Dark theme support */
        .dark-theme {
            background: #141414;
        }

.dark-theme .sidebar,
.dark-theme .chart-card,
.dark-theme .stock-chart-group {
    background: #1f1f1f;
    color: #e8e8e8;
}

.dark-theme .stock-chart-toolbar {
    color: #9a9a9a;
}

.dark-theme .stock-chart-title {
    color: #f0f0f0;
}

.dark-theme .main-content {
    background: #000;
}

.alert-panel {
    display: flex;
    flex-direction: column;
    gap: 12px;
}

.alert-status {
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 12px;
}

.alert-status-indicator {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    font-weight: 500;
}

.status-dot {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    background: #bfbfbf;
    box-shadow: 0 0 0 2px rgba(0,0,0,0.06);
}

.status-dot--online {
    background: #52c41a;
}

.status-dot--offline {
    background: #faad14;
}

.alert-error-text {
    color: #ff4d4f;
    font-size: 12px;
}

.alert-strategy-tags {
    display: flex;
    flex-wrap: wrap;
    gap: 6px;
}

.alert-history {
    max-height: 320px;
    overflow-y: auto;
    display: flex;
    flex-direction: column;
    gap: 8px;
}

.alert-card {
    border: 1px solid #e8e8e8;
    border-radius: 6px;
    padding: 8px;
    background: #fafafa;
}

.alert-card-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.alert-card-title {
    font-size: 12px;
    font-weight: 600;
    color: #262626;
}

.alert-card-message {
    margin-top: 6px;
    font-size: 12px;
    color: #444;
    line-height: 1.4;
}

.alert-card-meta {
    margin-top: 6px;
    display: flex;
    justify-content: space-between;
    font-size: 11px;
    color: #8c8c8c;
}

.dark-theme .alert-card {
    background: #1f1f1f;
    border-color: #333;
}

.dark-theme .alert-card-title {
    color: #f0f0f0;
}

.dark-theme .alert-card-message {
    color: #d9d9d9;
}

.dark-theme .alert-card-meta {
    color: #a6a6a6;
}
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { Layout, Button, Input, Select, Checkbox, message, Spin, Tag, Space, Tooltip, Radio, InputNumber, Slider, Switch, Tabs, Collapse, Divider, Popover, DatePicker, Segmented, List, Empty, AutoComplete, Drawer, Table, Modal } = antd;
        const { Header, Sider, Content } = Layout;
        const { useState, useEffect, useCallback, useContext, createContext, useRef, memo, useMemo, Fragment } = React;
        const dayjs = window.dayjs;

        // ============= Debug Logging =============
        const DEBUG_LOG_STORAGE_KEY = 'chan_debug_log';
        const loadDebugSetting = () => {
            try {
                return localStorage.getItem(DEBUG_LOG_STORAGE_KEY) === 'true';
            } catch (err) {
                return false;
            }
        };
        let debugEnabled = loadDebugSetting();
        const debugListeners = new Set();
        const notifyDebugChange = () => {
            debugListeners.forEach((listener) => {
                try {
                    listener(debugEnabled);
                } catch (err) {
                    // ignore listener errors
                }
            });
        };
        window.__CHAN_DEBUG__ = {
            enable() {
                debugEnabled = true;
                try {
                    localStorage.setItem(DEBUG_LOG_STORAGE_KEY, 'true');
                } catch (err) {
                    // ignore storage errors
                }
                notifyDebugChange();
            },
            disable() {
                debugEnabled = false;
                try {
                    localStorage.removeItem(DEBUG_LOG_STORAGE_KEY);
                } catch (err) {
                    // ignore storage errors
                }
                notifyDebugChange();
            },
            toggle() {
                if (debugEnabled) {
                    this.disable();
                } else {
                    this.enable();
                }
            },
            isEnabled() {
                return debugEnabled;
            },
            subscribe(listener) {
                if (typeof listener === 'function') {
                    debugListeners.add(listener);
                    try {
                        listener(debugEnabled);
                    } catch (err) {
                        // ignore listener errors
                    }
                    return () => {
                        debugListeners.delete(listener);
                    };
                }
                return () => {};
            },
        };
        const debugLog = (...args) => {
            if (!debugEnabled) return;
            console.log(...args);
        };
        const debugInfo = (...args) => {
            if (!debugEnabled) return;
            if (typeof console.info === 'function') {
                console.info(...args);
            } else {
                console.log(...args);
            }
        };
        const debugWarn = (...args) => {
            if (!debugEnabled) return;
            console.warn(...args);
        };
        const debugError = (...args) => {
            console.error(...args);
        };

        // ============= Version & Debug Info =============
        debugLog('üöÄ Chan.py Web v4.1.0 - KLineChart + Full Chan Theory Support');
        debugLog('üìÖ Loaded at:', new Date().toISOString());
        debugLog('‚úÖ Bi/Seg/ZS/BSP fully implemented with KLineChart overlay API');
        debugLog('üéØ All Chan theory indicators working perfectly!');
        
        // Check if KLineChart is loaded
        if (typeof klinecharts === 'undefined') {
            debugError('‚ùå KLineChart library not loaded! Check CDN.');
            debugError('üí° Try refreshing the page or check network in DevTools.');
        } else {
            debugLog('‚úÖ KLineChart library loaded:', klinecharts.version || 'version unknown');
        }

        // ============= Constants =============
        const API_BASE = 'http://localhost:8000';
        
        const LEVEL_OPTIONS = [
            { value: 'day', label: 'Êó•Á∫ø' },
            { value: '60m', label: '60ÂàÜ' },
            { value: '30m', label: '30ÂàÜ' },
            { value: '15m', label: '15ÂàÜ' },
            { value: '5m', label: '5ÂàÜ' },
        ];
        const DEFAULT_LEVEL = 'day';
        const LINE_STYLE_OPTIONS = [
            { value: 'solid', label: 'ÂÆûÁ∫ø' },
            { value: 'dashed', label: 'ËôöÁ∫ø' },
            { value: 'dotted', label: 'ÁÇπÁ∫ø' },
        ];

        const QUICK_STOCKS = [
            { code: 'sz.000001', name: 'Âπ≥ÂÆâÈì∂Ë°å' },
            { code: 'sh.600000', name: 'Êµ¶ÂèëÈì∂Ë°å' },
            { code: 'sh.600036', name: 'ÊãõÂïÜÈì∂Ë°å' },
            { code: 'sh.000300', name: 'Ê≤™Ê∑±300' },
        ];

        const DEFAULT_INDICATORS = {
            plot_bi: true,
            plot_seg: true,
            plot_zs: false,
            plot_bsp: true,
            plot_ma: true,
            plot_macd: true,
            plot_boll: false,
            plot_kdj: false,
            plot_rsi: false,
            plot_volume: true,
            begin_time: '2023-01-01',
            limit_kl_count: null,
            ma_params: [5, 10, 20, 60],
            kdj_period: 9,
            rsi_period: 14,
            zs_source: 'bi',
            bi_color: '#2196F3',
            bi_line_style: 'solid',
            bi_line_width: 2,
            seg_color: '#9C27B0',
            seg_line_style: 'solid',
            seg_line_width: 3,
            zs_border_color: '#FFC107',
            zs_border_style: 'dashed',
            zs_border_size: 1,
            zs_fill_color: '#FFC107',
            zs_fill_opacity: 0.2,
            zs_show_label: true,
            zs_label_color: '#FFC107',
            indicator_layout: 'stack',
            indicator_tab: 'macd',
            highlight_chan_kline: true,
            chan_kline_color: '#FF9800',
            chan_kline_show_label: false,
            // ‰π∞ÂçñÁÇπÁõ∏ÂÖ≥ÈªòËÆ§ÂÄºÔºà‰∏éÂêéÁ´Ø CChanConfig.set_bsp_config ‰∏ÄËá¥Ôºâ
            divergence_rate: Number.POSITIVE_INFINITY,
            min_zs_cnt: 1,
            bsp1_only_multibi_zs: true,
            max_bs2_rate: 0.9999,
            macd_algo: 'peak',
            bs1_peak: true,
            bs_type: '1,1p,2,2s,3a,3b',
            bsp2_follow_1: true,
            bsp3_follow_1: true,
            bsp3_peak: false,
            bsp2s_follow_2: false,
            max_bsp2s_lv: null,
            strict_bsp3: false,
            bsp_filters: { ...DEFAULT_BSP_FILTERS },
        };

        const MA_OPTIONS = [5, 10, 20, 30, 45, 60, 120, 250];
        const ALERT_HISTORY_LIMIT = 120;
        const INDICATOR_PROFILE_STORAGE_KEY = 'chanlun_indicator_profiles';

        const DEFAULT_CHAN_CONFIG = {
            bi_algo: 'normal',
            bi_strict: true,
            bi_fx_check: 'strict',
            gap_as_kl: false,
            bi_end_is_peak: true,
            bi_allow_sub_peak: true,
            seg_algo: 'chan',
            left_seg_method: 'peak',
            zs_combine: true,
            zs_combine_mode: 'zs',
            one_bi_zs: false,
            zs_algo: 'normal',
            trigger_step: false,
            skip_step: 0,
            kl_data_check: true,
            max_kl_misalgin_cnt: 2,
            max_kl_inconsistent_cnt: 5,
            auto_skip_illegal_sub_lv: false,
            print_warning: true,
            print_err_time: true,
            mean_metrics: [],
            trend_metrics: [],
            macd: { fast: 12, slow: 26, signal: 9 },
            boll_n: 20,
            cal_rsi: false,
            rsi_cycle: 14,
            cal_kdj: false,
            kdj_cycle: 9,
            cal_demark: false,
            demark: {
                demark_len: 9,
                setup_bias: 4,
                countdown_bias: 2,
                max_countdown: 13,
                tiaokong_st: true,
                setup_cmp2close: true,
                countdown_cmp2close: true,
            },
            // ‰π∞ÂçñÁÇπÈªòËÆ§È°π
            divergence_rate: Number.POSITIVE_INFINITY,
            min_zs_cnt: 1,
            bsp1_only_multibi_zs: true,
            max_bs2_rate: 0.9999,
            macd_algo: 'peak',
            bs1_peak: true,
            bs_type: '1,1p,2,2s,3a,3b',
            bsp2_follow_1: true,
            bsp3_follow_1: true,
            bsp3_peak: false,
            bsp2s_follow_2: false,
            max_bsp2s_lv: null,
            strict_bsp3: false,
        };
        const CORE_CHAN_FIELDS = [
            'bi_algo',
            'seg_algo',
            'zs_algo',
            'left_seg_method',
            'bi_strict',
            'bi_fx_check',
            'gap_as_kl',
            'bi_end_is_peak',
            'bi_allow_sub_peak',
            'zs_combine',
            'zs_combine_mode',
            'one_bi_zs',
        ];
        const CORE_CHAN_DEFAULTS = CORE_CHAN_FIELDS.reduce((acc, field) => {
            acc[field] = DEFAULT_CHAN_CONFIG[field];
            return acc;
        }, {});

        const DEFAULT_BSP_FILTERS = {
            directions: ['buy', 'sell'],
            types: [],
        };

        const SignalUtils = {
            normalizeBspType(value) {
                const str = value == null ? '' : String(value).trim();
                return str.length > 0 ? str : 'Êú™Ê†áÊ≥®';
            },
            normalizeFilters(rawFilters) {
                const source = rawFilters && typeof rawFilters === 'object' ? rawFilters : {};
                const rawDirections = Array.isArray(source.directions) && source.directions.length > 0
                    ? source.directions
                    : DEFAULT_BSP_FILTERS.directions;
                const rawTypes = Array.isArray(source.types) ? source.types : [];
                const directions = Array.from(new Set(rawDirections.map(item => (item === 'sell' ? 'sell' : 'buy'))));
                return {
                    directions: directions.length > 0 ? directions : [...DEFAULT_BSP_FILTERS.directions],
                    types: Array.from(new Set(rawTypes.map(value => {
                        if (value == null) return '';
                        const str = String(value).trim();
                        return str.length > 0 ? str : '';
                    }).filter(Boolean))),
                };
            },
            filterSignals(list, normalizedFilters) {
                if (!Array.isArray(list) || list.length === 0) {
                    return [];
                }
                const filters = normalizedFilters
                    ? normalizedFilters
                    : DEFAULT_BSP_FILTERS;
                return list.filter(item => {
                    const dir = item && item.is_buy ? 'buy' : 'sell';
                    if (!filters.directions.includes(dir)) {
                        return false;
                    }
                    if (filters.types.length > 0) {
                        const typeKey = SignalUtils.normalizeBspType(item?.type);
                        return filters.types.includes(typeKey);
                    }
                    return true;
                });
            },
            sortByTimestampDesc(list, convertFn) {
                if (!Array.isArray(list) || list.length === 0) {
                    return [];
                }
                return list
                    .map(item => {
                        const ts = convertFn(item.time);
                        return {
                            ...item,
                            timestamp: ts,
                        };
                    })
                    .filter(item => Number.isFinite(item.timestamp))
                    .sort((a, b) => b.timestamp - a.timestamp);
            },
        };

        const calculateMacdHistogram = (values, fastPeriod = 12, slowPeriod = 26, signalPeriod = 9) => {
            if (!Array.isArray(values) || values.length === 0) {
                return [];
            }
            const calcEma = (series, period) => {
                const result = [];
                if (!Array.isArray(series) || series.length === 0) {
                    return result;
                }
                const smoothing = 2 / (period + 1);
                let ema = series[0];
                result[0] = ema;
                for (let i = 1; i < series.length; i += 1) {
                    const value = series[i];
                    ema = (value * smoothing) + ema * (1 - smoothing);
                    result[i] = ema;
                }
                return result;
            };
            const emaFast = calcEma(values, fastPeriod);
            const emaSlow = calcEma(values, slowPeriod);
            if (emaFast.length !== emaSlow.length) {
                return [];
            }
            const macdLine = emaFast.map((ema, idx) => ema - emaSlow[idx]);
            const signalLine = calcEma(macdLine, signalPeriod);
            if (signalLine.length !== macdLine.length) {
                return [];
            }
            return macdLine.map((line, idx) => line - signalLine[idx]);
        };

        const normalizeDirectionValue = (candidateDir, beginPrice, endPrice) => {
            if (candidateDir === 'up' || candidateDir === 'down') {
                return candidateDir;
            }
            if (Number.isFinite(beginPrice) && Number.isFinite(endPrice)) {
                if (endPrice > beginPrice) return 'up';
                if (endPrice < beginPrice) return 'down';
            }
            return null;
        };

        const buildStrengthMetrics = (items, getTimes, getPrices, getDir, getLabel, getExtraMetrics) => {
            if (!Array.isArray(items)) {
                return [];
            }
            return items.map((item, idx) => {
                const { startTs, endTs } = getTimes(item);
                const { beginPrice, endPrice } = getPrices(item);
                const dir = normalizeDirectionValue(getDir(item), beginPrice, endPrice);
                const duration = Number.isFinite(startTs) && Number.isFinite(endTs)
                    ? Math.abs(endTs - startTs) / 60000
                    : null;
                const amplitude = (Number.isFinite(beginPrice) && Number.isFinite(endPrice))
                    ? Math.abs(endPrice - beginPrice)
                    : null;
                const efficiency = Number.isFinite(duration) && duration > 0 && Number.isFinite(amplitude)
                    ? amplitude / duration
                    : null;
                const extras = typeof getExtraMetrics === 'function' ? getExtraMetrics(startTs, endTs) : {};
                return {
                    idx,
                    startTs,
                    endTs,
                    beginPrice,
                    endPrice,
                    dir,
                    duration,
                    amplitude,
                    efficiency,
                    volume: Number.isFinite(extras?.volume) ? extras.volume : null,
                    macdAbs: Number.isFinite(extras?.macdAbs) ? extras.macdAbs : null,
                    label: getLabel(item, idx),
                };
            }).filter(metric =>
                metric.dir &&
                Number.isFinite(metric.amplitude) &&
                Number.isFinite(metric.duration) &&
                metric.duration > 0 &&
                metric.amplitude > 0 &&
                Number.isFinite(metric.endTs)
            );
        };

        const computeStrengthComparison = (metrics) => {
            if (!Array.isArray(metrics) || metrics.length < 2) {
                return null;
            }
            const ordered = metrics.slice().sort((a, b) => a.endTs - b.endTs);
            const latest = ordered[ordered.length - 1];
            let previous = null;
            for (let i = ordered.length - 2; i >= 0; i -= 1) {
                if (ordered[i].dir === latest.dir) {
                    previous = ordered[i];
                    break;
                }
            }
            if (!previous) {
                return null;
            }
            const amplitudeRatio = previous.amplitude > 0 ? latest.amplitude / previous.amplitude : null;
            const durationRatio = previous.duration > 0 ? latest.duration / previous.duration : null;
            const efficiencyRatio = (previous.efficiency && previous.efficiency > 0)
                ? (latest.efficiency ?? 0) / previous.efficiency
                : null;
            const volumeRatio = (previous.volume && previous.volume > 0 && latest.volume != null)
                ? latest.volume / previous.volume
                : null;
            const macdRatio = (previous.macdAbs && previous.macdAbs > 0 && latest.macdAbs != null)
                ? latest.macdAbs / previous.macdAbs
                : null;
            const volumeWeakening = volumeRatio != null && volumeRatio < 1;
            const macdWeakening = macdRatio != null && macdRatio < 1;
            const strongMomentum = (amplitudeRatio != null && amplitudeRatio > 1.1)
                || (macdRatio != null && macdRatio > 1.1);
            const weakening = (amplitudeRatio != null && amplitudeRatio < 1)
                && ((efficiencyRatio != null && efficiencyRatio < 1) || volumeWeakening || macdWeakening);
            const hintNotes = [];
            if (volumeWeakening) {
                hintNotes.push('ÈáèËÉΩÁº©Âáè');
            } else if (volumeRatio != null && volumeRatio > 1.1) {
                hintNotes.push('ÈáèËÉΩÊîæÂ§ß');
            }
            if (macdWeakening) {
                hintNotes.push('MACDËµ∞Âº±');
            } else if (macdRatio != null && macdRatio > 1.1) {
                hintNotes.push('MACDËµ∞Âº∫');
            }
            let hint = '';
            let hintType = null;
            if (strongMomentum) {
                hint = hintNotes.length > 0 ? hintNotes.join(' / ') : 'ÂäõÂ∫¶Â¢ûÂº∫';
                hintType = 'strong';
            } else if (weakening) {
                hint = hintNotes.length > 0 ? hintNotes.join(' / ') : 'ÂäõÂ∫¶ÂáèÂº±ÔºåÂÖ≥Ê≥®ËÉåÈ©∞';
                hintType = 'weak';
            } else if (efficiencyRatio != null && efficiencyRatio < 0.8) {
                hint = hintNotes.length > 0 ? hintNotes.join(' / ') : 'ÊïàÁéá‰∏ãÊªë';
                hintType = 'weak';
            } else if (hintNotes.length > 0) {
                hint = hintNotes.join(' / ');
            }
            return {
                dir: latest.dir,
                current: latest,
                previous,
                amplitudeRatio,
                durationRatio,
                efficiencyRatio,
                volumeRatio,
                macdRatio,
                weakening,
                volumeWeakening,
                macdWeakening,
                hint,
                hintType,
            };
        };

        const deriveStrengthMetrics = (data, chanConfig) => {
            if (!data || typeof data !== 'object') {
                return { biStrength: null, segStrength: null };
            }
            const safeNumber = (value) => {
                if (typeof value === 'number') {
                    return Number.isFinite(value) ? value : null;
                }
                if (value === null || value === undefined) {
                    return null;
                }
                const parsed = parseFloat(value);
                return Number.isFinite(parsed) ? parsed : null;
            };
            const candleSeriesRaw = Array.isArray(data.kline_data) ? data.kline_data : [];
            const candleSeries = candleSeriesRaw.map(item => {
                const timestamp = convertTime(item.time);
                const close = safeNumber(item.close);
                const volume = safeNumber(item.volume);
                return {
                    timestamp,
                    close,
                    volume: Number.isFinite(volume) ? volume : 0,
                };
            }).filter(item => Number.isFinite(item.timestamp) && Number.isFinite(item.close));
            const candleTimestamps = candleSeries.map(item => item.timestamp);
            const volumePrefix = [];
            let volumeAccum = 0;
            candleSeries.forEach((item, idx) => {
                volumeAccum += item.volume;
                volumePrefix[idx] = volumeAccum;
            });
            const macdParams = chanConfig?.macd || DEFAULT_CHAN_CONFIG.macd;
            const macdFast = Number(macdParams?.fast) || DEFAULT_CHAN_CONFIG.macd.fast;
            const macdSlow = Number(macdParams?.slow) || DEFAULT_CHAN_CONFIG.macd.slow;
            const macdSignal = Number(macdParams?.signal) || DEFAULT_CHAN_CONFIG.macd.signal;
            const macdHistogram = candleSeries.length > 0
                ? calculateMacdHistogram(
                    candleSeries.map(item => item.close),
                    macdFast,
                    macdSlow,
                    macdSignal
                )
                : [];
            const macdAbsPrefix = [];
            let macdAccum = 0;
            macdHistogram.forEach((value, idx) => {
                const absVal = Number.isFinite(value) ? Math.abs(value) : 0;
                macdAccum += absVal;
                macdAbsPrefix[idx] = macdAccum;
            });
            const findCandleIndex = (ts) => {
                if (!Number.isFinite(ts) || candleTimestamps.length === 0) {
                    return null;
                }
                let left = 0;
                let right = candleTimestamps.length - 1;
                if (ts <= candleTimestamps[left]) return left;
                if (ts >= candleTimestamps[right]) return right;
                while (left <= right) {
                    const mid = Math.floor((left + right) / 2);
                    const midTs = candleTimestamps[mid];
                    if (midTs === ts) {
                        return mid;
                    }
                    if (midTs < ts) {
                        left = mid + 1;
                    } else {
                        right = mid - 1;
                    }
                }
                if (left >= candleTimestamps.length) return candleTimestamps.length - 1;
                if (right < 0) return 0;
                const leftDiff = Math.abs(candleTimestamps[left] - ts);
                const rightDiff = Math.abs(candleTimestamps[right] - ts);
                return leftDiff < rightDiff ? left : right;
            };
            const calcRangeMetrics = (startTs, endTs) => {
                if (!Number.isFinite(startTs) || !Number.isFinite(endTs) || candleTimestamps.length === 0) {
                    return {};
                }
                const startIdx = findCandleIndex(startTs);
                const endIdx = findCandleIndex(endTs);
                if (startIdx == null || endIdx == null) {
                    return {};
                }
                const minIdx = Math.min(startIdx, endIdx);
                const maxIdx = Math.max(startIdx, endIdx);
                const volume = volumePrefix.length > 0
                    ? volumePrefix[maxIdx] - (minIdx > 0 ? volumePrefix[minIdx - 1] : 0)
                    : null;
                const macdAbs = macdAbsPrefix.length > 0
                    ? macdAbsPrefix[maxIdx] - (minIdx > 0 ? macdAbsPrefix[minIdx - 1] : 0)
                    : null;
                return { volume, macdAbs };
            };
            const biStrength = computeStrengthComparison(
                buildStrengthMetrics(
                    data.bi_list || [],
                    (item) => {
                        const startTs = convertTime(item.begin_time);
                        const endTs = convertTime(item.end_time);
                        return { startTs, endTs };
                    },
                    (item) => {
                        const beginPrice = safeNumber(item.begin_price);
                        const endPrice = safeNumber(item.end_price);
                        return { beginPrice, endPrice };
                    },
                    (item) => item.dir || item.direction,
                    (item, idx) => item.label || `Á¨î#${item.idx ?? idx + 1}`,
                    calcRangeMetrics
                )
            );
            const segStrength = computeStrengthComparison(
                buildStrengthMetrics(
                    data.seg_list || [],
                    (item) => {
                        const startTs = convertTime(item.begin_time);
                        const endTs = convertTime(item.end_time);
                        return { startTs, endTs };
                    },
                    (item) => {
                        const beginPrice = safeNumber(item.begin_price);
                        const endPrice = safeNumber(item.end_price);
                        return { beginPrice, endPrice };
                    },
                    (item) => item.dir || item.direction,
                    (item, idx) => item.label || `ÊÆµ#${item.idx ?? idx + 1}`,
                    calcRangeMetrics
                )
            );
            return { biStrength, segStrength };
        };

        const BI_ALGO_OPTIONS = [
            { value: 'normal', label: 'normal' },
            { value: 'fx', label: 'fx' },
        ];

        const SEG_ALGO_OPTIONS = [
            { value: 'chan', label: 'chan' },
            { value: '1+1', label: '1+1 (deprecated)' },
            { value: 'break', label: 'break (deprecated)' },
        ];

        // ============= Data Cache =============
        const DataCache = {
            cache: {},
            get(key) {
                const item = this.cache[key];
                if (item && Date.now() - item.timestamp < 5 * 60 * 1000) {
                    return item.data;
                }
                return null;
            },
            set(key, data) {
                this.cache[key] = { data, timestamp: Date.now() };
            },
            clear() {
                this.cache = {};
            }
        };

        // ============= Utility Functions =============
        const convertTime = (timeStr) => {
            if (!timeStr) return null;
            let normalized = String(timeStr).trim().replace(/\//g, '-');
            if (!normalized.includes('T') && normalized.includes(' ')) {
                normalized = normalized.replace(' ', 'T');
            }
            normalized = normalized.replace(/(\.\d+)(?=[+-]|Z|$)/, '');
            if (/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}$/.test(normalized)) {
                normalized = `${normalized}:00`;
            }
            const parsed = dayjs(normalized);
            if (parsed.isValid()) {
                return parsed.valueOf();
            }
            const fallback = new Date(normalized.replace('T', ' '));
            const ts = fallback.getTime();
            return Number.isNaN(ts) ? null : ts;
        };

        let chanOverlayRegistered = false;
        const registerChanOverlay = () => {
            if (chanOverlayRegistered) return;
            if (typeof klinecharts === 'undefined' || typeof klinecharts.registerOverlay !== 'function') {
                return;
            }
            klinecharts.registerOverlay({
                name: 'chanZone',
                totalStep: 0,
                needDefaultPointFigure: false,
                createPointFigures: ({ coordinates, overlay }) => {
                    if (!Array.isArray(coordinates) || coordinates.length < 4) {
                        return [];
                    }
                    const [topLeft, topRight, bottomRight, bottomLeft] = coordinates;
                    const fillColor = overlay.extendData?.fillColor || 'rgba(255, 152, 0, 0.22)';
                    const borderColor = overlay.extendData?.borderColor || '#FF9800';
                    const borderDashed = overlay.extendData?.borderDashed ?? [4, 3];
                    const borderSize = typeof overlay.extendData?.borderSize === 'number' ? overlay.extendData.borderSize : 1;
                    const borderStyle = overlay.extendData?.borderStyle
                        || (Array.isArray(borderDashed) && borderDashed.length ? 'dashed' : 'solid');
                    const label = overlay.extendData?.label;
                    const textColor = overlay.extendData?.labelColor || borderColor;

                    const rect = {
                        type: 'rect',
                        attrs: {
                            x: Math.min(topLeft.x, bottomLeft.x),
                            y: Math.min(topLeft.y, topRight.y),
                            width: Math.max(2, Math.abs(topRight.x - topLeft.x)),
                            height: Math.max(2, Math.abs(bottomLeft.y - topLeft.y)),
                        },
                        styles: {
                            color: fillColor,
                            borderColor,
                            borderSize,
                            borderStyle,
                            ...(Array.isArray(borderDashed) && borderDashed.length
                                ? { borderDashedValue: borderDashed }
                                : {}),
                        },
                    };

                    const figures = [rect];
                    if (label) {
                        figures.push({
                            type: 'text',
                            attrs: {
                                x: Math.min(topLeft.x, topRight.x) + 6,
                                y: Math.min(topLeft.y, topRight.y) - 6,
                                text: label,
                                align: 'left',
                                baseline: 'bottom',
                            },
                            styles: {
                                color: textColor,
                                size: 10,
                                family: 'sans-serif',
                                weight: '600',
                            },
                        });
                    }
                    return figures;
                },
            });
            chanOverlayRegistered = true;
        };

        const formatDateTime = (timestamp) => {
            if (!timestamp) return '--';
            return dayjs(timestamp).format('YYYY-MM-DD HH:mm');
        };

        const formatNumber = (value, digits = 2) => {
            if (!Number.isFinite(value)) return '--';
            return Number(value).toFixed(digits);
        };

        const formatVolume = (value) => {
            if (!Number.isFinite(value) || value === 0) return '--';
            if (Math.abs(value) >= 1e8) {
                return `${(value / 1e8).toFixed(2)}‰∫ø`;
            }
            if (Math.abs(value) >= 1e4) {
                return `${(value / 1e4).toFixed(2)}‰∏á`;
            }
            return value.toFixed(0);
        };

        const getLineStyleConfig = (styleKey) => {
            switch (styleKey) {
                case 'dashed':
                    return { style: 'dashed', dashedValue: [6, 4] };
                case 'dotted':
                    return { style: 'dashed', dashedValue: [2, 2] };
                default:
                    return { style: 'solid', dashedValue: undefined };
            }
        };

        const hexToRgba = (hex, opacity = 0.3) => {
            if (!hex) return `rgba(255, 193, 7, ${opacity})`;
            let normalized = hex.replace('#', '');
            if (normalized.length === 3) {
                normalized = normalized.split('').map((char) => char + char).join('');
            }
            const bigint = parseInt(normalized, 16);
            const r = (bigint >> 16) & 255;
            const g = (bigint >> 8) & 255;
            const b = bigint & 255;
            return `rgba(${r}, ${g}, ${b}, ${opacity})`;
        };

        const debounce = (func, wait) => {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        };

        const clamp = (value, min, max) => Math.min(Math.max(value, min), max);

        // ============= Config Management =============
        const loadConfig = () => {
            try {
                const config = localStorage.getItem('chanlun_config');
                return config ? JSON.parse(config) : null;
            } catch (e) {
                debugError('Failed to load config:', e);
                return null;
            }
        };

        const sanitizeIndicators = (raw) => {
            if (!raw || typeof raw !== 'object') {
                return {};
            }
            const { bi_strict, seg_algo, zs_algo, bsp_filters, ...rest } = raw;
            let normalizedFilters = null;
            if (bsp_filters && typeof bsp_filters === 'object') {
                normalizedFilters = SignalUtils.normalizeFilters(bsp_filters);
            }
            return {
                ...rest,
                ...(normalizedFilters ? { bsp_filters: normalizedFilters } : {}),
            };
        };

        // ============= API Service =============
        const api = {
            async calculateChan(params) {
                debugLog('üåê [API] Request:', params);
                const response = await fetch(`${API_BASE}/api/analysis/calculate`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(params),
                });
                if (!response.ok) {
                    throw new Error(`API Error: ${response.statusText}`);
                }
                const result = await response.json();
                debugLog('üåê [API] Response:', {
                    chan_kline_count: result.kline_data?.length,
                    raw_kline_count: result.raw_kline_data?.length,
                    bi_count: result.bi_list?.length,
                    seg_count: result.seg_list?.length,
                });
                return result;
            },
            async getAlertHistory(limit = 50) {
                const response = await fetch(`${API_BASE}/api/alerts/history?limit=${limit}`);
                if (!response.ok) {
                    throw new Error(`API Error: ${response.statusText}`);
                }
                return response.json();
            },
            async listAlertStrategies() {
                const response = await fetch(`${API_BASE}/api/alerts/strategies`);
                if (!response.ok) {
                    throw new Error(`API Error: ${response.statusText}`);
                }
                return response.json();
            },
            async searchStocks(keyword) {
                if (!keyword || !keyword.trim()) {
                    return [];
                }
                const response = await fetch(`${API_BASE}/api/analysis/stock/search?keyword=${encodeURIComponent(keyword.trim())}`);
                if (!response.ok) {
                    throw new Error(`API Error: ${response.statusText}`);
                }
                const result = await response.json();
                return Array.isArray(result.results) ? result.results : [];
            },
            async listBacktestQueue() {
                const response = await fetch(`${API_BASE}/api/backtest/queue`);
                if (!response.ok) {
                    throw new Error(`API Error: ${response.statusText}`);
                }
                return response.json();
            },
            async enqueueBacktestJob(payload) {
                const response = await fetch(`${API_BASE}/api/backtest/queue`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload),
                });
                if (!response.ok) {
                    throw new Error(`API Error: ${response.statusText}`);
                }
                return response.json();
            },
            async runBacktestJob(jobId, options = {}) {
                const response = await fetch(`${API_BASE}/api/backtest/queue/${jobId}/run`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(options),
                });
                if (!response.ok) {
                    throw new Error(`API Error: ${response.statusText}`);
                }
                return response.json();
            },
            async deleteBacktestJob(jobId) {
                const response = await fetch(`${API_BASE}/api/backtest/queue/${jobId}`, {
                    method: 'DELETE',
                });
                if (!response.ok) {
                    throw new Error(`API Error: ${response.statusText}`);
                }
                return true;
            },
        };

        // ============= App Context =============
        const AppContext = createContext();
        const useApp = () => useContext(AppContext);

        // ============= Chart Component =============
        const ChartPanel = memo(({ stockCode, level, data, loading, stats, multiLevelStats }) => {
            const chartRef = useRef(null);
            const chartInstanceRef = useRef(null);
            const {
                indicators,
                theme,
                registerChartInstance,
                unregisterChartInstance,
                syncVisibleRange,
                setActiveLevels,
                chartFocusRequest,
                acknowledgeChartFocus,
            } = useApp();
            const chartKey = `${stockCode}-${level}`;
            const candleDataRef = useRef([]);
            const candleMapRef = useRef(new Map());
            const bspMapRef = useRef(new Map());
            const biListRef = useRef([]);
            const segListRef = useRef([]);
            const zsListRef = useRef([]);
            const timestampsRef = useRef([]);
            const lastHoverRef = useRef(null);
            const suppressBroadcastRef = useRef(false);
            const [hoverInfo, setHoverInfo] = useState(null);
            const [detailVisible, setDetailVisible] = useState(false);
            const [detailData, setDetailData] = useState(null);
            const [detailTab, setDetailTab] = useState('bi');
            const [summaryCollapsed, setSummaryCollapsed] = useState(false);
            const [preparedSignals, setPreparedSignals] = useState([]);

            const levelMeta = LEVEL_OPTIONS.find(option => option.value === level);
            const levelLabel = levelMeta?.label || level;

            const formatPercent = useCallback((value, digits = 2) => Number.isFinite(value) ? `${(value * 100).toFixed(digits)}%` : '--', []);
            const formatMinutes = useCallback((value) => Number.isFinite(value) ? value.toFixed(1) : '--', []);
            const directionLabel = useCallback((dir) => {
                if (dir === 'up') return 'Âêë‰∏ä';
                if (dir === 'down') return 'Âêë‰∏ã';
                return dir || '--';
            }, []);

            const normalizedBspFilters = useMemo(
                () => SignalUtils.normalizeFilters(indicators?.bsp_filters),
                [indicators?.bsp_filters]
            );

            const filterSignals = useCallback(
                (list) => SignalUtils.filterSignals(list, normalizedBspFilters),
                [normalizedBspFilters]
            );

            const requestLevelFocus = useCallback((targetLevel) => {
                if (!targetLevel || targetLevel === level) {
                    return;
                }
                setActiveLevels(prev => {
                    if (prev.includes(targetLevel)) {
                        return prev;
                    }
                    return [...prev, targetLevel];
                });
                if (!timestampsRef.current.length) {
                    return;
                }
                const chart = chartInstanceRef.current;
                if (!chart || typeof chart.getVisibleRange !== 'function') {
                    return;
                }
                const range = chart.getVisibleRange();
                if (!range) {
                    return;
                }
                const rawFrom = Number.isFinite(range.realFrom) ? range.realFrom : range.from;
                const rawTo = Number.isFinite(range.realTo) ? range.realTo : range.to;
                if (!Number.isFinite(rawFrom) || !Number.isFinite(rawTo)) {
                    return;
                }
                const minIdx = clamp(Math.floor(Math.min(rawFrom, rawTo)), 0, timestampsRef.current.length - 1);
                const maxIdx = clamp(Math.ceil(Math.max(rawFrom, rawTo)), 0, timestampsRef.current.length - 1);
                const fromTs = timestampsRef.current[minIdx];
                const toTs = timestampsRef.current[maxIdx];
                if (Number.isFinite(fromTs) && Number.isFinite(toTs)) {
                    syncVisibleRange(`${stockCode}-${level}`, fromTs, toTs);
                }
            }, [level, setActiveLevels, syncVisibleRange, stockCode]);

            const findNearestIndex = useCallback((timestamp) => {
                const list = timestampsRef.current;
                if (!Array.isArray(list) || list.length === 0 || !Number.isFinite(timestamp)) {
                    return null;
                }
                let left = 0;
                let right = list.length - 1;
                if (timestamp <= list[left]) return left;
                if (timestamp >= list[right]) return right;
                while (left <= right) {
                    const mid = Math.floor((left + right) / 2);
                    const midTs = list[mid];
                    if (midTs === timestamp) {
                        return mid;
                    }
                    if (midTs < timestamp) {
                        left = mid + 1;
                    } else {
                        right = mid - 1;
                    }
                }
                if (left >= list.length) return list.length - 1;
                if (right < 0) return 0;
                const leftDiff = Math.abs(list[left] - timestamp);
                const rightDiff = Math.abs(list[right] - timestamp);
                return leftDiff <= rightDiff ? left : right;
            }, []);

            const calcStructureSnapshot = useCallback((timestamp) => {
                if (!Number.isFinite(timestamp)) {
                    return { bi: [], seg: [], zs: [] };
                }

                const toMinutes = (startTs, endTs) => {
                    if (!Number.isFinite(startTs) || !Number.isFinite(endTs)) return null;
                    return Math.abs(endTs - startTs) / 60000;
                };

                const toProgress = (startTs, endTs) => {
                    const startIdx = findNearestIndex(startTs);
                    const endIdx = findNearestIndex(endTs);
                    const currentIdx = findNearestIndex(timestamp);
                    if (startIdx == null || endIdx == null || currentIdx == null) {
                        return null;
                    }
                    const span = endIdx - startIdx;
                    if (span === 0) {
                        return currentIdx >= endIdx ? 1 : 0;
                    }
                    const progress = (currentIdx - startIdx) / span;
                    return Math.min(1, Math.max(0, progress));
                };

                const resolveLinearStructures = (list, labelPrefix) => list
                    .filter(item => Number.isFinite(item.startTs) && Number.isFinite(item.endTs) && item.startTs <= item.endTs)
                    .filter(item => timestamp >= item.startTs && timestamp <= item.endTs)
                    .map(item => {
                        const amplitude = Number.isFinite(item.amplitude)
                            ? item.amplitude
                            : Number.isFinite(item.end_price) && Number.isFinite(item.begin_price)
                                ? Number(item.end_price) - Number(item.begin_price)
                                : null;
                        const beginPrice = Number.isFinite(item.begin_price) ? Number(item.begin_price) : null;
                        const amplitudePct = Number.isFinite(amplitude) && Number.isFinite(beginPrice) && beginPrice !== 0
                            ? amplitude / beginPrice
                            : null;
                        return {
                            id: item.idx ?? `${labelPrefix}-${item.startTs}-${item.endTs}`,
                            label: item.label || `${labelPrefix}${item.idx != null ? `#${item.idx}` : ''}`,
                            dir: item.dir || 'unknown',
                            beginTs: item.startTs,
                            endTs: item.endTs,
                            beginPrice,
                            endPrice: Number.isFinite(item.end_price) ? Number(item.end_price) : null,
                            amplitude,
                            amplitudePct,
                            durationMinutes: Number.isFinite(item.durationMinutes)
                                ? Number(item.durationMinutes)
                                : toMinutes(item.startTs, item.endTs),
                            progress: toProgress(item.startTs, item.endTs),
                        };
                    });

                const resolveZones = (list) => list
                    .filter(item => Number.isFinite(item.startTs) && Number.isFinite(item.endTs) && item.startTs <= item.endTs)
                    .filter(item => timestamp >= item.startTs && timestamp <= item.endTs)
                    .map(item => {
                        const range = Number.isFinite(item.range)
                            ? Number(item.range)
                            : (Number.isFinite(item.high) && Number.isFinite(item.low)
                                ? Number(item.high) - Number(item.low)
                                : null);
                        const base = Number.isFinite(item.low) ? Number(item.low) : null;
                        const rangePct = Number.isFinite(item.rangePct)
                            ? Number(item.rangePct)
                            : (Number.isFinite(range) && Number.isFinite(base) && base !== 0 ? range / base : null);
                        const duration = Number.isFinite(item.durationMinutes)
                            ? Number(item.durationMinutes)
                            : toMinutes(item.startTs, item.endTs);
                        return {
                            id: item.id ?? `zs-${item.startTs}-${item.endTs}`,
                            beginTs: item.startTs,
                            endTs: item.endTs,
                            high: Number.isFinite(item.high) ? Number(item.high) : null,
                            low: Number.isFinite(item.low) ? Number(item.low) : null,
                            range,
                            rangePct,
                            componentCount: item.componentCount ?? item.component_count ?? null,
                            componentUnit: item.component_unit,
                            isSure: item.is_sure === true || item.isSure === true,
                            source: item.source || 'bi',
                            durationMinutes: duration,
                        };
                    });

                return {
                    bi: resolveLinearStructures(biListRef.current, 'Á¨î'),
                    seg: resolveLinearStructures(segListRef.current, 'ÊÆµ'),
                    zs: resolveZones(zsListRef.current).filter(item => item.source === 'bi'),
                };
            }, [findNearestIndex]);

            const updateHoverInfo = useCallback((timestamp) => {
                if (!timestamp) {
                    lastHoverRef.current = null;
                    setHoverInfo(null);
                    return;
                }
                const candle = candleMapRef.current.get(timestamp);
                if (!candle) {
                    return;
                }
                const structures = calcStructureSnapshot(timestamp);
                const signals = bspMapRef.current.get(timestamp) || [];
                const prev = lastHoverRef.current;
                const structuresKey = `${structures.bi.length}:${structures.seg.length}:${structures.zs.length}`;
                if (prev && prev.timestamp === timestamp && prev.signalsLength === signals.length && prev.structuresKey === structuresKey) {
                    return;
                }
                lastHoverRef.current = { timestamp, signalsLength: signals.length, structuresKey };
                setHoverInfo({
                    timestamp,
                    open: candle.open,
                    high: candle.high,
                    low: candle.low,
                    close: candle.close,
                    volume: candle.volume,
                    signals: signals.map(item => {
                        const numericPrice = Number.parseFloat(item.price);
                        return {
                            type: item.type,
                            typeKey: SignalUtils.normalizeBspType(item.type),
                            isBuy: !!item.is_buy,
                            price: Number.isFinite(numericPrice) ? numericPrice : null,
                            reason: item.reason || item.reason_text || null,
                            reasonDetails: Array.isArray(item.reason_details)
                                ? item.reason_details
                                : (Array.isArray(item.reasonDetails) ? item.reasonDetails : null),
                            context: item.context || null,
                            relate: item.relate_bsp1 || null,
                            features: item.features || null,
                        };
                    }),
                    structures,
                });
            }, [calcStructureSnapshot]);

            const focusOnTimestamp = useCallback((timestamp) => {
                if (!Number.isFinite(timestamp)) {
                    return;
                }
                const chart = chartInstanceRef.current;
                if (!chart) {
                    return;
                }
                const idx = findNearestIndex(timestamp);
                if (idx == null) {
                    return;
                }
                if (typeof chart.scrollToDataIndex === 'function') {
                    suppressBroadcastRef.current = true;
                    chart.scrollToDataIndex(idx, 0.3);
                } else if (typeof chart.scrollToTimestamp === 'function') {
                    suppressBroadcastRef.current = true;
                    chart.scrollToTimestamp(timestamp, 0.3);
                }
                const window = 30;
                const fromIdx = Math.max(0, idx - window);
                const toIdx = Math.min(timestampsRef.current.length - 1, idx + window);
                const fromTs = timestampsRef.current[fromIdx];
                    const toTs = timestampsRef.current[toIdx];
                    if (Number.isFinite(fromTs) && Number.isFinite(toTs)) {
                        syncVisibleRange(chartKey, fromTs, toTs);
                    }
            }, [findNearestIndex, syncVisibleRange, chartKey]);

            const buildStructureSnapshot = useCallback(() => ({
                generatedAt: new Date().toISOString(),
                stockCode,
                level,
                levelLabel,
                bi: biListRef.current.map(item => ({ ...item })),
                seg: segListRef.current.map(item => ({ ...item })),
                zs: zsListRef.current.map(item => ({ ...item })),
            }), [stockCode, level, levelLabel]);

            const openStructureDetail = useCallback(() => {
                const snapshot = buildStructureSnapshot();
                setDetailData(snapshot);
                if (snapshot.bi.length > 0) {
                    setDetailTab('bi');
                } else if (snapshot.seg.length > 0) {
                    setDetailTab('seg');
                } else if (snapshot.zs.length > 0) {
                    setDetailTab('zs');
                } else {
                    setDetailTab('bi');
                }
                setDetailVisible(true);
            }, [buildStructureSnapshot]);

            const closeStructureDetail = useCallback(() => {
                setDetailVisible(false);
                setDetailTab('bi');
                setDetailData(null);
            }, []);

            const exportStructureCsv = useCallback((type) => {
                if (!detailData) {
                    message.warning('ÊöÇÊó†ÁªìÊûÑÊï∞ÊçÆ');
                    return;
                }
                const map = {
                    bi: detailData.bi || [],
                    seg: detailData.seg || [],
                    zs: detailData.zs || [],
                };
                const rows = map[type] || [];
                if (!rows || rows.length === 0) {
                    message.warning('ËØ•ÁªìÊûÑÊöÇÊó†Êï∞ÊçÆ');
                    return;
                }

                let columns = [];
                if (type === 'bi' || type === 'seg') {
                    columns = [
                        { header: 'Â∫èÂè∑', accessor: (row, idx) => row.order ?? row.idx ?? idx + 1 },
                        { header: 'ÊñπÂêë', accessor: (row) => directionLabel(row.dir) },
                        { header: 'Ëµ∑ÂßãÊó∂Èó¥', accessor: (row) => formatDateTime(row.startTs) },
                        { header: 'ÁªìÊùüÊó∂Èó¥', accessor: (row) => formatDateTime(row.endTs) },
                        { header: 'Ëµ∑‰ª∑', accessor: (row) => Number.isFinite(row.begin_price) ? row.begin_price : '' },
                        { header: 'Áªà‰ª∑', accessor: (row) => Number.isFinite(row.end_price) ? row.end_price : '' },
                        { header: 'ÊåØÂπÖ', accessor: (row) => Number.isFinite(row.amplitude) ? row.amplitude : '' },
                        { header: 'ÊåØÂπÖ%', accessor: (row) => Number.isFinite(row.amplitudePct) ? (row.amplitudePct * 100).toFixed(2) + '%' : '' },
                        { header: 'ËÄóÊó∂(ÂàÜ)', accessor: (row) => Number.isFinite(row.durationMinutes) ? row.durationMinutes : '' },
                    ];
                } else {
                    columns = [
                        { header: 'Á±ªÂûã', accessor: (row) => row.source === 'seg' ? 'ÊÆµ‰∏≠Êû¢' : 'Á¨î‰∏≠Êû¢' },
                        { header: 'Áä∂ÊÄÅ', accessor: (row) => row.is_sure ? 'Á°ÆÂÆö' : 'Êú™Á°ÆËÆ§' },
                        { header: 'Ëµ∑ÂßãÊó∂Èó¥', accessor: (row) => formatDateTime(row.startTs) },
                        { header: 'ÁªìÊùüÊó∂Èó¥', accessor: (row) => formatDateTime(row.endTs) },
                        { header: '‰∏ãÊ≤ø', accessor: (row) => Number.isFinite(row.low) ? row.low : '' },
                        { header: '‰∏äÊ≤ø', accessor: (row) => Number.isFinite(row.high) ? row.high : '' },
                        { header: 'ÂÆΩÂ∫¶', accessor: (row) => Number.isFinite(row.range) ? row.range : '' },
                        { header: 'ÂÆΩÂ∫¶%', accessor: (row) => Number.isFinite(row.rangePct) ? (row.rangePct * 100).toFixed(2) + '%' : '' },
                        { header: 'ÁªÑÊàêÊï∞', accessor: (row) => row.componentCount ?? row.component_count ?? '' },
                        { header: 'ÁªÑÊàêÂçï‰Ωç', accessor: (row) => row.component_unit ?? '' },
                        { header: 'ËÄóÊó∂(ÂàÜ)', accessor: (row) => Number.isFinite(row.durationMinutes) ? row.durationMinutes : '' },
                    ];
                }

                const headerRow = columns.map(col => col.header).join(',');
                const lines = rows.map((row, rowIdx) => columns.map(col => {
                    const raw = col.accessor(row, rowIdx);
                    if (raw === null || raw === undefined) {
                        return '';
                    }
                    const value = typeof raw === 'number' && Number.isFinite(raw) ? raw : `${raw}`;
                    const sanitized = `${value}`.replace(/"/g, '""');
                    return `"${sanitized}"`;
                }).join(','));
                const csvContent = [headerRow, ...lines].join('\n');

                try {
                    const blob = new Blob(["\uFEFF" + csvContent], { type: 'text/csv;charset=utf-8;' });
                    const url = URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    link.href = url;
                    link.setAttribute('download', `${stockCode}_${level}_${type}_structures.csv`);
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    URL.revokeObjectURL(url);
                    message.success('CSV ÂØºÂá∫ÂÆåÊàê');
                } catch (err) {
                    debugWarn('CSV export failed', err);
                    message.error('ÂØºÂá∫Â§±Ë¥•ÔºåËØ∑Ê£ÄÊü•ÊµèËßàÂô®ÊùÉÈôê');
                }
            }, [detailData, directionLabel, level, stockCode]);

            const detailTabsConfig = useMemo(() => {
                if (!detailData) {
                    return [];
                }

                const biColumns = [
                    {
                        title: 'Â∫èÂè∑',
                        dataIndex: 'order',
                        width: 70,
                        render: (value, row, index) => value ?? row.idx ?? index + 1,
                    },
                    {
                        title: 'ÊñπÂêë',
                        dataIndex: 'dir',
                        width: 70,
                        render: (value) => directionLabel(value),
                    },
                    {
                        title: 'Ëµ∑‰ª∑',
                        dataIndex: 'begin_price',
                        width: 90,
                        render: (value) => Number.isFinite(value) ? formatNumber(value, 2) : '--',
                    },
                    {
                        title: 'Áªà‰ª∑',
                        dataIndex: 'end_price',
                        width: 90,
                        render: (value) => Number.isFinite(value) ? formatNumber(value, 2) : '--',
                    },
                    {
                        title: 'ÊåØÂπÖ',
                        dataIndex: 'amplitude',
                        width: 90,
                        render: (value) => Number.isFinite(value) ? formatNumber(value, 2) : '--',
                    },
                    {
                        title: 'ÊåØÂπÖ%',
                        dataIndex: 'amplitudePct',
                        width: 90,
                        render: (value) => formatPercent(value),
                    },
                    {
                        title: 'Ëµ∑ÂßãÊó∂Èó¥',
                        dataIndex: 'startTs',
                        width: 180,
                        render: (value) => formatDateTime(value),
                    },
                    {
                        title: 'ÁªìÊùüÊó∂Èó¥',
                        dataIndex: 'endTs',
                        width: 180,
                        render: (value) => formatDateTime(value),
                    },
                    {
                        title: 'ËÄóÊó∂(ÂàÜ)',
                        dataIndex: 'durationMinutes',
                        width: 100,
                        render: (value) => formatMinutes(value),
                    },
                ];

                const segColumns = [
                    {
                        title: 'Â∫èÂè∑',
                        dataIndex: 'order',
                        width: 70,
                        render: (value, row, index) => value ?? row.idx ?? index + 1,
                    },
                    {
                        title: 'ÊñπÂêë',
                        dataIndex: 'dir',
                        width: 70,
                        render: (value) => directionLabel(value),
                    },
                    {
                        title: 'Ëµ∑‰ª∑',
                        dataIndex: 'begin_price',
                        width: 90,
                        render: (value) => Number.isFinite(value) ? formatNumber(value, 2) : '--',
                    },
                    {
                        title: 'Áªà‰ª∑',
                        dataIndex: 'end_price',
                        width: 90,
                        render: (value) => Number.isFinite(value) ? formatNumber(value, 2) : '--',
                    },
                    {
                        title: 'ÊåØÂπÖ',
                        dataIndex: 'amplitude',
                        width: 90,
                        render: (value) => Number.isFinite(value) ? formatNumber(value, 2) : '--',
                    },
                    {
                        title: 'ÊåØÂπÖ%',
                        dataIndex: 'amplitudePct',
                        width: 90,
                        render: (value) => formatPercent(value),
                    },
                    {
                        title: 'Ëµ∑ÂßãÊó∂Èó¥',
                        dataIndex: 'startTs',
                        width: 180,
                        render: (value) => formatDateTime(value),
                    },
                    {
                        title: 'ÁªìÊùüÊó∂Èó¥',
                        dataIndex: 'endTs',
                        width: 180,
                        render: (value) => formatDateTime(value),
                    },
                    {
                        title: 'ËÄóÊó∂(ÂàÜ)',
                        dataIndex: 'durationMinutes',
                        width: 100,
                        render: (value) => formatMinutes(value),
                    },
                ];

                const zsColumns = [
                    {
                        title: 'Á±ªÂûã',
                        dataIndex: 'source',
                        width: 90,
                        render: (value) => value === 'seg' ? 'ÊÆµ‰∏≠Êû¢' : 'Á¨î‰∏≠Êû¢',
                    },
                    {
                        title: 'Áä∂ÊÄÅ',
                        dataIndex: 'is_sure',
                        width: 90,
                        render: (value, row) => (value || row.isSure) ? 'Á°ÆÂÆö' : 'Êú™Á°ÆËÆ§',
                    },
                    {
                        title: '‰∏ãÊ≤ø',
                        dataIndex: 'low',
                        width: 90,
                        render: (value) => Number.isFinite(value) ? formatNumber(value, 2) : '--',
                    },
                    {
                        title: '‰∏äÊ≤ø',
                        dataIndex: 'high',
                        width: 90,
                        render: (value) => Number.isFinite(value) ? formatNumber(value, 2) : '--',
                    },
                    {
                        title: 'ÂÆΩÂ∫¶',
                        dataIndex: 'range',
                        width: 90,
                        render: (value) => Number.isFinite(value) ? formatNumber(value, 2) : '--',
                    },
                    {
                        title: 'ÂÆΩÂ∫¶%',
                        dataIndex: 'rangePct',
                        width: 90,
                        render: (value) => formatPercent(value),
                    },
                    {
                        title: 'ÁªÑÊàêÊï∞',
                        dataIndex: 'componentCount',
                        width: 90,
                        render: (value, row) => value ?? row.component_count ?? '--',
                    },
                    {
                        title: 'ÁªÑÊàêÂçï‰Ωç',
                        dataIndex: 'component_unit',
                        width: 100,
                        render: (value) => value || '--',
                    },
                    {
                        title: 'Ëµ∑ÂßãÊó∂Èó¥',
                        dataIndex: 'startTs',
                        width: 180,
                        render: (value) => formatDateTime(value),
                    },
                    {
                        title: 'ÁªìÊùüÊó∂Èó¥',
                        dataIndex: 'endTs',
                        width: 180,
                        render: (value) => formatDateTime(value),
                    },
                    {
                        title: 'ËÄóÊó∂(ÂàÜ)',
                        dataIndex: 'durationMinutes',
                        width: 100,
                        render: (value) => formatMinutes(value),
                    },
                ];

                const buildTable = (type, columns, data) => (
                    <Space direction="vertical" size="small" style={{ width: '100%' }}>
                        <Space size="small">
                            <Button
                                size="small"
                                onClick={() => exportStructureCsv(type)}
                                disabled={data.length === 0}
                            >
                                ÂØºÂá∫CSV
                            </Button>
                            <span className="chart-info-placeholder">
                                ÂÖ± {data.length} Êù°
                            </span>
                        </Space>
                        <Table
                            size="small"
                            columns={columns}
                            dataSource={data}
                            pagination={{ pageSize: 12, showSizeChanger: false, hideOnSinglePage: true }}
                            rowKey={(row, index) => row.id ?? row.idx ?? row.order ?? `${type}-${index}`}
                            scroll={{ x: 780 }}
                        />
                    </Space>
                );

                return [
                    {
                        key: 'bi',
                        label: `Á¨î (${detailData.bi.length})`,
                        children: buildTable('bi', biColumns, detailData.bi),
                    },
                    {
                        key: 'seg',
                        label: `Á∫øÊÆµ (${detailData.seg.length})`,
                        children: buildTable('seg', segColumns, detailData.seg),
                    },
                    {
                        key: 'zs',
                        label: `‰∏≠Êû¢ (${detailData.zs.length})`,
                        children: buildTable('zs', zsColumns, detailData.zs),
                    },
                ];
            }, [detailData, directionLabel, exportStructureCsv, formatMinutes, formatPercent]);
            const getIndexRangeForTimestamps = useCallback((fromTs, toTs) => {
                const list = timestampsRef.current;
                if (!Array.isArray(list) || list.length === 0) {
                    debugLog('‚ö†Ô∏è [IndexRange] empty timestamps', chartKey);
                    return null;
                }
                const fromIdx = findNearestIndex(fromTs);
                const toIdx = findNearestIndex(toTs);
                if (fromIdx == null || toIdx == null) {
                    debugLog('‚ö†Ô∏è [IndexRange] nearest index missing', chartKey, { fromTs, toTs, fromIdx, toIdx });
                    return null;
                }
                const start = Math.min(fromIdx, toIdx);
                const end = Math.max(fromIdx, toIdx);
                const padding = Math.max(2, Math.floor((end - start) * 0.05));
                const minIdx = clamp(start - padding, 0, list.length - 1);
                const maxIdx = clamp(end + padding, 0, list.length - 1);
                debugLog('üßÆ [IndexRange]', chartKey, { fromTs, toTs, fromIdx: minIdx, toIdx: maxIdx, total: list.length });
                if (minIdx === maxIdx && list.length > 1) {
                    const extra = Math.min(5, list.length - 1);
                    return [clamp(minIdx - 2, 0, list.length - 1), clamp(maxIdx + extra, 0, list.length - 1)];
                }
                return [minIdx, maxIdx];
            }, [findNearestIndex]);

            useEffect(() => {
                if (!chartRef.current || !data) {
                    setHoverInfo(null);
                    timestampsRef.current = [];
                    biListRef.current = [];
                    segListRef.current = [];
                    zsListRef.current = [];
                    setPreparedSignals([]);
                    return;
                }

                // Reset cached data
                candleDataRef.current = [];
                candleMapRef.current = new Map();
                bspMapRef.current = new Map();
                timestampsRef.current = [];
                biListRef.current = [];
                segListRef.current = [];
                zsListRef.current = [];
                lastHoverRef.current = null;
                setHoverInfo(null);

                // Initialize KLineChart
                const chart = klinecharts.init(chartRef.current);
                chartInstanceRef.current = chart;

                // Apply theme
                chart.setStyles({
                    grid: {
                        show: true,
                        horizontal: {
                            show: true,
                            color: theme === 'dark' ? '#333' : '#f0f0f0',
                        },
                        vertical: {
                            show: true,
                            color: theme === 'dark' ? '#333' : '#f0f0f0',
                        }
                    },
                    candle: {
                        type: 'candle_solid',
                        bar: {
                            upColor: '#ef5350',
                            downColor: '#26a69a',
                            noChangeColor: '#888888',
                            upBorderColor: 'rgba(0,0,0,0)',
                            downBorderColor: 'rgba(0,0,0,0)',
                            noChangeBorderColor: 'rgba(0,0,0,0)',
                            upWickColor: '#ef5350',
                            downWickColor: '#26a69a',
                            noChangeWickColor: '#888888',
                        },
                        tooltip: {
                            showRule: 'none',
                            showType: 'standard',
                        }
                    },
                    indicator: {
                        tooltip: {
                            showRule: 'none',
                        }
                    }
                });

                // Prepare candle data
                const chanKlineMeta = Array.isArray(data.kline_data) ? data.kline_data : [];
                const rawChildMap = new Map();
                chanKlineMeta.forEach(item => {
                    if (!Array.isArray(item.chan_children)) {
                        return;
                    }
                    item.chan_children.forEach(child => {
                        const ts = convertTime(child.time);
                        if (!ts || rawChildMap.has(ts)) {
                            return;
                        }
                        rawChildMap.set(ts, {
                            timestamp: ts,
                            open: parseFloat(child.open),
                            high: parseFloat(child.high),
                            low: parseFloat(child.low),
                            close: parseFloat(child.close),
                            volume: parseFloat(child.volume || 0),
                        });
                    });
                });

                const fallbackCandles = (data.kline_data || []).map(k => ({
                    timestamp: convertTime(k.time),
                    open: parseFloat(k.open),
                    high: parseFloat(k.high),
                    low: parseFloat(k.low),
                    close: parseFloat(k.close),
                    volume: parseFloat(k.volume || 0),
                })).filter(k => k.timestamp !== null);
                const rawCandles = Array.from(rawChildMap.values()).sort((a, b) => a.timestamp - b.timestamp);
                const candleData = rawCandles.length > 0 ? rawCandles : fallbackCandles;
                candleDataRef.current = candleData;
                timestampsRef.current = candleData.map(item => item.timestamp);

                const candleMap = new Map();
                candleData.forEach(item => {
                    candleMap.set(item.timestamp, item);
                });
                candleMapRef.current = candleMap;

                const rawBspList = Array.isArray(data.bsp_list) ? data.bsp_list : [];
                const filteredBspList = filterSignals(rawBspList);
                const bspMap = new Map();
                filteredBspList.forEach(bsp => {
                    const ts = convertTime(bsp.time);
                    if (!ts) return;
                    if (!bspMap.has(ts)) {
                        bspMap.set(ts, []);
                    }
                    bspMap.get(ts).push(bsp);
                });
                bspMapRef.current = bspMap;
                if (indicators.plot_bsp) {
                    const prepared = SignalUtils.sortByTimestampDesc(filteredBspList, convertTime).map(item => {
                        const numericPrice = Number.parseFloat(item.price);
                        return {
                            ...item,
                            price: Number.isFinite(numericPrice) ? numericPrice : null,
                            typeKey: SignalUtils.normalizeBspType(item.type),
                        };
                    });
                    setPreparedSignals(prepared);
                } else {
                    setPreparedSignals([]);
                }

                biListRef.current = Array.isArray(data.bi_list)
                    ? data.bi_list.map((bi, idx) => {
                        const startTs = convertTime(bi.begin_time);
                        let endTs = convertTime(bi.end_time);
                        if (!Number.isFinite(endTs) && Number.isFinite(startTs)) {
                            endTs = startTs;
                        }
                        const beginPrice = parseFloat(bi.begin_price);
                        const endPrice = parseFloat(bi.end_price);
                        return {
                            ...bi,
                            idx: typeof bi.idx === 'number' ? bi.idx : idx,
                            order: idx + 1,
                            startTs,
                            endTs,
                            begin_price: Number.isFinite(beginPrice) ? beginPrice : null,
                            end_price: Number.isFinite(endPrice) ? endPrice : null,
                            amplitude: (Number.isFinite(endPrice) && Number.isFinite(beginPrice))
                                ? endPrice - beginPrice
                                : null,
                            label: `Á¨¨${idx + 1}Á¨î`,
                        };
                    }).filter(item => Number.isFinite(item.startTs) && Number.isFinite(item.endTs))
                    : [];

                segListRef.current = Array.isArray(data.seg_list)
                    ? data.seg_list.map((seg, idx) => {
                        const startTs = convertTime(seg.begin_time);
                        let endTs = convertTime(seg.end_time);
                        if (!Number.isFinite(endTs) && Number.isFinite(startTs)) {
                            endTs = startTs;
                        }
                        const beginPrice = parseFloat(seg.begin_price);
                        const endPrice = parseFloat(seg.end_price);
                        return {
                            ...seg,
                            idx: typeof seg.idx === 'number' ? seg.idx : idx,
                            order: idx + 1,
                            startTs,
                            endTs,
                            begin_price: Number.isFinite(beginPrice) ? beginPrice : null,
                            end_price: Number.isFinite(endPrice) ? endPrice : null,
                            amplitude: (Number.isFinite(endPrice) && Number.isFinite(beginPrice))
                                ? endPrice - beginPrice
                                : null,
                            label: `Á¨¨${idx + 1}ÊÆµ`,
                        };
                    }).filter(item => Number.isFinite(item.startTs) && Number.isFinite(item.endTs))
                    : [];

                const normalizeZsList = (sourceList, sourceLabel) => Array.isArray(sourceList)
                    ? sourceList.map((zs, idx) => {
                        const startTs = convertTime(zs.begin_time ?? zs.begin ?? zs.start_time);
                        let endTs = convertTime(zs.end_time ?? zs.end ?? zs.finish_time);
                        if (!Number.isFinite(endTs) && Number.isFinite(startTs)) {
                            endTs = startTs;
                        }
                        const high = parseFloat(zs.high);
                        const low = parseFloat(zs.low);
                        const range = Number.isFinite(high) && Number.isFinite(low) ? high - low : null;
                        const base = Number.isFinite(low) ? low : null;
                        const rangePct = Number.isFinite(range) && Number.isFinite(base) && base !== 0 ? range / base : null;
                        const componentCountRaw = zs.component_count ?? zs.bi_count ?? zs.componentCnt ?? zs.count ??
                            (Array.isArray(zs.bi_lst) ? zs.bi_lst.length : Array.isArray(zs.component_list) ? zs.component_list.length : null);
                        const normalizedComponentCount = Number.isFinite(componentCountRaw) ? Number(componentCountRaw) : componentCountRaw ?? null;
                        const durationMinutes = Number.isFinite(startTs) && Number.isFinite(endTs)
                            ? Math.abs(endTs - startTs) / 60000
                            : null;
                        const isSure = zs.is_sure === true || zs.isSure === true;
                        return {
                            ...zs,
                            id: zs.id ?? `${sourceLabel}_zs_${idx}`,
                            startTs,
                            endTs,
                            high: Number.isFinite(high) ? high : null,
                            low: Number.isFinite(low) ? low : null,
                            range,
                            rangePct,
                            durationMinutes,
                            componentCount: normalizedComponentCount,
                            component_count: normalizedComponentCount,
                            component_unit: zs.component_unit || (sourceLabel === 'seg' ? 'ÊÆµ' : 'Á¨î'),
                            source: sourceLabel,
                            is_sure: isSure,
                            isSure,
                        };
                    }).filter(item => Number.isFinite(item.startTs) && Number.isFinite(item.endTs))
                    : [];

                const biZs = normalizeZsList(data.zs_list, 'bi');
                const segZs = normalizeZsList(data.seg_zs_list, 'seg');
                zsListRef.current = [...biZs, ...segZs];
                if (detailVisible) {
                    setDetailData(buildStructureSnapshot());
                }

                debugLog('üìä [KLineChart] Loading', candleData.length, 'candles');
                chart.applyNewData(candleData);

                if (indicators.highlight_chan_kline && chanKlineMeta.length > 0) {
                    debugLog('üß© Chan K-line stats', chanKlineMeta.slice(0, 3));
                    const chanBorderColor = indicators.chan_kline_color || '#FF9800';
                    const borderDashed = [4, 3];
                    registerChanOverlay();
                    try {
                        const removed = chart.removeOverlay({ groupId: 'chan_kline_group' });
                        if (removed) {
                            debugLog('üßπ Cleared Chan K-line overlays:', removed.length);
                        }
                    } catch (error) {
                        debugWarn('‚ö†Ô∏è Unable to clear previous Chan K-line overlays', error);
                    }

                    const composedCount = chanKlineMeta.filter(item => (item.chan_sub_count ?? item.sub_count ?? 1) > 1).length;
                    chanKlineMeta.forEach((item, idx) => {
                        const subCount = Number(item.chan_sub_count ?? item.sub_count ?? item.components ?? 1);
                        const isComposed = item.chan_is_composed === true || subCount > 1;
                        if (!isComposed) {
                            return;
                        }

                        let startTs = convertTime(item.time);
                        if (!startTs) {
                            return;
                        }

                        let endTs = convertTime(item.end_time);
                        const children = Array.isArray(item.chan_children) ? item.chan_children : [];
                        let highVal = Number(item.high);
                        let lowVal = Number(item.low);
                        if (children.length > 0) {
                            const childStart = convertTime(children[0]?.time);
                            const childEnd = convertTime(children[children.length - 1]?.end_time || children[children.length - 1]?.time);
                            if (childStart) {
                                startTs = childStart;
                            }
                            if (childEnd && childEnd > startTs) {
                                endTs = childEnd;
                            }
                            const childHighs = children.map(child => Number(child.high)).filter(Number.isFinite);
                            const childLows = children.map(child => Number(child.low)).filter(Number.isFinite);
                            if (!Number.isFinite(highVal) && childHighs.length > 0) {
                                highVal = Math.max(...childHighs);
                            }
                            if (!Number.isFinite(lowVal) && childLows.length > 0) {
                                lowVal = Math.min(...childLows);
                            }
                        }

                        const nextChanStart = convertTime(chanKlineMeta[idx + 1]?.time);
                        if (!endTs || endTs <= startTs) {
                            if (nextChanStart && nextChanStart > startTs) {
                                endTs = nextChanStart;
                            } else {
                                const prevChanStart = convertTime(chanKlineMeta[idx - 1]?.time);
                                const averageSpan = prevChanStart && startTs > prevChanStart ? startTs - prevChanStart : 60000;
                                endTs = startTs + Math.max(averageSpan, 60000);
                            }
                        }

                        if (nextChanStart && nextChanStart > endTs) {
                            endTs = Math.min(endTs, nextChanStart);
                        }

                        if (!Number.isFinite(highVal) || !Number.isFinite(lowVal)) {
                            return;
                        }

                        const showLabel = !!indicators.chan_kline_show_label;

                        const fillColor = theme === 'dark'
                            ? 'rgba(255, 152, 0, 0.16)'
                            : 'rgba(255, 152, 0, 0.26)';
                        const labelColor = theme === 'dark' ? '#FFE0B2' : '#B36B00';

                        const overlayId = chart.createOverlay({
                            name: 'chanZone',
                            id: `chan_kline_${idx}`,
                            groupId: 'chan_kline_group',
                            paneId: 'candle_pane',
                            points: [
                                { timestamp: startTs, value: highVal },
                                { timestamp: endTs, value: highVal },
                                { timestamp: endTs, value: lowVal },
                                { timestamp: startTs, value: lowVal },
                            ],
                            extendData: {
                                fillColor,
                                borderColor: chanBorderColor,
                                borderDashed,
                                label: showLabel ? `${subCount}K` : undefined,
                                labelColor,
                            },
                        });

                        if (idx < 5) {
                            debugLog('üî∂ Chan K-line highlight', {
                                index: idx,
                                overlayId,
                                timestamp: startTs,
                                end: endTs,
                                high: highVal,
                                low: lowVal,
                                subCount,
                            });
                        }
                    });
                    debugLog('‚ú® Highlighted Chan K-lines:', composedCount);
                } else {
                    try {
                        chart.removeOverlay({ groupId: 'chan_kline_group' });
                    } catch (error) {
                        // ignore when overlay absent
                    }
                }

                const indicatorLayout = indicators.indicator_layout || 'stack';
                const availableLower = LOWER_INDICATOR_KEYS.filter(key => indicators[`plot_${key}`]);
                let activeLower = availableLower;
                let activeTab = indicators.indicator_tab;
                if (indicatorLayout === 'tab') {
                    if (!availableLower.includes(activeTab)) {
                        activeTab = availableLower[0];
                    }
                    activeLower = activeTab ? [activeTab] : [];
                }

                const panes = [];
                if (indicators.plot_volume) {
                    panes.push({ name: 'VOL', paneId: 'vol_pane', type: 'volume' });
                }
                activeLower.forEach(key => {
                    panes.push({
                        name: key.toUpperCase(),
                        paneId: `${key}_pane`,
                        type: 'indicator',
                    });
                });

                const totalPanes = panes.length;
                let heightMap = {};
                if (indicatorLayout === 'tab') {
                    panes.forEach(pane => {
                        heightMap[pane.paneId] = pane.type === 'volume' ? 160 : 240;
                    });
                } else {
                    panes.forEach((pane, idx) => {
                        if (pane.type === 'volume') {
                            heightMap[pane.paneId] = Math.max(120, 180 - 20 * (totalPanes - 1 - idx));
                        } else {
                            heightMap[pane.paneId] = Math.max(150, 220 - 10 * (totalPanes - 1));
                        }
                    });
                }

                panes.forEach(pane => {
                    chart.createIndicator(pane.name, false, {
                        id: pane.paneId,
                        height: heightMap[pane.paneId],
                    });
                });

                // Adjust main pane height when lower panes exist
                if (typeof chart.setPaneOptions === 'function') {
                    try {
                        const lowerSpace = panes.length > 0 ? Math.min(0.45, panes.length * 0.14) : 0.0;
                        chart.setPaneOptions({ id: 'candle_pane', height: 1 - lowerSpace });
                    } catch (error) {
                        debugWarn('‚ö†Ô∏è Unable to adjust candle pane height', error);
                    }
                }

                // Add MA overlays
                if (indicators.plot_ma && indicators.ma_params && indicators.ma_params.length > 0) {
                    const maParams = indicators.ma_params
                        .map(Number)
                        .filter(value => Number.isFinite(value) && value > 0)
                        .slice(0, 6);
                    if (maParams.length > 0) {
                        chart.createIndicator('MA', true, { id: 'candle_pane' }, {
                            calcParams: maParams,
                        });
                    }
                }

                // Add BOLL overlay
                if (indicators.plot_boll) {
                    chart.createIndicator('BOLL', true, { id: 'candle_pane' });
                }

                // ========== Áº†ËÆ∫ÊåáÊ†áÁªòÂà∂ ==========
                
                // 1. ÁªòÂà∂Á¨î (Bi) - ËìùËâ≤ÊäòÁ∫ø
                if (indicators.plot_bi && data.bi_list && data.bi_list.length > 0) {
                    debugLog('üìä [Bi] Adding', data.bi_list.length, 'segments');
                    data.bi_list.forEach((bi, idx) => {
                        const beginTime = convertTime(bi.begin_time);
                        const endTime = convertTime(bi.end_time);
                        const biColor = indicators.bi_color || '#2196F3';
                        const biWidth = Number(indicators.bi_line_width) || 2;
                        const biStyleConfig = getLineStyleConfig(indicators.bi_line_style);
                        
                        if (beginTime && endTime) {
                            chart.createOverlay({
                                name: 'segment',
                                id: `bi_${idx}`,
                                groupId: 'bi_group',
                                paneId: 'candle_pane',
                                points: [
                                    { timestamp: beginTime, value: parseFloat(bi.begin_price) },
                                    { timestamp: endTime, value: parseFloat(bi.end_price) }
                                ],
                                styles: {
                                    line: {
                                        style: biStyleConfig.style,
                                        size: biWidth,
                                        color: biColor,
                                        ...(biStyleConfig.dashedValue ? { dashedValue: biStyleConfig.dashedValue } : {})
                                    }
                                }
                            });
                        }
                    });
                    debugLog('‚úÖ [Bi] Added successfully');
                }

                // 2. ÁªòÂà∂Á∫øÊÆµ (Seg) - Á¥´Ëâ≤Á≤óÁ∫ø
                if (indicators.plot_seg && data.seg_list && data.seg_list.length > 0) {
                    debugLog('üìä [Seg] Adding', data.seg_list.length, 'segments');
                    data.seg_list.forEach((seg, idx) => {
                        const beginTime = convertTime(seg.begin_time);
                        const endTime = convertTime(seg.end_time);
                        const segColor = indicators.seg_color || '#9C27B0';
                        const segWidth = Number(indicators.seg_line_width) || 3;
                        const segStyleConfig = getLineStyleConfig(indicators.seg_line_style);
                        
                        if (beginTime && endTime) {
                            chart.createOverlay({
                                name: 'segment',
                                id: `seg_${idx}`,
                                groupId: 'seg_group',
                                paneId: 'candle_pane',
                                points: [
                                    { timestamp: beginTime, value: parseFloat(seg.begin_price) },
                                    { timestamp: endTime, value: parseFloat(seg.end_price) }
                                ],
                                styles: {
                                    line: {
                                        style: segStyleConfig.style,
                                        size: segWidth,
                                        color: segColor,
                                        ...(segStyleConfig.dashedValue ? { dashedValue: segStyleConfig.dashedValue } : {})
                                    }
                                }
                            });
                        }
                    });
                    debugLog('‚úÖ [Seg] Added successfully');
                }

                // 3. ÁªòÂà∂‰∏≠Êû¢ (ZhongShu) - ÈªÑËâ≤Áü©ÂΩ¢Âå∫Âüü
                const baseZsList = Array.isArray(data?.zs_list) ? data.zs_list : [];
                const segZsList = Array.isArray(data?.seg_zs_list) ? data.seg_zs_list : [];
                const zsSource = indicators.zs_source || 'bi';
                let zsData = [];
                if (zsSource === 'seg') {
                    zsData = segZsList.length > 0 ? segZsList : baseZsList;
                } else if (zsSource === 'both') {
                    zsData = [...baseZsList, ...segZsList];
                } else {
                    zsData = baseZsList;
                }

                const zsEmptyMessageKey = 'zs-empty-hint';
                if (chart.removeOverlay) {
                    try {
                        const removed = chart.removeOverlay({ groupId: 'zs_group' });
                        if (removed && removed.length) {
                            debugLog('üßπ [ZS] Cleared previous overlays:', removed.length);
                        }
                    } catch (error) {
                        debugWarn('‚ö†Ô∏è [ZS] Unable to clear previous overlays', error);
                    }
                }

                if (indicators.plot_zs && zsSource === 'bi') {
                    if (zsData.length === 0) {
                        const segCount = segZsList.length;
                        message.open({
                            key: zsEmptyMessageKey,
                            type: 'info',
                            duration: 3,
                            content: segCount > 0
                                ? 'ÂΩìÂâçÁ¨î‰∏≠Êû¢‰∏∫Á©∫ÔºåÂèØÂºÄÂêØÂè≥‰æß„ÄåÂçïÁ¨î‰∏≠Êû¢„ÄçÊàñÂ∞ÜÊù•Ê∫êÂàáÊç¢‰∏∫Á∫øÊÆµ‰∏≠Êû¢Êü•Áúã„ÄÇ'
                                : 'ÂΩìÂâçÁ¨î‰∏≠Êû¢Êï∞Èáè‰∏∫ 0ÔºåËØ∑Â∞ùËØïÊîæÂÆΩÊó∂Èó¥ËåÉÂõ¥ÊàñË∞ÉÊï¥‰∏≠Êû¢ÂèÇÊï∞„ÄÇ',
                        });
                    } else {
                        message.destroy(zsEmptyMessageKey);
                    }
                }

                if (indicators.plot_zs && zsData.length > 0) {
                    debugLog('üìä [ZS] Using source', zsSource, 'total', zsData.length);
                    zsData.forEach((zs, idx) => {
                        if (idx === 0) {
                            debugLog('üüß [ZS] Sample payload', zs);
                        }
                        const beginTime = convertTime(zs.begin_time);
                        const endTime = convertTime(zs.end_time);
                        const high = parseFloat(zs.high ?? zs.zg);
                        const low = parseFloat(zs.low ?? zs.zd);

                        if (beginTime && endTime && Number.isFinite(high) && Number.isFinite(low)) {
                            registerChanOverlay();
                            const sourceTag = zs.source || zsSource || 'bi';
                            const borderStyleConfig = getLineStyleConfig(indicators.zs_border_style);
                            const fillColor = hexToRgba(indicators.zs_fill_color, indicators.zs_fill_opacity ?? 0.2);
                            const borderColor = indicators.zs_border_color || '#FFC107';
                            const dashedValue = Array.isArray(borderStyleConfig.dashedValue)
                                ? borderStyleConfig.dashedValue
                                : [];
                            const borderSize = Number(indicators.zs_border_size) || 1;
                            const baseLabel = sourceTag === 'seg' ? 'Á∫øÊÆµ‰∏≠Êû¢' : 'Á¨î‰∏≠Êû¢';
                            const levelValue = zs.level;
                            const levelLabel = (typeof levelValue === 'number' && Number.isFinite(levelValue))
                                ? `Lv ${levelValue}`
                                : (typeof levelValue === 'string' && levelValue.trim() ? levelValue : '');
                            const unit = zs.component_unit || (sourceTag === 'seg' ? 'ÊÆµ' : 'Á¨î');
                            let countLabel = '';
                            const componentCount = Number.isFinite(zs.component_count) ? zs.component_count
                                : Number.isFinite(zs.bi_count) ? zs.bi_count
                                : null;
                            if (componentCount !== null) {
                                const unitLabel = componentCount === zs.bi_count && sourceTag !== 'seg' ? 'Á¨î' : unit;
                                countLabel = `${componentCount}${unitLabel}`;
                            } else if (zs.is_one_bi) {
                                countLabel = 'ÂçïÁ¨î';
                            }
                            const labelText = [baseLabel, levelLabel, countLabel].filter(Boolean).join(' ¬∑ ') || baseLabel;

                            chart.createOverlay({
                                name: 'chanZone',
                                id: `zs_${sourceTag}_${idx}`,
                                groupId: 'zs_group',
                                paneId: 'candle_pane',
                                points: [
                                    { timestamp: beginTime, value: high },
                                    { timestamp: endTime, value: high },
                                    { timestamp: endTime, value: low },
                                    { timestamp: beginTime, value: low },
                                ],
                                extendData: {
                                    fillColor,
                                    borderColor,
                                    borderDashed: dashedValue,
                                    borderSize,
                                    borderStyle: borderStyleConfig.style,
                                    labelColor: indicators.zs_label_color || '#FFC107',
                                },
                            });

                            if (indicators.zs_show_label) {
                                const midpoint = beginTime && endTime ? Math.floor(beginTime + (endTime - beginTime) / 2) : beginTime;
                                chart.createOverlay({
                                    name: 'simpleAnnotation',
                                    id: `zs_label_${sourceTag}_${idx}`,
                                    groupId: 'zs_group',
                                    paneId: 'candle_pane',
                                    points: [{ timestamp: midpoint, value: high }],
                                    styles: {
                                        position: 'top',
                                        offset: [0, -16],
                                        symbol: {
                                            type: 'none',
                                            size: 0,
                                        },
                                        text: {
                                            color: indicators.zs_label_color || '#FFC107',
                                            size: 12,
                                            weight: '600',
                                            value: labelText,
                                        },
                                        background: {
                                            color: theme === 'dark' ? 'rgba(0, 0, 0, 0.6)' : 'rgba(255, 255, 255, 0.8)',
                                            borderRadius: 4,
                                            padding: { left: 6, right: 6, top: 2, bottom: 2 },
                                        },
                                    },
                                    extendData: labelText,
                                });
                            }
                        }
                    });
                    debugLog('‚úÖ [ZS] Added successfully');
                }

                // 4. ÁªòÂà∂‰π∞ÂçñÁÇπ (BuySellPoint) - ÁÆ≠Â§¥Ê†áËÆ∞
                try {
                    chart.removeOverlay({ groupId: 'bsp_group' });
                } catch (error) {
                    // ignore when no previous overlays
                }

                if (indicators.plot_bsp && filteredBspList.length > 0) {
                    debugLog('üìä [BSP] Adding', filteredBspList.length, 'buy/sell points (filtered)');
                    filteredBspList.forEach((bsp, idx) => {
                        const timestamp = convertTime(bsp.time);
                        const price = parseFloat(bsp.price);
                        const isBuy = bsp.is_buy;
                        
                        if (timestamp && price) {
                            chart.createOverlay({
                                name: 'simpleAnnotation',
                                id: `bsp_${idx}`,
                                groupId: 'bsp_group',
                                paneId: 'candle_pane',
                                points: [{ timestamp, value: price }],
                                styles: {
                                    position: isBuy ? 'bottom' : 'top',
                                    offset: [0, isBuy ? 10 : -10],
                                    symbol: {
                                        type: isBuy ? 'arrow_up' : 'arrow_down',
                                        size: 12,
                                        color: isBuy ? '#4CAF50' : '#F44336',
                                        activeColor: isBuy ? '#66BB6A' : '#EF5350',
                                    },
                                },
                                extendData: `${isBuy ? '‰π∞ÁÇπ' : 'ÂçñÁÇπ'}${bsp.type || ''}`
                            });
                        }
                    });
                    debugLog('‚úÖ [BSP] Added successfully');
                }

                try {
                    chart.removeOverlay({ groupId: 'strength_group' });
                } catch (error) {
                    // ignore removal errors
                }

                const addStrengthOverlay = (strength, label) => {
                    if (!strength) {
                        return;
                    }
                    const timestamp = Number(strength.current?.endTs);
                    const price = Number(strength.current?.endPrice);
                    if (!Number.isFinite(timestamp) || !Number.isFinite(price)) {
                        return;
                    }
                    const dir = strength.dir === 'down' ? 'down' : 'up';
                    const hintType = strength.hintType;
                    const weakening = strength.weakening;
                    const baseColor = hintType === 'strong'
                        ? '#2E7D32'
                        : weakening
                            ? '#C62828'
                            : '#0277BD';
                    const baseLabel = hintType === 'strong'
                        ? `${label}Â¢ûÂº∫`
                        : weakening
                            ? `${label}ÂáèÂº±`
                            : `${label}ËßÇÂØü`;
                    const cues = [];
                    if (strength.volumeRatio != null) {
                        cues.push(strength.volumeRatio > 1 ? 'Èáè‚Üë' : strength.volumeRatio < 1 ? 'Èáè‚Üì' : null);
                    }
                    if (strength.macdRatio != null) {
                        cues.push(strength.macdRatio > 1 ? 'MACD‚Üë' : strength.macdRatio < 1 ? 'MACD‚Üì' : null);
                    }
                    const extraLabel = cues.filter(Boolean).join('/');
                    const textLabel = extraLabel ? `${baseLabel} ${extraLabel}` : baseLabel;
                    const symbolType = dir === 'up'
                        ? (hintType === 'strong' ? 'arrow_up' : 'triangle')
                        : (weakening ? 'arrow_down' : 'triangle_down');
                    const position = dir === 'up' ? 'top' : 'bottom';
                    const offsetY = dir === 'up' ? -18 : 18;
                    chart.createOverlay({
                        name: 'simpleAnnotation',
                        id: `strength_${label}_${timestamp}`,
                        groupId: 'strength_group',
                        paneId: 'candle_pane',
                        points: [{ timestamp, value: price }],
                        styles: {
                            position,
                            offset: [0, offsetY],
                            symbol: {
                                type: symbolType,
                                size: 12,
                                color: baseColor,
                                activeColor: baseColor,
                            },
                            text: {
                                value: textLabel,
                                color: baseColor,
                                offset: [0, position === 'top' ? -14 : 14],
                                size: 11,
                                weight: '600',
                            },
                        },
                    });
                };

                addStrengthOverlay(stats?.biStrength, 'Á¨î');
                addStrengthOverlay(stats?.segStrength, 'ÊÆµ');

                const applySyncedIndexRange = (fromIdx, toIdx) => {
                    const chartInst = chartInstanceRef.current;
                    const total = timestampsRef.current.length;
                    if (!chartInst || total === 0) {
                        return false;
                    }
                    let startIdx = Math.min(fromIdx, toIdx);
                    let endIdx = Math.max(fromIdx, toIdx);
                    if (!Number.isFinite(startIdx) || !Number.isFinite(endIdx)) {
                        return false;
                    }
                    startIdx = clamp(Math.floor(startIdx), 0, total - 1);
                    endIdx = clamp(Math.ceil(endIdx), 0, total - 1);
                    const desiredCount = Math.max(1, endIdx - startIdx);
                    let applied = false;
                    let mutated = false;

                    if (typeof chartInst.getVisibleRange === 'function' &&
                        typeof chartInst.getBarSpace === 'function' &&
                        typeof chartInst.setBarSpace === 'function') {
                        try {
                            const currentRange = chartInst.getVisibleRange();
                            const barInfo = chartInst.getBarSpace();
                            const currentSpan = (() => {
                                if (!currentRange) return null;
                                const raw = Number.isFinite(currentRange.realTo) && Number.isFinite(currentRange.realFrom)
                                    ? Math.abs(currentRange.realTo - currentRange.realFrom)
                                    : Math.abs((currentRange.to ?? 0) - (currentRange.from ?? 0));
                                return Number.isFinite(raw) && raw > 0 ? raw : null;
                            })();
                            const currentBar = barInfo && Number.isFinite(barInfo.bar) && barInfo.bar > 0 ? barInfo.bar : null;
                            if (currentSpan && currentBar) {
                                const ratio = currentSpan / desiredCount;
                                if (Number.isFinite(ratio) && ratio > 0) {
                                    if (Math.abs(ratio - 1) > 0.05) {
                                        const MIN_BAR = 2;
                                        const MAX_BAR = 60;
                                        let nextBar = currentBar * ratio;
                                        nextBar = clamp(nextBar, MIN_BAR, MAX_BAR);
                                        if (Math.abs(nextBar - currentBar) > 0.1) {
                                            suppressBroadcastRef.current = true;
                                            chartInst.setBarSpace(nextBar);
                                            applied = true;
                                            mutated = true;
                                        }
                                    }
                                }
                            }
                        } catch (err) {
                            debugWarn('‚ö†Ô∏è [Sync] failed to adjust bar space', chartKey, err);
                        }
                    }

                    const scrollToIndex = () => {
                        if (typeof chartInst.scrollToDataIndex === 'function') {
                            suppressBroadcastRef.current = true;
                            chartInst.scrollToDataIndex(endIdx, 0);
                            mutated = true;
                            return true;
                        }
                        if (typeof chartInst.scrollToTimestamp === 'function') {
                            const ts = timestampsRef.current[endIdx];
                            if (Number.isFinite(ts)) {
                                suppressBroadcastRef.current = true;
                                chartInst.scrollToTimestamp(ts, 0);
                                mutated = true;
                                return true;
                            }
                        }
                        return false;
                    };

                    if (scrollToIndex()) {
                        applied = true;
                    }
                    if (!mutated && suppressBroadcastRef.current) {
                        suppressBroadcastRef.current = false;
                    }
                    return applied;
                };

                if (timestampsRef.current.length > 0) {
                    registerChartInstance(chartKey, {
                        chart,
                        getIndexRange: getIndexRangeForTimestamps,
                        applyIndexRange: applySyncedIndexRange,
                        suppressNextBroadcast: () => {
                            suppressBroadcastRef.current = true;
                        },
                    });
                    debugLog('üìù [ChartRegistry] Registered', chartKey, 'candles:', timestampsRef.current.length);
                }

                if (chartFocusRequest && !chartFocusRequest.acknowledged && chartFocusRequest.stockCode === stockCode && chartFocusRequest.level === level) {
                    focusOnTimestamp(chartFocusRequest.timestamp);
                    acknowledgeChartFocus(chartFocusRequest.id);
                }

                const visibleRangeAction = (klinecharts.ActionType && klinecharts.ActionType.OnVisibleRangeChange) || 'onVisibleRangeChange';
                const scrollAction = (klinecharts.ActionType && klinecharts.ActionType.OnScroll) || 'onScroll';
                const zoomAction = (klinecharts.ActionType && klinecharts.ActionType.OnZoom) || 'onZoom';
                const subscribedRangeActions = [];
                let initialRangeTimerId = null;
                const handleVisibleRange = () => {
                    if (!syncVisibleRange || !chart || typeof chart.getVisibleRange !== 'function') {
                        return;
                    }
                    if (suppressBroadcastRef.current) {
                        suppressBroadcastRef.current = false;
                        return;
                    }
                    const list = timestampsRef.current;
                    if (!Array.isArray(list) || list.length === 0) {
                        return;
                    }
                    const range = chart.getVisibleRange();
                    if (!range) {
                        return;
                    }
                    const fromRaw = Number.isFinite(range.from) ? range.from : 0;
                    const toRaw = Number.isFinite(range.to) ? range.to : list.length - 1;
                    const fromIdx = clamp(Math.floor(fromRaw), 0, list.length - 1);
                    const toIdx = clamp(Math.ceil(toRaw), 0, list.length - 1);
                    const fromTs = list[fromIdx];
                    const toTs = list[toIdx];
                    if (!Number.isFinite(fromTs) || !Number.isFinite(toTs)) {
                        return;
                    }
                    debugLog('üîÑ [VisibleRange]', chartKey, { fromIdx, toIdx, fromTs, toTs });
                    syncVisibleRange(chartKey, fromTs, toTs);
                };
                const subscribeRangeAction = (actionType) => {
                    if (!chart.subscribeAction || !actionType || subscribedRangeActions.includes(actionType)) {
                        return;
                    }
                    try {
                        chart.subscribeAction(actionType, handleVisibleRange);
                        subscribedRangeActions.push(actionType);
                        debugLog('‚úÖ [Subscribe]', chartKey, actionType);
                    } catch (err) {
                        debugWarn(`‚ö†Ô∏è Failed to subscribe ${actionType} action`, err);
                    }
                };
                subscribeRangeAction(visibleRangeAction);
                subscribeRangeAction(scrollAction);
                subscribeRangeAction(zoomAction);
                initialRangeTimerId = setTimeout(handleVisibleRange, 0);

                const crosshairAction = (klinecharts.ActionType && klinecharts.ActionType.OnCrosshairChange) || 'onCrosshairChange';
                let subscribed = false;
                const handleCrosshair = (params) => {
                    try {
                        const payload = (() => {
                            if (!params) return null;
                            if (params.data) return params.data;
                            if (params.current) return params.current;
                            if (params.kLineData || Number.isFinite(params.dataIndex)) {
                                return params;
                            }
                            return null;
                        })();

                        if (!payload) {
                            updateHoverInfo(null);
                            return;
                        }

                        const dataIndex = Number.isFinite(payload.dataIndex)
                            ? payload.dataIndex
                            : Number.isFinite(payload.currentDataIndex)
                                ? payload.currentDataIndex
                                : undefined;

                        const kLineData = payload.kLineData || payload.klineData || null;
                        let timestamp = payload.timestamp;

                        if (!timestamp && kLineData && Number.isFinite(kLineData.timestamp)) {
                            timestamp = kLineData.timestamp;
                        }

                        if (!timestamp && Number.isFinite(dataIndex)) {
                            const list = candleDataRef.current;
                            if (Array.isArray(list) && list.length > 0) {
                                const idx = clamp(Math.floor(dataIndex), 0, list.length - 1);
                                timestamp = idx >= 0 ? list[idx]?.timestamp : undefined;
                            }
                        }

                        if (!timestamp) {
                            updateHoverInfo(null);
                            return;
                        }

                        updateHoverInfo(timestamp);
                    } catch (err) {
                        debugWarn('‚ö†Ô∏è Crosshair update failed', err);
                    }
                };

                if (chart.subscribeAction) {
                    try {
                        chart.subscribeAction(crosshairAction, handleCrosshair);
                        subscribed = true;
                    } catch (err) {
                        debugWarn('‚ö†Ô∏è Failed to subscribe crosshair action', err);
                    }
                }

                if (candleData.length > 0) {
                    updateHoverInfo(candleData[candleData.length - 1].timestamp);
                }

                // Cleanup
                return () => {
                    unregisterChartInstance(chartKey);
                    if (initialRangeTimerId) {
                        clearTimeout(initialRangeTimerId);
                    }
                    if (chart.unsubscribeAction && subscribedRangeActions.length > 0) {
                        subscribedRangeActions.forEach(actionType => {
                            try {
                                chart.unsubscribeAction(actionType, handleVisibleRange);
                                debugLog('üö™ [Unsubscribe]', chartKey, actionType);
                            } catch (err) {
                                debugWarn(`‚ö†Ô∏è Failed to unsubscribe ${actionType} action`, err);
                            }
                        });
                    }
                    if (chart.unsubscribeAction && subscribed) {
                        try {
                            chart.unsubscribeAction(crosshairAction, handleCrosshair);
                        } catch (err) {
                            debugWarn('‚ö†Ô∏è Failed to unsubscribe crosshair action', err);
                        }
                    }
                    biListRef.current = [];
                    segListRef.current = [];
                    zsListRef.current = [];
                    if (chartRef.current) {
                        klinecharts.dispose(chartRef.current);
                    }
                    timestampsRef.current = [];
                    chartInstanceRef.current = null;
                };
            }, [data, indicators, theme, updateHoverInfo, registerChartInstance, unregisterChartInstance, syncVisibleRange, chartKey, getIndexRangeForTimestamps, detailVisible, buildStructureSnapshot, filterSignals, stats, chartFocusRequest, acknowledgeChartFocus]);

            if (loading) {
                return (
                    <div style={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '100%' }}>
                        <Spin size="large" tip="Âä†ËΩΩ‰∏≠..." />
                    </div>
                );
            }

            return (
                <div className="chart-card">
                    <div className="chart-header">
                        <div className="chart-title">
                            {stockCode} | {LEVEL_OPTIONS.find(o => o.value === level)?.label || level}
                        </div>
                        <Space>
                            <Button
                                size="small"
                                onClick={() => setSummaryCollapsed(prev => !prev)}
                            >
                                {summaryCollapsed ? 'Â±ïÂºÄ‰ø°ÊÅØÈù¢Êùø' : 'Êî∂Ëµ∑‰ø°ÊÅØÈù¢Êùø'}
                            </Button>
                            <Button
                                size="small"
                                onClick={openStructureDetail}
                            >
                                ÁªìÊûÑÊòéÁªÜ
                            </Button>
                            <Button 
                                size="small" 
                                onClick={() => {
                                    if (chartInstanceRef.current) {
                                        const total = candleDataRef.current.length;
                                        if (total > 0 && chartInstanceRef.current.zoomAtDataIndex) {
                                            chartInstanceRef.current.zoomAtDataIndex(0.5, total - 1, 0);
                                        }
                                    }
                                }}
                            >
                                ÈáçÁΩÆÁº©Êîæ
                            </Button>
                        </Space>
                    </div>
                    {!summaryCollapsed && (
                        <ChartSummary
                            hoverInfo={hoverInfo}
                            stats={stats}
                            level={level}
                            stockCode={stockCode}
                            onOpenDetail={openStructureDetail}
                            multiLevelStats={multiLevelStats}
                            allSignals={preparedSignals}
                            onFocusSignal={focusOnTimestamp}
                            onDrillDownLevel={requestLevelFocus}
                        />
                    )}
                    <div className="chart-wrapper">
                        <div ref={chartRef} className="chart-container" />
                    </div>
                    <Drawer
                        open={detailVisible}
                        onClose={closeStructureDetail}
                        width={640}
                        title={`ÁªìÊûÑÊòéÁªÜ ¬∑ ${stockCode} ¬∑ ${levelLabel}`}
                        destroyOnClose
                    >
                        {detailData ? (
                            <Tabs
                                size="small"
                                activeKey={detailTab}
                                onChange={setDetailTab}
                                items={detailTabsConfig}
                            />
                        ) : (
                            <Empty description="ÊöÇÊó†ÁªìÊûÑÊï∞ÊçÆ" />
                        )}
                    </Drawer>
                </div>
            );
        });

        const LOWER_INDICATOR_KEYS = ['macd', 'kdj', 'rsi'];

        const LabelWithTip = ({ label, tip }) => (
            <Tooltip title={tip}>
                <span style={{ display: 'inline-flex', alignItems: 'center', gap: 4 }}>
                    {label}
                    <span style={{ fontSize: 10, color: '#bbb' }}>i</span>
                </span>
            </Tooltip>
        );

        function ChartSummaryComponent({ hoverInfo, stats, level, stockCode, onOpenDetail, multiLevelStats, allSignals = [], onFocusSignal = () => {}, onDrillDownLevel }) {
            const { indicators, setIndicators } = useApp();
            const handleChange = useCallback((key, value) => {
                setIndicators(prev => ({ ...prev, [key]: value }));
            }, [setIndicators]);
            const [statsCollapsed, setStatsCollapsed] = useState(true);
            const [hoverCollapsed, setHoverCollapsed] = useState(false);
            const [replayVisible, setReplayVisible] = useState(false);
            const [replayIndex, setReplayIndex] = useState(0);

            if (!indicators) {
                return null;
            }

            const levelLabel = LEVEL_OPTIONS.find(option => option.value === level)?.label || level;
            const percentLabel = (value, digits = 1) => Number.isFinite(value) ? `${(value * 100).toFixed(digits)}%` : '--';
            const minuteLabel = (value) => Number.isFinite(value) ? value.toFixed(1) : '--';
            const signalList = hoverInfo?.signals || [];
            const structureData = hoverInfo?.structures;
            const hasStructureInfo = !!(structureData &&
                (((structureData.bi || []).length > 0) ||
                 ((structureData.seg || []).length > 0) ||
                 ((structureData.zs || []).length > 0)));
            const statPairs = [];
            const rawTypeDirMap = stats?.rawBspTypesByDir || {};
            const filteredTypeDirMap = stats?.bspTypesByDir || {};
            const currentFilters = useMemo(() => {
                const raw = indicators?.bsp_filters || DEFAULT_BSP_FILTERS;
                const directions = Array.isArray(raw.directions) && raw.directions.length > 0
                    ? raw.directions
                    : DEFAULT_BSP_FILTERS.directions;
                const types = Array.isArray(raw.types) ? raw.types : [];
                return {
                    directions,
                    types,
                };
            }, [indicators?.bsp_filters]);
            const directionOptions = useMemo(() => ([
                { label: '‰π∞ÁÇπ', value: 'buy' },
                { label: 'ÂçñÁÇπ', value: 'sell' },
            ]), []);
            const typeOptions = useMemo(() => {
                if (!stats?.rawBspTypes) {
                    return [];
                }
                return Object.keys(stats.rawBspTypes)
                    .map(type => ({ label: type, value: type }))
                    .sort((a, b) => a.label.localeCompare(b.label, 'zh-CN'));
            }, [stats?.rawBspTypes]);

            const formatSignalReason = useCallback((signal) => {
                if (!signal) {
                    return 'ÊöÇÊó†‰æùÊçÆ';
                }
                const rawDetails = Array.isArray(signal.reason_details)
                    ? signal.reason_details
                    : (Array.isArray(signal.reasonDetails) ? signal.reasonDetails : null);
                if (rawDetails && rawDetails.length > 0) {
                    return rawDetails.join('Ôºõ');
                }
                return signal.reason || 'ÊöÇÊó†‰æùÊçÆ';
            }, []);

            const applyBspFilters = useCallback((nextFilters) => {
                setIndicators(prev => ({
                    ...prev,
                    bsp_filters: {
                        directions: nextFilters.directions.length > 0 ? nextFilters.directions : [...DEFAULT_BSP_FILTERS.directions],
                        types: Array.from(new Set(nextFilters.types)),
                    },
                }));
            }, [setIndicators]);

            const handleDirectionFilterChange = useCallback((values) => {
                if (values.length === 0) {
                    message.warning('Ëá≥Â∞ë‰øùÁïô‰∏Ä‰∏™ÊñπÂêë');
                    applyBspFilters({
                        directions: [...DEFAULT_BSP_FILTERS.directions],
                        types: currentFilters.types,
                    });
                    return;
                }
                applyBspFilters({
                    directions: values,
                    types: currentFilters.types,
                });
            }, [applyBspFilters, currentFilters.types]);

            const handleTypeFilterChange = useCallback((values) => {
                applyBspFilters({
                    directions: currentFilters.directions,
                    types: values,
                });
            }, [applyBspFilters, currentFilters.directions]);
            const replaySignals = useMemo(() => (
                Array.isArray(allSignals)
                    ? allSignals
                        .filter(item => Number.isFinite(item.timestamp))
                        .sort((a, b) => b.timestamp - a.timestamp)
                    : []
            ), [allSignals]);
            useEffect(() => {
                if (replayIndex >= replaySignals.length) {
                    setReplayIndex(replaySignals.length > 0 ? 0 : 0);
                }
            }, [replaySignals.length, replayIndex]);
            const activeReplaySignal = replaySignals[replayIndex] || null;
            const handleReplayOpen = useCallback(() => {
                if (replaySignals.length === 0) {
                    message.info('ÂΩìÂâçÁ≠õÈÄâÁªìÊûúÊöÇÊó†ÂèØÂõûÊîæÁöÑ‰π∞ÂçñÁÇπ');
                    return;
                }
                setReplayVisible(true);
                setReplayIndex(0);
            }, [replaySignals.length]);
            const handleReplayClose = useCallback(() => {
                setReplayVisible(false);
            }, []);
            const handleReplayIndexChange = useCallback((nextIndex) => {
                if (nextIndex < 0 || nextIndex >= replaySignals.length) {
                    return;
                }
                setReplayIndex(nextIndex);
            }, [replaySignals.length]);
            const handleJumpToSignal = useCallback((signal) => {
                if (!signal || !Number.isFinite(signal.timestamp)) {
                    return;
                }
                onFocusSignal(signal.timestamp);
            }, [onFocusSignal]);
            const handleJumpCurrent = useCallback(() => {
                if (activeReplaySignal) {
                    handleJumpToSignal(activeReplaySignal);
                }
            }, [activeReplaySignal, handleJumpToSignal]);
            const formatReplayLine = useCallback((signal) => {
                if (!signal || !Number.isFinite(signal.timestamp)) {
                    return '--';
                }
                const typeText = signal.typeKey || SignalUtils.normalizeBspType(signal.type);
                const timeText = dayjs(signal.timestamp).format('YYYY-MM-DD HH:mm');
                return `${signal.is_buy ? '‰π∞' : 'Âçñ'} ¬∑ ${typeText} ¬∑ ${timeText}`;
            }, []);
            const ratioPercent = (ratio) => ratio == null ? '--' : `${((ratio - 1) * 100).toFixed(1)}%`;
            const pillClass = (ratio) => {
                if (ratio == null) return 'strength-pill';
                if (ratio < 0.95) return 'strength-pill strength-pill--weak';
                if (ratio > 1.05) return 'strength-pill strength-pill--strong';
                return 'strength-pill';
            };
            const directionText = (dir) => {
                if (dir === 'up') return 'Âêë‰∏ä';
                if (dir === 'down') return 'Âêë‰∏ã';
                return 'Êú™Âà§ÂÆö';
            };
            if (stats) {
                statPairs.push(
                    { label: 'KÁ∫ø', value: stats.kline },
                    { label: 'Á¨î', value: stats.bi },
                    { label: 'Á∫øÊÆµ', value: stats.seg },
                    { label: '‰∏≠Êû¢', value: stats.zs },
                    { label: '‰π∞ÂçñÁÇπ(Á≠õÈÄâ)', value: stats.bsp },
                    { label: '‰π∞ÁÇπ(Á≠õÈÄâ)', value: stats.buy },
                    { label: 'ÂçñÁÇπ(Á≠õÈÄâ)', value: stats.sell },
                );
                if (typeof stats.rawBspCount === 'number' && stats.rawBspCount !== stats.bsp) {
                    statPairs.push({ label: '‰π∞ÂçñÁÇπ(ÊÄª)', value: stats.rawBspCount });
                }
                if (typeof stats.rawBuyCount === 'number' && stats.rawBuyCount !== stats.buy) {
                    statPairs.push({ label: '‰π∞ÁÇπ(ÊÄª)', value: stats.rawBuyCount });
                }
                if (typeof stats.rawSellCount === 'number' && stats.rawSellCount !== stats.sell) {
                    statPairs.push({ label: 'ÂçñÁÇπ(ÊÄª)', value: stats.rawSellCount });
                }
                if (Number.isFinite(stats.biAvgAmplitude)) {
                    statPairs.push({ label: 'Á¨îÊåØÂπÖÂùáÂÄº', value: formatNumber(stats.biAvgAmplitude, 2) });
                }
                if (Number.isFinite(stats.biAvgDuration)) {
                    statPairs.push({ label: 'Á¨îËÄóÊó∂(ÂàÜ)', value: minuteLabel(stats.biAvgDuration) });
                }
                if (Number.isFinite(stats.segAvgAmplitude)) {
                    statPairs.push({ label: 'ÊÆµÊåØÂπÖÂùáÂÄº', value: formatNumber(stats.segAvgAmplitude, 2) });
                }
                if (Number.isFinite(stats.segAvgDuration)) {
                    statPairs.push({ label: 'ÊÆµËÄóÊó∂(ÂàÜ)', value: minuteLabel(stats.segAvgDuration) });
                }
                if (Number.isFinite(stats.zsSureRatio)) {
                    statPairs.push({ label: 'Á°ÆÂÆö‰∏≠Êû¢Âç†ÊØî', value: percentLabel(stats.zsSureRatio) });
                }
            }
            const biStrength = stats?.biStrength;
            const segStrength = stats?.segStrength;
            const latestSignals = stats?.latestSignals || [];
            const multiLevelEntries = useMemo(() => {
                if (!multiLevelStats) return [];
                return LEVEL_OPTIONS
                    .map(option => ({
                        key: option.value,
                        label: option.label,
                        stats: multiLevelStats[option.value],
                    }))
                    .filter(entry => entry.stats);
            }, [multiLevelStats]);
            const totalTypeEntries = stats?.rawBspTypes ? Object.entries(stats.rawBspTypes) : [];
            const handleDrillDown = useCallback((targetLevel) => {
                if (typeof onDrillDownLevel === 'function') {
                    onDrillDownLevel(targetLevel);
                }
            }, [onDrillDownLevel]);
            const copyStatsToClipboard = useCallback(() => {
                if (!stats) {
                    message.warning('ÊöÇÊó†ÁªüËÆ°Êï∞ÊçÆ');
                    return;
                }
                const payload = {
                    stock: stockCode,
                    level,
                    levelLabel,
                    generatedAt: new Date().toISOString(),
                    stats,
                };
                const text = JSON.stringify(payload, null, 2);
                const fallback = () => {
                    try {
                        const textarea = document.createElement('textarea');
                        textarea.value = text;
                        textarea.setAttribute('readonly', '');
                        textarea.style.position = 'absolute';
                        textarea.style.left = '-9999px';
                        document.body.appendChild(textarea);
                        textarea.select();
                        document.execCommand('copy');
                        document.body.removeChild(textarea);
                        message.success('ÁªüËÆ°Â∑≤Â§çÂà∂Âà∞Ââ™Ë¥¥Êùø');
                    } catch (err) {
                        debugWarn('Fallback clipboard copy failed', err);
                        message.error('Â§çÂà∂Â§±Ë¥•ÔºåËØ∑ÊâãÂä®ÈÄâÊã©ÊñáÊú¨');
                    }
                };
                if (navigator.clipboard?.writeText) {
                    navigator.clipboard.writeText(text)
                        .then(() => message.success('ÁªüËÆ°Â∑≤Â§çÂà∂Âà∞Ââ™Ë¥¥Êùø'))
                        .catch(err => {
                            debugWarn('Clipboard copy failed', err);
                            fallback();
                        });
                } else {
                    fallback();
                }
            }, [stats, stockCode, level, levelLabel]);

            return (
                <div className="chart-summary-wrapper">
                    <div className="chart-summary-card">
                        <div className="card-header">
                            <span className="card-title">Áº†ËÆ∫ÁªüËÆ° ¬∑ {levelLabel}</span>
                            <Space size="small">
                                {onOpenDetail && (
                                    <Button
                                        size="small"
                                        type="link"
                                        onClick={onOpenDetail}
                                        disabled={!stats}
                                    >
                                        ÁªìÊûÑÊòéÁªÜ
                                    </Button>
                                )}
                                <Button size="small" type="link" onClick={handleReplayOpen}>
                                    ÂõûÊîæ
                                </Button>
                                <Button size="small" type="link" onClick={copyStatsToClipboard}>
                                    Â§çÂà∂ÁªüËÆ°
                                </Button>
                                <Button size="small" type="link" onClick={() => setStatsCollapsed(prev => !prev)}>
                                    {statsCollapsed ? 'Â±ïÂºÄ' : 'Êî∂Ëµ∑'}
                                </Button>
                            </Space>
                        </div>
                        {!statsCollapsed && (
                            stats ? (
                                <>
                                    <div className="chart-stats-grid">
                                        {statPairs.map(item => (
                                            <div className="chart-stats-item" key={item.label}>
                                                <span className="chart-stats-label">{item.label}</span>
                                                <span className="chart-stats-value">{item.value ?? '--'}</span>
                                            </div>
                                        ))}
                                    </div>
                                    {totalTypeEntries.length > 0 && (
                                        <div className="chart-bsp-types">
                                            {totalTypeEntries.map(([type, total]) => {
                                                const filteredTotal = stats?.bspTypes?.[type] ?? 0;
                                                const overallDisplay = total > 0 && filteredTotal !== total
                                                    ? `${filteredTotal}/${total}`
                                                    : `${filteredTotal}`;
                                                const dirChips = ['buy', 'sell']
                                                    .map(dir => {
                                                        const rawCount = rawTypeDirMap?.[type]?.[dir] || 0;
                                                        const filteredCount = filteredTypeDirMap?.[type]?.[dir] || 0;
                                                        if (rawCount === 0 && filteredCount === 0) {
                                                            return null;
                                                        }
                                                        const dirDisplay = rawCount > 0 && filteredCount !== rawCount
                                                            ? `${filteredCount}/${rawCount}`
                                                            : `${filteredCount}`;
                                                        const dirLabel = dir === 'buy' ? '‰π∞' : 'Âçñ';
                                                        return (
                                                            <span className="chart-type-chip chart-type-chip--dir" key={`${type}-${dir}`}>
                                                                {dirLabel}{type} √ó {dirDisplay}
                                                            </span>
                                                        );
                                                    })
                                                    .filter(Boolean);
                                                return (
                                                    <Fragment key={type}>
                                                        <span className="chart-type-chip">
                                                            Á±ªÂûã {type} √ó {overallDisplay}
                                                        </span>
                                                        {dirChips}
                                                    </Fragment>
                                                );
                                            })}
                                        </div>
                                    )}
                                </>
                            ) : (
                                <span className="chart-info-placeholder">ÊöÇÊó†ËØ•Âë®ÊúüÁªüËÆ°</span>
                            )
                        )}
                        {indicators.highlight_chan_kline && (
                            <div className="indicator-item" style={{ display: 'flex', alignItems: 'center', gap: 8 }}>
                                <Checkbox
                                    checked={indicators.chan_kline_show_label}
                                    onChange={e => handleChange('chan_kline_show_label', e.target.checked)}
                                >
                                    ÊòæÁ§∫ÂêàÊàêÊ†áÊ≥®
                                </Checkbox>
                            </div>
                        )}
                        <div className="signal-filter">
                            <div className="signal-filter__row">
                                <span style={{ color: '#666' }}>‰ø°Âè∑ÊñπÂêë</span>
                                <Checkbox.Group
                                    options={directionOptions}
                                    value={currentFilters.directions}
                                    onChange={handleDirectionFilterChange}
                                />
                            </div>
                            {typeOptions.length > 0 && (
                                <div className="signal-filter__row">
                                    <span style={{ color: '#666' }}>‰ø°Âè∑Á±ªÂûã</span>
                                    <Checkbox.Group
                                        options={typeOptions}
                                        value={currentFilters.types}
                                        onChange={handleTypeFilterChange}
                                    />
                                    {currentFilters.types.length === 0 && (
                                        <Tag color="blue">ÂÖ®ÈÉ®</Tag>
                                    )}
                                </div>
                            )}
                        </div>
                        {(biStrength || segStrength) && (
                            <div className="strength-section">
                                <div style={{ fontSize: 12, fontWeight: 600, color: '#595959' }}>ÂäõÂ∫¶ÂØπÊØî</div>
                                {biStrength && (
                                    <div className="strength-row">
                                        <div className="strength-row__title">Á¨î ¬∑ {directionText(biStrength.dir)}</div>
                                        <div className="strength-row__metrics">
                                            <span className={pillClass(biStrength.amplitudeRatio)}>
                                                ÊåØÂπÖ {ratioPercent(biStrength.amplitudeRatio)}
                                            </span>
                                            <span className={pillClass(biStrength.durationRatio)}>
                                                ËÄóÊó∂ {ratioPercent(biStrength.durationRatio)}
                                            </span>
                                            <span className={pillClass(biStrength.efficiencyRatio)}>
                                                ÊïàÁéá {ratioPercent(biStrength.efficiencyRatio)}
                                            </span>
                                            <span className={pillClass(biStrength.volumeRatio)}>
                                                ÈáèËÉΩ {ratioPercent(biStrength.volumeRatio)}
                                            </span>
                                            <span className={pillClass(biStrength.macdRatio)}>
                                                MACD {ratioPercent(biStrength.macdRatio)}
                                            </span>
                                            {biStrength.hint && (
                                                <span className={biStrength.hintType === 'strong' ? 'strength-pill strength-pill--strong' : 'strength-pill strength-pill--weak'}>
                                                    {biStrength.hint}
                                                </span>
                                            )}
                                        </div>
                                    </div>
                                )}
                                {segStrength && (
                                    <div className="strength-row">
                                        <div className="strength-row__title">Á∫øÊÆµ ¬∑ {directionText(segStrength.dir)}</div>
                                        <div className="strength-row__metrics">
                                            <span className={pillClass(segStrength.amplitudeRatio)}>
                                                ÊåØÂπÖ {ratioPercent(segStrength.amplitudeRatio)}
                                            </span>
                                            <span className={pillClass(segStrength.durationRatio)}>
                                                ËÄóÊó∂ {ratioPercent(segStrength.durationRatio)}
                                            </span>
                                            <span className={pillClass(segStrength.efficiencyRatio)}>
                                                ÊïàÁéá {ratioPercent(segStrength.efficiencyRatio)}
                                            </span>
                                            <span className={pillClass(segStrength.volumeRatio)}>
                                                ÈáèËÉΩ {ratioPercent(segStrength.volumeRatio)}
                                            </span>
                                            <span className={pillClass(segStrength.macdRatio)}>
                                                MACD {ratioPercent(segStrength.macdRatio)}
                                            </span>
                                            {segStrength.hint && (
                                                <span className={segStrength.hintType === 'strong' ? 'strength-pill strength-pill--strong' : 'strength-pill strength-pill--weak'}>
                                                    {segStrength.hint}
                                                </span>
                                            )}
                                        </div>
                                    </div>
                                )}
                            </div>
                        )}
                        {latestSignals.length > 0 && (
                            <div style={{ display: 'flex', flexDirection: 'column', gap: 6, marginTop: 8 }}>
                                <div style={{ fontSize: 12, fontWeight: 600, color: '#595959' }}>ÊúÄËøë‰ø°Âè∑</div>
                                <Space size={[6, 6]} wrap>
                                    {latestSignals.map(signal => (
                                        <div className="latest-signal-item" key={`${signal.type}-${signal.timestamp}`}>
                                            <Tooltip
                                                title={formatSignalReason(signal)}
                                            >
                                                <Tag
                                                    color={signal.is_buy ? 'green' : 'volcano'}
                                                    style={{ cursor: 'pointer' }}
                                                    onClick={() => onFocusSignal(signal.timestamp)}
                                                >
                                                    {signal.type} ¬∑ {signal.price != null ? signal.price.toFixed(2) : '--'} ¬∑ {dayjs(signal.timestamp).format('MM-DD HH:mm')}
                                                </Tag>
                                            </Tooltip>
                                            <div className="signal-reason-text">
                                                {formatSignalReason(signal)}
                                            </div>
                                        </div>
                                    ))}
                                </Space>
                            </div>
                        )}
                        {multiLevelEntries.length > 1 && (
                            <div className="level-overview">
                                <div style={{ fontSize: 12, fontWeight: 600, color: '#595959' }}>Â§öÁ∫ßÂà´ËÅîÁ´ã</div>
                                {multiLevelEntries.map(entry => {
                                    const strength = entry.stats?.biStrength;
                                    const amplitudeText = strength ? ratioPercent(strength.amplitudeRatio) : '--';
                                    const statusText = strength
                                        ? (strength.hintType === 'strong'
                                            ? 'üìà Â¢ûÂº∫'
                                            : (strength.weakening || strength.hintType === 'weak') ? '‚ö†Ô∏è ÂáèÂº±' : '‚úÖ Á®≥ÂÆö')
                                        : '‚Äî';
                                    const dirText = strength ? directionText(strength.dir) : '‚Äî';
                                    return (
                                        <div
                                            key={entry.key}
                                            className="level-overview__item"
                                            style={entry.key === level ? { border: '1px solid #1976d2' } : undefined}
                                        >
                                            <span>{entry.label}{entry.key === level ? ' ¬∑ ÂΩìÂâç' : ''} ¬∑ {dirText}</span>
                                            <span style={{ display: 'flex', alignItems: 'center', gap: 8 }}>
                                                <span>{statusText} ¬∑ ÊåØÂπÖ {amplitudeText}</span>
                                                {entry.key !== level && (
                                                    <Button size="small" type="link" onClick={() => handleDrillDown(entry.key)}>
                                                        ËÅîÂä®
                                                    </Button>
                                                )}
                                            </span>
                                        </div>
                                    );
                                })}
                            </div>
                        )}
                    </div>
                    <div className={`chart-hover-card${hoverCollapsed ? ' chart-hover-card--collapsed' : ''}`}>
                        <div className="card-header">
                            <span className="card-title">KÁ∫øÊï∞ÊçÆ</span>
                            <Button size="small" type="link" onClick={() => setHoverCollapsed(prev => !prev)}>
                                {hoverCollapsed ? 'Â±ïÂºÄ' : 'Êî∂Ëµ∑'}
                            </Button>
                        </div>
                        <div className="chart-hover-card__body">
                        {hoverCollapsed ? (
                            <span className="chart-info-placeholder">‰ø°ÊÅØÂ∑≤Êî∂Ëµ∑ÔºåÁÇπÂáªÂè≥‰∏äËßíÂ±ïÂºÄ</span>
                        ) : hoverInfo ? (
                            <>
                                <div className="hover-info-grid">
                                    <div className="hover-info-cell hover-info-cell--full">
                                        <span className="hover-info-label">Êó∂Èó¥</span>
                                        <span className="hover-info-value">{formatDateTime(hoverInfo.timestamp)}</span>
                                    </div>
                                    <div className="hover-info-cell">
                                        <span className="hover-info-label">ÂºÄÁõò</span>
                                        <span className="hover-info-value">{formatNumber(hoverInfo.open)}</span>
                                    </div>
                                    <div className="hover-info-cell">
                                        <span className="hover-info-label">Êî∂Áõò</span>
                                        <span className="hover-info-value">{formatNumber(hoverInfo.close)}</span>
                                    </div>
                                    <div className="hover-info-cell">
                                        <span className="hover-info-label">ÊúÄÈ´ò</span>
                                        <span className="hover-info-value">{formatNumber(hoverInfo.high)}</span>
                                    </div>
                                    <div className="hover-info-cell">
                                        <span className="hover-info-label">ÊúÄ‰Ωé</span>
                                        <span className="hover-info-value">{formatNumber(hoverInfo.low)}</span>
                                    </div>
                                    <div className="hover-info-cell hover-info-cell--full">
                                        <span className="hover-info-label">Êàê‰∫§Èáè</span>
                                        <span className="hover-info-value">{formatVolume(hoverInfo.volume)}</span>
                                    </div>
                                </div>
                                <div className="chart-signal-tags">
                                    {signalList.length > 0 ? (
                                        signalList.map((signal, idx) => (
                                            <div className="hover-signal-item" key={`${signal.isBuy ? 'buy' : 'sell'}-${idx}`}>
                                                <Tooltip
                                                    title={formatSignalReason(signal)}
                                                >
                                                    <Tag
                                                        color={signal.isBuy ? 'green' : 'volcano'}
                                                        style={{ cursor: 'pointer' }}
                                                        onClick={() => onFocusSignal(hoverInfo.timestamp)}
                                                    >
                                                        {signal.isBuy ? '‰π∞' : 'Âçñ'}{signal.type || ''}
                                                    </Tag>
                                                </Tooltip>
                                                <div className="signal-reason-text signal-reason-text--inline">
                                                    {formatSignalReason(signal)}
                                                </div>
                                            </div>
                                        ))
                                    ) : (
                                        <span className="chart-info-placeholder">ÂΩìÂâçKÁ∫øÊó†‰π∞ÂçñÁÇπ</span>
                                    )}
                                </div>
                                {structureData && (
                                   <div className="hover-structures">
                                       {hasStructureInfo ? (
                                           <>
                                               {(structureData.bi || []).length > 0 && (
                                                   <div className="hover-structure-section">
                                                        <div className="hover-structure-title">ÂΩìÂâçÁ¨î</div>
                                                        {(structureData.bi || []).map((item, idx) => (
                                                            <div className="hover-structure-row" key={`bi-${item.id ?? idx}`}>
                                                                <span className="hover-structure-metric">{item.label || `Á¨î${idx + 1}`}</span>
                                                                <Tag color={item.dir === 'down' ? 'blue' : item.dir === 'up' ? 'red' : 'default'}>
                                                                    {item.dir === 'down' ? 'Âêë‰∏ã' : item.dir === 'up' ? 'Âêë‰∏ä' : 'Êú™Áü•'}
                                                                </Tag>
                                                                <span className="hover-structure-metric">
                                                                    {formatDateTime(item.beginTs)} ‚Üí {formatDateTime(item.endTs)}
                                                                </span>
                                                                {Number.isFinite(item.amplitude) && (
                                                                    <span className="hover-structure-metric">
                                                                        ÊåØÂπÖ {formatNumber(item.amplitude, 2)}
                                                                    </span>
                                                                )}
                                                                {Number.isFinite(item.amplitudePct) && (
                                                                    <span className="hover-structure-metric">
                                                                        {percentLabel(item.amplitudePct, 2)}
                                                                    </span>
                                                                )}
                                                                {Number.isFinite(item.durationMinutes) && (
                                                                    <span className="hover-structure-metric">
                                                                        ËÄóÊó∂ {minuteLabel(item.durationMinutes)} ÂàÜ
                                                                    </span>
                                                                )}
                                                                {Number.isFinite(item.progress) && (
                                                                    <span className="hover-structure-metric">
                                                                        ËøõÂ∫¶ {percentLabel(item.progress, 0)}
                                                                    </span>
                                                                )}
                                                            </div>
                                                        ))}
                                                    </div>
                                                )}
                                                {(structureData.seg || []).length > 0 && (
                                                    <div className="hover-structure-section">
                                                        <div className="hover-structure-title">ÂΩìÂâçÁ∫øÊÆµ</div>
                                                        {(structureData.seg || []).map((item, idx) => (
                                                            <div className="hover-structure-row" key={`seg-${item.id ?? idx}`}>
                                                                <span className="hover-structure-metric">{item.label || `Á∫øÊÆµ${idx + 1}`}</span>
                                                                <Tag color={item.dir === 'down' ? 'geekblue' : item.dir === 'up' ? 'orange' : 'default'}>
                                                                    {item.dir === 'down' ? 'Âêë‰∏ã' : item.dir === 'up' ? 'Âêë‰∏ä' : 'Êú™Áü•'}
                                                                </Tag>
                                                                <span className="hover-structure-metric">
                                                                    {formatDateTime(item.beginTs)} ‚Üí {formatDateTime(item.endTs)}
                                                                </span>
                                                                {Number.isFinite(item.amplitude) && (
                                                                    <span className="hover-structure-metric">
                                                                        ÊåØÂπÖ {formatNumber(item.amplitude, 2)}
                                                                    </span>
                                                                )}
                                                                {Number.isFinite(item.amplitudePct) && (
                                                                    <span className="hover-structure-metric">
                                                                        {percentLabel(item.amplitudePct, 2)}
                                                                    </span>
                                                                )}
                                                                {Number.isFinite(item.durationMinutes) && (
                                                                    <span className="hover-structure-metric">
                                                                        ËÄóÊó∂ {minuteLabel(item.durationMinutes)} ÂàÜ
                                                                    </span>
                                                                )}
                                                                {Number.isFinite(item.progress) && (
                                                                    <span className="hover-structure-metric">
                                                                        ËøõÂ∫¶ {percentLabel(item.progress, 0)}
                                                                    </span>
                                                                )}
                                                            </div>
                                                        ))}
                                                    </div>
                                                )}
                                                {(structureData.zs || []).length > 0 && (
                                                    <div className="hover-structure-section">
                                                        <div className="hover-structure-title">ÂΩìÂâç‰∏≠Êû¢</div>
                                                        {(structureData.zs || []).map((item, idx) => (
                                                            <div className="hover-structure-row" key={`zs-${item.id ?? idx}`}>
                                                                <Tag color={item.source === 'seg' ? 'purple' : 'gold'}>
                                                                    {item.source === 'seg' ? 'ÊÆµ‰∏≠Êû¢' : 'Á¨î‰∏≠Êû¢'}
                                                                </Tag>
                                                                <Tag color={item.isSure ? 'green' : 'default'}>
                                                                    {item.isSure ? 'Á°ÆÂÆö' : 'Êú™Á°ÆËÆ§'}
                                                                </Tag>
                                                                <span className="hover-structure-metric">
                                                                    {formatDateTime(item.beginTs)} ‚Üí {formatDateTime(item.endTs)}
                                                                </span>
                                                                {(Number.isFinite(item.low) || Number.isFinite(item.high)) && (
                                                                    <span className="hover-structure-metric">
                                                                        Âå∫Èó¥ {Number.isFinite(item.low) ? formatNumber(item.low, 2) : '--'} ~ {Number.isFinite(item.high) ? formatNumber(item.high, 2) : '--'}
                                                                    </span>
                                                                )}
                                                                {Number.isFinite(item.range) && (
                                                                    <span className="hover-structure-metric">
                                                                        ÂÆΩÂ∫¶ {formatNumber(item.range, 2)}{Number.isFinite(item.rangePct) ? ` (${percentLabel(item.rangePct, 2)})` : ''}
                                                                    </span>
                                                                )}
                                                                {item.componentCount != null && (
                                                                    <span className="hover-structure-metric">
                                                                        ÁªÑÊàê {item.componentCount}{item.componentUnit || ''}
                                                                    </span>
                                                                )}
                                                                {Number.isFinite(item.durationMinutes) && (
                                                                    <span className="hover-structure-metric">
                                                                        ËÄóÊó∂ {minuteLabel(item.durationMinutes)} ÂàÜ
                                                                    </span>
                                                                )}
                                                            </div>
                                                       ))}
                                                   </div>
                                               )}
                                           </>
                                       ) : (
                                           <span className="chart-info-placeholder">ÂΩìÂâçKÁ∫øÊú™ÂåπÈÖç‰ªª‰ΩïÁ¨î„ÄÅÊÆµÊàñ‰∏≠Êû¢</span>
                                       )}
                                   </div>
                                )}
                            </>
                        ) : (
                            <span className="chart-info-placeholder">Â∞ÜÈº†Ê†áÁßªÂä®Âà∞KÁ∫øÊü•ÁúãËØ¶ÁªÜÊï∞ÊçÆ</span>
                        )}
                        </div>
                    </div>
                    <Drawer
                        open={replayVisible}
                        width={420}
                        onClose={handleReplayClose}
                        destroyOnClose
                        title={`‰ø°Âè∑ÂõûÊîæ ¬∑ ${stockCode} ¬∑ ${levelLabel}`}
                    >
                        {replaySignals.length === 0 ? (
                            <Empty description="Â∞öÊó†‰π∞ÂçñÁÇπ‰ø°Âè∑" />
                        ) : (
                            <>
                                <div style={{ marginBottom: 12, fontSize: 12, color: '#666' }}>
                                    Á¨¨ {replayIndex + 1} Êù° / ÂÖ± {replaySignals.length} Êù°
                                </div>
                                <Space size="small" style={{ marginBottom: 12 }}>
                                    <Button
                                        size="small"
                                        disabled={replayIndex <= 0}
                                        onClick={() => handleReplayIndexChange(replayIndex - 1)}
                                    >
                                        ‰∏ä‰∏ÄÊù°
                                    </Button>
                                    <Button
                                        size="small"
                                        disabled={replayIndex >= replaySignals.length - 1}
                                        onClick={() => handleReplayIndexChange(replayIndex + 1)}
                                    >
                                        ‰∏ã‰∏ÄÊù°
                                    </Button>
                                    <Button
                                        size="small"
                                        type="primary"
                                        onClick={handleJumpCurrent}
                                        disabled={!activeReplaySignal}
                                    >
                                        Ë∑≥ËΩ¨ÂõæË°®
                                    </Button>
                                </Space>
                                <div style={{ marginBottom: 12, padding: 8, borderRadius: 6, background: 'rgba(24,144,255,0.08)' }}>
                                    <div style={{ fontWeight: 600, marginBottom: 4 }}>
                                        ÂΩìÂâç‰ø°Âè∑
                                    </div>
                                    <div style={{ fontSize: 12, color: '#555' }}>
                                        {formatReplayLine(activeReplaySignal)}
                                    </div>
                                    {activeReplaySignal?.price != null && (
                                        <div style={{ fontSize: 12, color: '#555', marginTop: 4 }}>
                                            ‰ª∑Ê†ºÔºö{formatNumber(activeReplaySignal.price, 2)}
                                        </div>
                                    )}
                                </div>
                                <div style={{ maxHeight: 260, overflowY: 'auto', display: 'flex', flexDirection: 'column', gap: 6 }}>
                                    {replaySignals.map((signal, idx) => {
                                        const isActive = idx === replayIndex;
                                        return (
                                            <div
                                                key={`${signal.timestamp}-${signal.type || idx}`}
                                                style={{
                                                    padding: 8,
                                                    borderRadius: 6,
                                                    background: isActive ? 'rgba(24,144,255,0.12)' : 'rgba(0,0,0,0.04)',
                                                    display: 'flex',
                                                    justifyContent: 'space-between',
                                                    alignItems: 'center',
                                                    fontSize: 12,
                                                    cursor: 'pointer',
                                                }}
                                                onClick={() => handleReplayIndexChange(idx)}
                                            >
                                                <span>{formatReplayLine(signal)}</span>
                                                <Button size="small" type="link" onClick={() => handleJumpToSignal(signal)}>
                                                    ÂÆö‰Ωç
                                                </Button>
                                            </div>
                                        );
                                    })}
                                </div>
                            </>
                        )}
                    </Drawer>
                </div>
            );
        }

        const ChartSummary = memo(ChartSummaryComponent);

        const ActiveStockPanel = memo(() => {
            const {
                activeStock,
                activeLevels,
                setActiveLevels,
                levelLayout,
                setLevelLayout,
                chartDensity,
                setChartDensity,
                chartData,
                loadingCharts,
                analyzeStock,
                refreshAllCharts,
                indicators,
                setIndicators,
                chanConfig,
            } = useApp();

            useEffect(() => {
                if (!activeStock) {
                    return;
                }
                activeLevels.forEach(level => analyzeStock(activeStock.code, level));
            }, [activeStock?.code, activeLevels.join(','), analyzeStock]);

            if (!activeStock) {
                return (
                    <div className="watchlist-empty" style={{ marginTop: 40 }}>
                        ËØ∑ÈÄâÊã©Â∑¶‰æßËá™ÈÄâËÇ°Á•®ÂºÄÂßãÂàÜÊûê
                    </div>
                );
            }

            const displayTitle = activeStock.name ? `${activeStock.name} ¬∑ ${activeStock.code}` : activeStock.code;

            const handleLevelToggle = (level) => {
                const isActive = activeLevels.includes(level);
                if (isActive) {
                    if (activeLevels.length === 1) {
                        message.warning('Ëá≥Â∞ë‰øùÁïô‰∏Ä‰∏™Âë®Êúü');
                        return;
                    }
                    setActiveLevels(prev => prev.filter(item => item !== level));
                } else {
                    setActiveLevels(prev => {
                        const next = [...prev, level];
                        analyzeStock(activeStock.code, level);
                        return next;
                    });
                }
            };

            const normalizedBspFilters = useMemo(
                () => SignalUtils.normalizeFilters(indicators?.bsp_filters),
                [indicators?.bsp_filters]
            );

            const filterBspList = useCallback(
                (list) => SignalUtils.filterSignals(list, normalizedBspFilters),
                [normalizedBspFilters]
            );

            const aggregateBspTypes = useCallback((list) => {
                if (!Array.isArray(list) || list.length === 0) {
                    return {};
                }
                return list.reduce((map, item) => {
                    const typeKey = SignalUtils.normalizeBspType(item.type);
                    map[typeKey] = (map[typeKey] || 0) + 1;
                    return map;
                }, {});
            }, []);

            const aggregateBspTypesByDir = useCallback((list) => {
                if (!Array.isArray(list) || list.length === 0) {
                    return {};
                }
                return list.reduce((map, item) => {
                    const typeKey = SignalUtils.normalizeBspType(item.type);
                    if (!map[typeKey]) {
                        map[typeKey] = { buy: 0, sell: 0 };
                    }
                    const dirKey = item && item.is_buy ? 'buy' : 'sell';
                    map[typeKey][dirKey] = (map[typeKey][dirKey] || 0) + 1;
                    return map;
                }, {});
            }, []);

            const statsByLevel = activeLevels.reduce((acc, level) => {
                const key = `${activeStock.code}-${level}`;
                const data = chartData[key];
                if (!data) {
                    acc[level] = null;
                    return acc;
                }
                const meta = data.meta || {};
                const bspList = data.bsp_list || [];
                const filteredBspList = filterBspList(bspList);
                const safeNumber = (value) => {
                    if (typeof value === 'number') {
                        return Number.isFinite(value) ? value : null;
                    }
                    if (value === null || value === undefined) {
                        return null;
                    }
                    const parsed = parseFloat(value);
                    return Number.isFinite(parsed) ? parsed : null;
                };
                const toDurationMinutes = (start, end) => {
                    const startTs = convertTime(start);
                    let endTs = convertTime(end);
                    if (!Number.isFinite(endTs) && Number.isFinite(startTs)) {
                        endTs = startTs;
                    }
                    if (!Number.isFinite(startTs) || !Number.isFinite(endTs)) {
                        return null;
                    }
                    return Math.abs(endTs - startTs) / 60000;
                };
                const average = (values) => {
                    if (!Array.isArray(values) || values.length === 0) {
                        return null;
                    }
                    const total = values.reduce((sum, item) => sum + item, 0);
                    return total / values.length;
                };

                const { biStrength, segStrength } = deriveStrengthMetrics(data, chanConfig);

                const biDurations = [];
                const biAmplitudes = [];
                (data.bi_list || []).forEach(bi => {
                    const duration = toDurationMinutes(bi.begin_time, bi.end_time);
                    if (Number.isFinite(duration)) {
                        biDurations.push(duration);
                    }
                    const beginPrice = safeNumber(bi.begin_price);
                    const endPrice = safeNumber(bi.end_price);
                    if (Number.isFinite(beginPrice) && Number.isFinite(endPrice)) {
                        biAmplitudes.push(Math.abs(endPrice - beginPrice));
                    }
                });

                const segDurations = [];
                const segAmplitudes = [];
                (data.seg_list || []).forEach(seg => {
                    const duration = toDurationMinutes(seg.begin_time, seg.end_time);
                    if (Number.isFinite(duration)) {
                        segDurations.push(duration);
                    }
                    const beginPrice = safeNumber(seg.begin_price);
                    const endPrice = safeNumber(seg.end_price);
                    if (Number.isFinite(beginPrice) && Number.isFinite(endPrice)) {
                        segAmplitudes.push(Math.abs(endPrice - beginPrice));
                    }
                });

                const zsList = Array.isArray(data.zs_list) ? data.zs_list : [];
                const zsSureCount = zsList.filter(item => item && item.is_sure).length;
                const zsSureRatio = zsList.length > 0 ? zsSureCount / zsList.length : null;

                const latestSignals = SignalUtils.sortByTimestampDesc(filteredBspList, convertTime)
                    .map(item => ({
                        ...item,
                        price: safeNumber(item.price),
                    }))
                    .slice(0, 4);

                const rawBspCount = bspList.length;
                const rawBuyCount = bspList.filter(item => item.is_buy).length;
                const filteredBuyCount = filteredBspList.filter(item => item.is_buy).length;
                const filteredSellCount = filteredBspList.length - filteredBuyCount;
                const filteredTypeMap = aggregateBspTypes(filteredBspList);
                const rawTypeMap = aggregateBspTypes(bspList);
                const filteredTypeDirMap = aggregateBspTypesByDir(filteredBspList);
                const rawTypeDirMap = aggregateBspTypesByDir(bspList);

                acc[level] = {
                    kline: meta.total_klines ?? data.kline_data?.length ?? 0,
                    bi: meta.bi_count ?? data.bi_list?.length ?? 0,
                    seg: meta.seg_count ?? data.seg_list?.length ?? 0,
                    zs: meta.zs_count ?? data.zs_list?.length ?? 0,
                    bsp: filteredBspList.length,
                    buy: filteredBuyCount,
                    sell: filteredSellCount,
                    rawBspCount,
                    rawBuyCount,
                    rawSellCount: rawBspCount - rawBuyCount,
                    biAvgDuration: average(biDurations),
                    biAvgAmplitude: average(biAmplitudes),
                    segAvgDuration: average(segDurations),
                    segAvgAmplitude: average(segAmplitudes),
                    zsSureRatio,
                    bspTypes: filteredTypeMap,
                    rawBspTypes: rawTypeMap,
                    bspTypesByDir: filteredTypeDirMap,
                    rawBspTypesByDir: rawTypeDirMap,
                    biStrength,
                    segStrength,
                    latestSignals,
                };
                return acc;
            }, {});

            let columnsClass = 'columns-1';
            if (levelLayout === 'grid' && activeLevels.length > 1) {
                columnsClass = activeLevels.length >= 3 ? 'columns-3' : 'columns-2';
            }

            return (
                <div className="stock-chart-group">
                    <div className="stock-chart-header">
                        <div className="stock-chart-title">{displayTitle}</div>
                        <Space>
                            <Tooltip title="Âà∑Êñ∞ÂΩìÂâçËÇ°Á•®ÊâÄÊúâÂë®Êúü">
                                <Button size="small" onClick={refreshAllCharts}>
                                    üîÑ Âà∑Êñ∞
                                </Button>
                            </Tooltip>
                        </Space>
                    </div>
                    <div className="stock-chart-toolbar">
                        <div className="period-buttons">
                            {LEVEL_OPTIONS.map(option => {
                                const active = activeLevels.includes(option.value);
                                return (
                                    <Button
                                        key={option.value}
                                        type={active ? 'primary' : 'default'}
                                        onClick={() => handleLevelToggle(option.value)}
                                    >
                                        {option.label}
                                    </Button>
                                );
                            })}
                        </div>
                        <Space size="small" align="center" wrap>
                            <Radio.Group
                                size="small"
                                value={levelLayout}
                                onChange={e => setLevelLayout(e.target.value)}
                                buttonStyle="solid"
                            >
                                <Radio.Button value="stack">Á∫µÂêë</Radio.Button>
                                <Radio.Button value="grid" disabled={activeLevels.length < 2}>Âπ∂Êéí</Radio.Button>
                            </Radio.Group>
                            <Tooltip title="Ëøõ‰∏ÄÊ≠•ÊãâÂºÄÂçïÂõæÈ´òÂ∫¶‰∏éÈó¥Ë∑ù">
                                <Segmented
                                    size="small"
                                    value={chartDensity}
                                    onChange={setChartDensity}
                                    options={[
                                        { label: 'ÂÆΩÊùæ', value: 'wide' },
                                        { label: 'Êõ¥ÂÆΩ', value: 'ultra' },
                                        { label: 'Ë∂ÖÂÆΩ', value: 'mega' },
                                    ]}
                                />
                            </Tooltip>
                            {(indicators.indicator_layout === 'tab' && LOWER_INDICATOR_KEYS.some(key => indicators[`plot_${key}`])) && (
                                <Select
                                    size="small"
                                    style={{ width: 120 }}
                                    value={indicators.indicator_tab}
                                    onChange={value => setIndicators(prev => ({ ...prev, indicator_tab: value }))}
                                    options={LOWER_INDICATOR_KEYS.filter(key => indicators[`plot_${key}`]).map(key => ({
                                        value: key,
                                        label: key === 'macd' ? 'MACD' : key.toUpperCase(),
                                    }))}
                                />
                            )}
                        </Space>
                    </div>
                    <div className={`stock-chart-panels ${columnsClass} density-${chartDensity}`}>
                        {activeLevels.map(level => {
                            const key = `${activeStock.code}-${level}`;
                            return (
                                <ChartPanel
                                    key={key}
                                    stockCode={activeStock.code}
                                    level={level}
                                    data={chartData[key]}
                                    loading={loadingCharts[key]}
                                    stats={statsByLevel[level]}
                                    multiLevelStats={statsByLevel}
                                />
                            );
                        })}
                </div>
            </div>
        );
        });

        // ============= Stock Manager Component =============
        const StockManager = memo(() => {
            const {
                stocks,
                addStock,
                removeStock,
                activeStockCode,
                setActiveStockCode,
            } = useApp();

            const [searchValue, setSearchValue] = useState('');
            const [searchOptions, setSearchOptions] = useState([]);
            const [searchLoading, setSearchLoading] = useState(false);
            const [manualCode, setManualCode] = useState('');

            const runSearch = useMemo(() => debounce(async (value) => {
                if (!value || value.trim().length < 2) {
                    setSearchOptions([]);
                    setSearchLoading(false);
                    return;
                }
                try {
                    const results = await api.searchStocks(value);
                    setSearchOptions(results.map(item => ({
                        value: item.code,
                        label: `${item.code} ¬∑ ${item.name}`,
                        code: item.code,
                        name: item.name,
                    })));
                } catch (error) {
                    debugError('‚ö†Ô∏è ÊêúÁ¥¢ËÇ°Á•®Â§±Ë¥•:', error);
                    setSearchOptions([]);
                } finally {
                    setSearchLoading(false);
                }
            }, 350), []);

            const handleSearchChange = (value) => {
                setSearchValue(value);
                if (!value) {
                    setSearchOptions([]);
                    setSearchLoading(false);
                    return;
                }
                setSearchLoading(true);
                runSearch(value);
            };

            const handleSearchSelect = (value, option) => {
                const result = addStock({ code: option.code, name: option.name });
                if (result === 'new') {
                    message.success(`Â∑≤Ê∑ªÂä† ${option.label}`);
                } else if (result === 'updated') {
                    message.success(`Â∑≤Êõ¥Êñ∞ ${option.label}`);
                }
                setActiveStockCode(option.code);
                setSearchValue('');
                setSearchOptions([]);
            };

            const handleManualAdd = () => {
                const code = manualCode.trim();
                if (!code) {
                    message.warning('ËØ∑ËæìÂÖ•ËÇ°Á•®‰ª£Á†Å');
                    return;
                }
                const result = addStock({ code });
                if (result === 'new') {
                    message.success(`Â∑≤Ê∑ªÂä† ${code}`);
                } else if (result === 'updated') {
                    message.success(`Â∑≤Êõ¥Êñ∞ ${code}`);
                } else if (result === 'unchanged') {
                    message.info(`${code} Â∑≤Âú®Ëá™ÈÄâÂàóË°®`);
                }
                setActiveStockCode(code);
                setManualCode('');
            };

            const handleQuickAdd = (stock) => {
                const result = addStock({ code: stock.code, name: stock.name });
                if (result === 'new') {
                    message.success(`Â∑≤Ê∑ªÂä† ${stock.name}`);
                } else if (result === 'updated') {
                    message.success(`Â∑≤Êõ¥Êñ∞ ${stock.name}`);
                } else if (result === 'unchanged') {
                    message.info(`${stock.name} Â∑≤Âú®Ëá™ÈÄâÂàóË°®`);
                }
                setActiveStockCode(stock.code);
            };

            const WatchlistItem = ({ stock }) => {
                const isActive = stock.code === activeStockCode;
                return (
                    <List.Item className={`watchlist-item ${isActive ? 'watchlist-item--active' : ''}`} key={stock.id}>
                        <div className="watchlist-item__header">
                            <div className="watchlist-item__info">
                                <div className="watchlist-item__code">{stock.name || stock.code}</div>
                                {stock.name && <div className="watchlist-item__meta">{stock.code}</div>}
                            </div>
                            <Space size="small">
                                {!isActive && (
                                    <Button size="small" onClick={() => setActiveStockCode(stock.code)}>
                                        Êü•Áúã
                                    </Button>
                                )}
                                <Button size="small" danger onClick={() => removeStock(stock.id)}>
                                    Âà†Èô§
                                </Button>
                            </Space>
                        </div>
                    </List.Item>
                );
            };

            return (
                <div className="stock-manager">
                    <div>
                        <div className="stock-manager-title">Ëá™ÈÄâËÇ°Á•®</div>
                        <div className="stock-manager-subtitle">ÊêúÁ¥¢ÊàñÊâãÂä®ËæìÂÖ•‰ª£Á†ÅÊ∑ªÂä†ÔºåÁÇπÂáªÂç≥ÂèØÂàáÊç¢</div>
                    </div>

                    <div className="stock-add-card">
                        <AutoComplete
                            value={searchValue}
                            options={searchOptions}
                            onSearch={handleSearchChange}
                            onSelect={handleSearchSelect}
                            onChange={value => setSearchValue(value)}
                            placeholder="ÊêúÁ¥¢ËÇ°Á•®‰ª£Á†Å / ÂêçÁß∞ÔºàËá≥Â∞ëËæìÂÖ•2‰∏™Â≠óÁ¨¶Ôºâ"
                            style={{ width: '100%' }}
                        >
                            <Input
                                suffix={searchLoading ? <Spin size="small" /> : null}
                                allowClear
                            />
                        </AutoComplete>
                        <Space.Compact style={{ width: '100%' }}>
                            <Input
                                placeholder="ÊàñÁõ¥Êé•ËæìÂÖ•ËÇ°Á•®‰ª£Á†ÅÊ∑ªÂä†"
                                value={manualCode}
                                onChange={e => setManualCode(e.target.value)}
                                onPressEnter={handleManualAdd}
                            />
                            <Button type="primary" onClick={handleManualAdd}>
                                Ê∑ªÂä†
                            </Button>
                        </Space.Compact>
                        <div className="stock-add-hint">
                            ÈÄâ‰∏≠Ëá™ÈÄâÈ°πÂêéÔºåÂèØÂú®‰∏ªÈù¢Êùø‰∏≠ÂêåÊó∂Êü•ÁúãÂ§öÂë®Êúü K Á∫ø„ÄÇ
                        </div>
                    </div>

                    <div className="stock-quick-area">
                        <div className="stock-quick-title">Âø´ÈÄüÊ∑ªÂä†</div>
                        <Space size={[8, 8]} wrap>
                            {QUICK_STOCKS.map(stock => (
                                <Button key={stock.code} size="small" onClick={() => handleQuickAdd(stock)}>
                                    {stock.name}
                                </Button>
                            ))}
                        </Space>
                    </div>

                    <Divider style={{ margin: '8px 0' }} />

                    {stocks.length === 0 ? (
                        <div className="watchlist-empty">
                            ÊöÇÊó†Ëá™ÈÄâËÇ°Á•®ÔºåÂÖàÊ∑ªÂä†‰∏ÄÂè™ÁúãÁúã~
                        </div>
                    ) : (
                        <List
                            split={false}
                            dataSource={stocks}
                            locale={{ emptyText: <Empty description="ÊöÇÊó†Ëá™ÈÄâËÇ°Á•®" /> }}
                            renderItem={(stock) => <WatchlistItem stock={stock} />}
                        />
                    )}
                    <WatchlistOverview />
                </div>
            );
        });

        const WatchlistOverview = memo(() => {
            const {
                stocks,
                chartData,
                analyzeStock,
                activeLevels,
                setActiveStockCode,
                setActiveLevels,
                indicators,
                chanConfig,
            } = useApp();

            const overviewLevels = useMemo(() => (
                activeLevels && activeLevels.length > 0 ? activeLevels : [DEFAULT_LEVEL]
            ), [activeLevels]);

            const normalizedBspFilters = useMemo(
                () => SignalUtils.normalizeFilters(indicators?.bsp_filters),
                [indicators?.bsp_filters]
            );

            const filterSignals = useCallback(
                (list) => SignalUtils.filterSignals(list, normalizedBspFilters),
                [normalizedBspFilters]
            );

            const safeNumber = useCallback((value) => {
                if (typeof value === 'number') {
                    return Number.isFinite(value) ? value : null;
                }
                if (value === null || value === undefined) {
                    return null;
                }
                const parsed = parseFloat(value);
                return Number.isFinite(parsed) ? parsed : null;
            }, []);

            const summarizeLevel = useCallback((stockCode, level) => {
                const key = `${stockCode}-${level}`;
                const data = chartData[key];
                if (!data) {
                    return { level, status: 'missing' };
                }
                const filteredSignals = filterSignals(data.bsp_list || []);
                let latestSignal = null;
                if (filteredSignals.length > 0) {
                    const sorted = SignalUtils.sortByTimestampDesc(filteredSignals, convertTime)
                        .map(item => ({
                            ...item,
                            price: safeNumber(item.price),
                            typeKey: SignalUtils.normalizeBspType(item.type),
                        }));
                    if (sorted.length > 0) {
                        const top = sorted[0];
                        latestSignal = {
                            isBuy: !!top.is_buy,
                            type: top.typeKey,
                            timestamp: top.timestamp,
                            price: top.price,
                        };
                    }
                }
                const { biStrength, segStrength } = deriveStrengthMetrics(data, chanConfig);
                return {
                    level,
                    status: 'ready',
                    latestSignal,
                    biStrength,
                    segStrength,
                };
            }, [chartData, filterSignals, chanConfig, safeNumber]);

            const rows = useMemo(() => (
                stocks.map(stock => ({
                    stock,
                    entries: overviewLevels.map(level => summarizeLevel(stock.code, level)),
                }))
            ), [stocks, overviewLevels, summarizeLevel]);

            if (stocks.length === 0) {
                return null;
            }

            const handleActivate = (stockCode, level) => {
                setActiveStockCode(stockCode);
                setActiveLevels(prev => {
                    if (prev.includes(level)) {
                        return prev;
                    }
                    return [...prev, level];
                });
            };

            const handleAnalyze = (stockCode, level) => {
                analyzeStock(stockCode, level, true);
            };

            const formatSignal = (info) => {
                if (!info) {
                    return 'Êó†‰ø°Âè∑';
                }
                const timeText = dayjs(info.timestamp).format('MM-DD HH:mm');
                return `${info.isBuy ? '‰π∞' : 'Âçñ'} ¬∑ ${info.type} ¬∑ ${timeText}`;
            };

            const strengthSummary = (strength) => {
                if (!strength) return 'Êú™ËÆ°ÁÆó';
                if (strength.hint) {
                    return strength.hint;
                }
                if (strength.amplitudeRatio != null) {
                    const percent = ((strength.amplitudeRatio - 1) * 100).toFixed(1);
                    return `ÊåØÂπÖ ${percent}%`;
                }
                return 'Êó†Êï∞ÊçÆ';
            };

            return (
                <div className="watchlist-overview">
                    <div className="watchlist-overview__header">ÁúãÁõòÊ¶ÇËßà</div>
                    {rows.map(({ stock, entries }) => (
                        <div className="watchlist-overview__stock" key={stock.code}>
                            <div className="watchlist-overview__stock-name">
                                {stock.name ? `${stock.name} ¬∑ ${stock.code}` : stock.code}
                            </div>
                            <div className="watchlist-overview__rows">
                                {entries.map(entry => (
                                    <div className="watchlist-overview__row" key={`${stock.code}-${entry.level}`}>
                                        <div className="watchlist-overview__level-info">
                                            <span>{LEVEL_OPTIONS.find(opt => opt.value === entry.level)?.label || entry.level}</span>
                                            {entry.status === 'ready' ? (
                                                <>
                                                    <span>{formatSignal(entry.latestSignal)}</span>
                                                    <span>Á¨îÔºö{strengthSummary(entry.biStrength)} / ÊÆµÔºö{strengthSummary(entry.segStrength)}</span>
                                                </>
                                            ) : (
                                                <span>Â∞öÊú™ÂàÜÊûê</span>
                                            )}
                                        </div>
                                        <div className="watchlist-overview__actions">
                                            <Button size="small" onClick={() => handleActivate(stock.code, entry.level)}>
                                                Êü•Áúã
                                            </Button>
                                            <Button size="small" type="link" onClick={() => handleAnalyze(stock.code, entry.level)}>
                                                {entry.status === 'ready' ? 'Âà∑Êñ∞' : 'ÂàÜÊûê'}
                                            </Button>
                                        </div>
                                    </div>
                                ))}
                            </div>
                        </div>
                    ))}
                </div>
            );
        });

        // ÂõûÊµãÊéßÂà∂Âè∞ÔºöÂØπÊé•ÂêéÁ´ØÂõûÊµãÈòüÂàóËÉΩÂäõ
        const BacktestConsole = memo(() => {
            const {
                stocks,
                indicators,
                chartData,
                analyzeStock,
                setActiveStockCode,
                setActiveLevels,
                requestChartFocus,
                chanConfig,
            } = useApp();

            const [form, setForm] = useState(() => ({
                stockCode: '',
                level: DEFAULT_LEVEL,
                directions: [...DEFAULT_BSP_FILTERS.directions],
                types: [],
            }));
            const [queue, setQueue] = useState([]);
            const [loadingQueue, setLoadingQueue] = useState(false);
            const [inspectorVisible, setInspectorVisible] = useState(false);
            const [inspectorData, setInspectorData] = useState(null);

            useEffect(() => {
                if (stocks.length > 0 && !form.stockCode) {
                    setForm(prev => ({ ...prev, stockCode: stocks[0].code }));
                }
            }, [stocks, form.stockCode]);

            useEffect(() => {
                try {
                    localStorage.setItem('chan_backtest_queue', JSON.stringify(queue));
                } catch (err) {
                    debugWarn('‚ö†Ô∏è Failed to persist backtest queue:', err);
                }
            }, [queue]);

            const syncQueueFromServer = useCallback(async () => {
                setLoadingQueue(true);
                try {
                    const result = await api.listBacktestQueue();
                    const hydrated = Array.isArray(result) ? result.map(hydrateJob).filter(Boolean) : [];
                    setQueue(hydrated.length > 0 ? sortByCreated(hydrated) : []);
                } catch (error) {
                    debugError('Âä†ËΩΩÂõûÊµãÈòüÂàóÂ§±Ë¥•:', error);
                    message.error(`ÂõûÊµãÈòüÂàóÂä†ËΩΩÂ§±Ë¥•Ôºö${error.message}`);
                } finally {
                    setLoadingQueue(false);
                }
            }, [hydrateJob, sortByCreated]);

            useEffect(() => {
                syncQueueFromServer();
            }, [syncQueueFromServer]);

            const normalizeFilters = useCallback(
                (filters) => SignalUtils.normalizeFilters({
                    directions: filters?.directions ?? DEFAULT_BSP_FILTERS.directions,
                    types: filters?.types ?? [],
                }),
                []
            );

            const normalizeSignals = useCallback((signals) => {
                if (!Array.isArray(signals) || signals.length === 0) {
                    return [];
                }
                return signals
                    .map(item => {
                        if (!item) {
                            return null;
                        }
                        if (Number.isFinite(item.timestamp)) {
                            return item;
                        }
                        const ts = convertTime(item.timestamp ?? item.time);
                        if (!Number.isFinite(ts)) {
                            return item;
                        }
                        return { ...item, timestamp: ts };
                    })
                    .filter(Boolean);
            }, []);

            const ensureSampleTimestamp = useCallback((sample) => {
                if (!sample) {
                    return null;
                }
                if (Number.isFinite(sample.timestamp)) {
                    return sample;
                }
                const ts = convertTime(sample.timestamp ?? sample.time);
                if (!Number.isFinite(ts)) {
                    return sample;
                }
                return { ...sample, timestamp: ts };
            }, []);

            const sortByCreated = useCallback((list) => (
                list.slice().sort((a, b) => dayjs(b.createdAt).valueOf() - dayjs(a.createdAt).valueOf())
            ), []);

            const hydrateJob = useCallback((job) => {
                if (!job) {
                    return null;
                }
                const filters = normalizeFilters(job.filters);
                const status = job.status ? String(job.status).toLowerCase() : 'pending';
                const createdAt = job.createdAt || job.created_at || new Date().toISOString();
                const lastRunAt = job.lastRunAt || job.last_run_at || null;
                const errorMessage = job.errorMessage || job.error_message || null;
                let summary = null;
                if (job.lastSummary) {
                    summary = {
                        ...job.lastSummary,
                        sampleSignal: ensureSampleTimestamp(job.lastSummary.sampleSignal),
                        strength: job.lastSummary.strength || null,
                        signals: normalizeSignals(job.lastSummary.signals),
                        resultInfo: job.lastSummary.resultInfo || null,
                    };
                }
                return {
                    ...job,
                    status,
                    filters,
                    createdAt,
                    lastRunAt,
                    errorMessage,
                    lastSummary: summary,
                };
            }, [normalizeFilters, ensureSampleTimestamp, normalizeSignals]);

            const mergeHydratedJob = useCallback((hydrated) => {
                if (!hydrated) {
                    return;
                }
                setQueue(prev => sortByCreated([
                    hydrated,
                    ...prev.filter(item => item.id !== hydrated.id),
                ]));
            }, [sortByCreated]);

            const mergeJob = useCallback((job) => {
                const hydrated = hydrateJob(job);
                if (hydrated) {
                    mergeHydratedJob(hydrated);
                }
            }, [hydrateJob, mergeHydratedJob]);

            useEffect(() => {
                try {
                    const saved = localStorage.getItem('chan_backtest_queue');
                    if (!saved) {
                        return;
                    }
                    const parsed = JSON.parse(saved);
                    if (!Array.isArray(parsed) || parsed.length === 0) {
                        return;
                    }
                    const hydrated = parsed.map(hydrateJob).filter(Boolean);
                    if (hydrated.length > 0) {
                        setQueue(prev => (prev.length > 0 ? prev : sortByCreated(hydrated)));
                    }
                } catch (err) {
                    debugWarn('‚ö†Ô∏è Failed to load backtest queue:', err);
                }
            }, [hydrateJob, sortByCreated]);

            const computeSummary = useCallback((entry) => {
                const key = `${entry.stockCode}-${entry.level}`;
                const data = chartData[key];
                const filters = normalizeFilters(entry.filters);
                if (data) {
                    const filtered = SignalUtils.filterSignals(data.bsp_list || [], filters);
                    const sorted = SignalUtils.sortByTimestampDesc(filtered, convertTime);
                    const sample = sorted.length > 0 ? sorted[0] : null;
                    const { biStrength, segStrength } = deriveStrengthMetrics(data, chanConfig);
                    return {
                        status: 'ready',
                        signalCount: filtered.length,
                        sampleSignal: sample,
                        strength: { biStrength, segStrength },
                        signals: sorted,
                        resultInfo: {
                            klineCount: (data.kline_data || []).length,
                            rawKlineCount: (data.raw_kline_data || []).length,
                            biCount: (data.bi_list || []).length,
                            segCount: (data.seg_list || []).length,
                            zsCount: (data.zs_list || []).length,
                            bspCount: (data.bsp_list || []).length,
                            meta: data.meta || null,
                        },
                    };
                }
                if (entry.lastSummary) {
                    return {
                        ...entry.lastSummary,
                        sampleSignal: ensureSampleTimestamp(entry.lastSummary.sampleSignal),
                        strength: entry.lastSummary.strength || null,
                        signals: normalizeSignals(entry.lastSummary.signals),
                        resultInfo: entry.lastSummary.resultInfo || null,
                    };
                }
                return {
                    status: 'pending',
                    signalCount: 0,
                    sampleSignal: null,
                    strength: null,
                    signals: [],
                    resultInfo: null,
                };
            }, [chartData, normalizeFilters, chanConfig, ensureSampleTimestamp, normalizeSignals]);

            const handleFormChange = useCallback((patch) => {
                setForm(prev => ({ ...prev, ...patch }));
            }, []);

            const handleAddToQueue = useCallback(async () => {
                if (!form.stockCode) {
                    message.warning('ËØ∑ÈÄâÊã©ËÇ°Á•®');
                    return;
                }
                try {
                    const filters = normalizeFilters({ directions: form.directions, types: form.types });
                    const payload = {
                        stockCode: form.stockCode,
                        level: form.level,
                        dataSrc: 'BAO_STOCK',
                        filters,
                        chanConfig,
                        indicatorOverrides: indicators,
                    };
                    const job = await api.enqueueBacktestJob(payload);
                    mergeJob(job);
                    message.success('Â∑≤Âä†ÂÖ•ÂõûÊµãÈòüÂàó');
                } catch (error) {
                    debugError('Âä†ÂÖ•ÂõûÊµãÈòüÂàóÂ§±Ë¥•:', error);
                    message.error(`Âä†ÂÖ•ÂõûÊµãÈòüÂàóÂ§±Ë¥•Ôºö${error.message}`);
                }
            }, [form, normalizeFilters, chanConfig, indicators, mergeJob]);

            const removeEntry = useCallback(async (id) => {
                try {
                    await api.deleteBacktestJob(id);
                    setQueue(prev => prev.filter(item => item.id !== id));
                    message.success('Â∑≤Âà†Èô§ÂõûÊµã‰ªªÂä°');
                } catch (error) {
                    debugError('Âà†Èô§ÂõûÊµã‰ªªÂä°Â§±Ë¥•:', error);
                    message.error(`Âà†Èô§Â§±Ë¥•Ôºö${error.message}`);
                }
            }, []);

            const ensureChartData = useCallback(async (stockCode, level) => {
                const key = `${stockCode}-${level}`;
                if (!chartData[key]) {
                    await analyzeStock(stockCode, level, true);
                    return false;
                }
                return true;
            }, [chartData, analyzeStock]);

            const handleRunEntry = useCallback(async (entry) => {
                try {
                    setQueue(prev => prev.map(item => item.id === entry.id ? { ...item, status: 'running' } : item));
                    const job = await api.runBacktestJob(entry.id, { forceRefresh: false });
                    const hydrated = hydrateJob(job);
                    mergeHydratedJob(hydrated);
                    const signal = hydrated?.lastSummary?.sampleSignal;
                    if (!signal) {
                        message.info('Á≠õÈÄâÊù°‰ª∂‰∏ãÊöÇÊó†‰ø°Âè∑');
                        return;
                    }
                    const timestamp = Number.isFinite(signal.timestamp)
                        ? signal.timestamp
                        : convertTime(signal.timestamp ?? signal.time);
                    if (!Number.isFinite(timestamp)) {
                        message.warning('ËøîÂõû‰ø°Âè∑Áº∫Â∞ëÊó∂Èó¥‰ø°ÊÅØ');
                        return;
                    }
                    const ready = await ensureChartData(hydrated.stockCode, hydrated.level);
                    if (!ready) {
                        message.info('Â∑≤ËØ∑Ê±ÇÊúÄÊñ∞Êï∞ÊçÆÔºåÁ®çÂêéÂèØÂÜçÊ¨°ËøêË°å');
                        return;
                    }
                    setActiveStockCode(hydrated.stockCode);
                    setActiveLevels(prev => (prev.includes(hydrated.level) ? prev : [...prev, hydrated.level]));
                    requestChartFocus({ stockCode: hydrated.stockCode, level: hydrated.level, timestamp });
                    message.success('Â∑≤ÂÆö‰ΩçËá≥ÊúÄÊñ∞‰ø°Âè∑');
                } catch (error) {
                    debugError('ÊâßË°åÂõûÊµãÂ§±Ë¥•:', error);
                    setQueue(prev => prev.map(item => item.id === entry.id ? { ...item, status: 'failed', errorMessage: error.message } : item));
                    message.error(`ÊâßË°åÂ§±Ë¥•Ôºö${error.message}`);
                }
            }, [hydrateJob, mergeHydratedJob, ensureChartData, setActiveStockCode, setActiveLevels, requestChartFocus]);

            const handleRefreshEntry = useCallback(async (entry) => {
                try {
                    setQueue(prev => prev.map(item => item.id === entry.id ? { ...item, status: 'running' } : item));
                    const job = await api.runBacktestJob(entry.id, { forceRefresh: true });
                    mergeJob(job);
                    await analyzeStock(entry.stockCode, entry.level, true);
                    message.success('Â∑≤Âà∑Êñ∞ËØ•Âë®ÊúüÊï∞ÊçÆ');
                } catch (error) {
                    debugError('Âà∑Êñ∞ÂõûÊµãÊï∞ÊçÆÂ§±Ë¥•:', error);
                    setQueue(prev => prev.map(item => item.id === entry.id ? { ...item, status: 'failed', errorMessage: error.message } : item));
                    message.error(`Âà∑Êñ∞Â§±Ë¥•Ôºö${error.message}`);
                }
            }, [mergeJob, analyzeStock]);

            const allTypes = useMemo(() => {
                const key = form.stockCode ? `${form.stockCode}-${form.level}` : null;
                if (!key || !chartData[key]) return [];
                const list = chartData[key].bsp_list || [];
                return Array.from(new Set(list.map(item => SignalUtils.normalizeBspType(item.type))));
            }, [chartData, form.stockCode, form.level]);

            const statusLabel = {
                pending: 'ÂæÖÊâßË°å',
                running: 'ÊâßË°å‰∏≠',
                completed: 'Â∑≤ËøêË°å',
                failed: 'Â§±Ë¥•',
            };

            const openSignalInspector = useCallback((entry, summary) => {
                if (!summary?.signals?.length) {
                    message.info('ÊöÇÊó†‰ø°Âè∑');
                    return;
                }
                setInspectorData({ entry, summary });
                setInspectorVisible(true);
            }, []);

            const closeSignalInspector = useCallback(() => {
                setInspectorVisible(false);
                setInspectorData(null);
            }, []);

            return (
                <div style={{ display: 'flex', flexDirection: 'column', gap: 16 }}>
                    <div className="config-section">
                        <div className="config-section-title">ÂõûÊµãËÆæÁΩÆ</div>
                        <div className="config-grid config-grid--two">
                            <div className="config-field">
                                <label>ËÇ°Á•®</label>
                                <Select
                                    size="small"
                                    placeholder="ÈÄâÊã©ËÇ°Á•®"
                                    value={form.stockCode || undefined}
                                    onChange={value => handleFormChange({ stockCode: value })}
                                    options={stocks.map(stock => ({
                                        value: stock.code,
                                        label: stock.name ? `${stock.name} ¬∑ ${stock.code}` : stock.code,
                                    }))}
                                />
                            </div>
                            <div className="config-field">
                                <label>Á∫ßÂà´</label>
                                <Select
                                    size="small"
                                    value={form.level}
                                    onChange={value => handleFormChange({ level: value })}
                                    options={LEVEL_OPTIONS}
                                />
                            </div>
                            <div className="config-field config-field--full">
                                <label>ÊñπÂêëÁ≠õÈÄâ</label>
                                <Checkbox.Group
                                    options={[
                                        { label: '‰π∞ÁÇπ', value: 'buy' },
                                        { label: 'ÂçñÁÇπ', value: 'sell' },
                                    ]}
                                    value={form.directions}
                                    onChange={(values) => handleFormChange({ directions: values })}
                                />
                            </div>
                            <div className="config-field config-field--full">
                                <label>Á±ªÂûãÁ≠õÈÄâ</label>
                                <Select
                                    mode="tags"
                                    allowClear
                                    size="small"
                                    value={form.types}
                                    onChange={(values) => handleFormChange({ types: values })}
                                    placeholder="ÂèØËæìÂÖ•‰ø°Âè∑Á±ªÂûãÔºåÂ¶Ç 1, 1p"
                                    options={allTypes.map(type => ({ value: type, label: type }))}
                                />
                                <span className="config-hint">ÁïôÁ©∫ÈªòËÆ§ÂÖ®ÈÉ®Á±ªÂûã</span>
                            </div>
                        </div>
                        <Button
                            size="small"
                            type="primary"
                            style={{ marginTop: 8 }}
                            onClick={handleAddToQueue}
                            disabled={!form.stockCode}
                        >
                            Âä†ÂÖ•ÈòüÂàó
                        </Button>
                    </div>
                    <div className="config-section">
                        <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', marginBottom: 8 }}>
                            <div className="config-section-title" style={{ marginBottom: 0 }}>ÈòüÂàó</div>
                            <Button size="small" onClick={syncQueueFromServer} loading={loadingQueue}>
                                Âà∑Êñ∞
                            </Button>
                        </div>
                        {loadingQueue ? (
                            <div style={{ padding: 24, textAlign: 'center' }}>
                                <Spin size="small" />
                            </div>
                        ) : queue.length === 0 ? (
                            <Empty description="ÊöÇÊó†ÂæÖÊâßË°å‰ªªÂä°" />
                        ) : (
                            <div style={{ display: 'flex', flexDirection: 'column', gap: 12 }}>
                                {queue.map(entry => {
                                    const summary = computeSummary(entry);
                                    const typeText = entry.filters.types.length > 0 ? entry.filters.types.join(', ') : 'ÂÖ®ÈÉ®';
                                    const statusColor = entry.status === 'completed'
                                        ? 'green'
                                        : entry.status === 'running'
                                            ? 'blue'
                                            : entry.status === 'failed'
                                                ? 'red'
                                                : 'default';
                                    const statusText = statusLabel[entry.status] || statusLabel.pending;
                                    const directionText = entry.filters.directions.length > 0
                                        ? entry.filters.directions.map(dir => (dir === 'sell' ? 'ÂçñÁÇπ' : '‰π∞ÁÇπ')).join(', ')
                                        : 'ÂÖ®ÈÉ®';
                                    const signalText = summary.status === 'ready'
                                        ? `‰ø°Âè∑Êï∞Ôºö${summary.signalCount}`
                                        : 'Á≠âÂæÖÂä†ËΩΩ';
                                    return (
                                        <div
                                            key={entry.id}
                                            style={{
                                                border: '1px solid #e5e5e5',
                                                borderRadius: 8,
                                                padding: 12,
                                                background: '#fafafa',
                                                display: 'flex',
                                                flexDirection: 'column',
                                                gap: 6,
                                            }}
                                        >
                                            <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                                                <div style={{ fontSize: 13, fontWeight: 600 }}>
                                                    {entry.stockCode} ¬∑ {LEVEL_OPTIONS.find(opt => opt.value === entry.level)?.label || entry.level}
                                                </div>
                                                <Space size="small">
                                                    <Tag color={statusColor}>{statusText}</Tag>
                                                    <Button
                                                        size="small"
                                                        onClick={() => handleRunEntry(entry)}
                                                        disabled={entry.status === 'running'}
                                                        loading={entry.status === 'running'}
                                                    >
                                                        ËøêË°å
                                                    </Button>
                                                    <Button
                                                        size="small"
                                                        onClick={() => handleRefreshEntry(entry)}
                                                        disabled={entry.status === 'running'}
                                                    >
                                                        Âà∑Êñ∞Êï∞ÊçÆ
                                                    </Button>
                                                    <Button
                                                        size="small"
                                                        onClick={() => openSignalInspector(entry, summary)}
                                                        disabled={!summary?.signals?.length}
                                                    >
                                                        ‰ø°Âè∑
                                                    </Button>
                                                    <Button size="small" danger onClick={() => removeEntry(entry.id)}>
                                                        Âà†Èô§
                                                    </Button>
                                                </Space>
                                            </div>
                                            <div style={{ fontSize: 12, color: '#666' }}>
                                                ÊñπÂêëÔºö{directionText} ÔΩú Á±ªÂûãÔºö{typeText}
                                            </div>
                                            <div style={{ fontSize: 12, color: '#555' }}>
                                                {signalText}
                                                {summary.sampleSignal && (
                                                    <span>
                                                        {' '}¬∑ ÊúÄËøëÔºö{dayjs(summary.sampleSignal.timestamp).format('MM-DD HH:mm')}
                                                    </span>
                                                )}
                                            </div>
                                            {summary.strength?.biStrength && (
                                                <div style={{ fontSize: 12, color: '#555' }}>
                                                    Á¨îÂäõÂ∫¶Ôºö{summary.strength.biStrength.hint || '‚Äî'}
                                                </div>
                                            )}
                                            {summary.strength?.segStrength && (
                                                <div style={{ fontSize: 12, color: '#555' }}>
                                                    ÊÆµÂäõÂ∫¶Ôºö{summary.strength.segStrength.hint || '‚Äî'}
                                                </div>
                                            )}
                                            {entry.lastRunAt && (
                                                <div style={{ fontSize: 11, color: '#888' }}>
                                                    ‰∏äÊ¨°ËøêË°åÔºö{dayjs(entry.lastRunAt).format('MM-DD HH:mm')}
                                                </div>
                                            )}
                                            {summary.resultInfo && (
                                                <div style={{ fontSize: 11, color: '#777' }}>
                                                    KÁ∫øÔºö{summary.resultInfo.klineCount ?? '--'} ÔΩú BIÔºö{summary.resultInfo.biCount ?? '--'} ÔΩú ÊÆµÔºö{summary.resultInfo.segCount ?? '--'} ÔΩú ‰ø°Âè∑Ôºö{summary.resultInfo.bspCount ?? '--'}
                                                </div>
                                            )}
                                            {entry.status === 'failed' && entry.errorMessage && (
                                                <div style={{ fontSize: 11, color: '#d4380d' }}>
                                                    ÈîôËØØÔºö{entry.errorMessage}
                                                </div>
                                            )}
                                        </div>
                                    );
                                })}
                            </div>
                        )}
                    </div>
                    <Drawer
                        width={520}
                        title="‰ø°Âè∑ËØ¶ÊÉÖ"
                        onClose={closeSignalInspector}
                        open={inspectorVisible}
                        destroyOnClose
                    >
                        {!inspectorData ? (
                            <div style={{ color: '#999' }}>ËØ∑ÈÄâÊã©‰ªªÂä°Êü•Áúã‰ø°Âè∑ËØ¶ÊÉÖ</div>
                        ) : (
                            <>
                                <div style={{ marginBottom: 12, fontSize: 12, color: '#555' }}>
                                    <div>ËÇ°Á•®Ôºö{inspectorData.entry.stockCode}</div>
                                    <div>Á∫ßÂà´Ôºö{LEVEL_OPTIONS.find(item => item.value === inspectorData.entry.level)?.label || inspectorData.entry.level}</div>
                                    <div>ÊñπÂêëÔºö{(inspectorData.entry.filters?.directions || []).map(dir => (dir === 'sell' ? 'ÂçñÁÇπ' : '‰π∞ÁÇπ')).join(' / ') || 'ÂÖ®ÈÉ®'}</div>
                                    <div>Á±ªÂûãÔºö{(inspectorData.entry.filters?.types || []).join('„ÄÅ') || 'ÂÖ®ÈÉ®'}</div>
                                </div>
                                {inspectorData.summary?.resultInfo && (
                                    <div style={{ marginBottom: 12, fontSize: 12, color: '#555' }}>
                                        <div>ÁªüËÆ°ÔºöKÁ∫ø {inspectorData.summary.resultInfo.klineCount ?? '--'} ÔΩú BI {inspectorData.summary.resultInfo.biCount ?? '--'} ÔΩú ÊÆµ {inspectorData.summary.resultInfo.segCount ?? '--'} ÔΩú ‰ø°Âè∑ {inspectorData.summary.resultInfo.bspCount ?? '--'}</div>
                                    </div>
                                )}
                                <Table
                                    size="small"
                                    pagination={{ pageSize: 10 }}
                                    columns={[
                                        { title: 'Â∫èÂè∑', dataIndex: 'index', width: 60 },
                                        { title: 'Êó∂Èó¥', dataIndex: 'time', width: 160 },
                                        { title: 'ÊñπÂêë', dataIndex: 'direction', width: 80 },
                                        { title: 'Á±ªÂûã', dataIndex: 'type' },
                                        { title: '‰ª∑Ê†º', dataIndex: 'price', width: 100 },
                                    ]}
                                    dataSource={(inspectorData.summary?.signals || []).map((signal, idx) => {
                                        const priceValue = Number(signal.price);
                                        return {
                                            key: `${signal.timestamp || idx}-${idx}`,
                                            index: idx + 1,
                                            time: signal.timestamp ? dayjs(signal.timestamp).format('YYYY-MM-DD HH:mm') : (signal.time || '--'),
                                            direction: signal.is_buy ? '‰π∞ÁÇπ' : 'ÂçñÁÇπ',
                                            type: SignalUtils.normalizeBspType(signal.typeKey || signal.type),
                                            price: Number.isFinite(priceValue) ? priceValue.toFixed(3) : (signal.price ?? '--'),
                                        };
                                    })}
                                    scroll={{ y: 360 }}
                                />
                            </>
                        )}
                    </Drawer>
                </div>
            );
        });

        // ============= Indicator Config Component =============
        const IndicatorConfig = memo(() => {
            const { indicators, setIndicators, refreshAllCharts } = useApp();
            const [timeRange, setTimeRange] = useState('1y');
            const [customRange, setCustomRange] = useState(() => {
                if (indicators.begin_time || indicators.end_time) {
                    return [indicators.begin_time || null, indicators.end_time || null];
                }
                return [null, null];
            });
            const { RangePicker } = DatePicker;
            const [limitCount, setLimitCount] = useState(indicators.limit_kl_count || null);
            const [profileName, setProfileName] = useState('');
            const [customProfiles, setCustomProfiles] = useState(() => {
                if (typeof window === 'undefined') {
                    return [];
                }
                try {
                    const stored = localStorage.getItem(INDICATOR_PROFILE_STORAGE_KEY);
                    const parsed = stored ? JSON.parse(stored) : [];
                    return Array.isArray(parsed) ? parsed : [];
                } catch (err) {
                    debugError('Failed to load indicator profiles:', err);
                    return [];
                }
            });
            const persistProfiles = useCallback((updater) => {
                setCustomProfiles(prev => {
                    const next = typeof updater === 'function' ? updater(prev) : updater;
                    const normalized = Array.isArray(next) ? next : [];
                    if (typeof window !== 'undefined') {
                        try {
                            localStorage.setItem(INDICATOR_PROFILE_STORAGE_KEY, JSON.stringify(normalized));
                        } catch (err) {
                            debugError('Failed to save indicator profiles:', err);
                        }
                    }
                    return normalized;
                });
            }, []);

            useEffect(() => {
                setLimitCount(indicators.limit_kl_count || null);
            }, [indicators.limit_kl_count]);

            const PRESET_INDICATORS = [
                {
                    key: 'standard',
                    name: 'Ê†áÂáÜ',
                    description: 'Â±ïÁ§∫Á¨î/Á∫øÊÆµ/‰π∞ÂçñÁÇπ + MACD + 5/10/20/60 ÂùáÁ∫ø',
                    apply: () => {
                        setIndicators(prev => ({
                            ...prev,
                            plot_bi: true,
                            plot_seg: true,
                            plot_zs: true,
                            plot_bsp: true,
                            plot_macd: true,
                            plot_volume: true,
                            plot_kdj: false,
                            plot_rsi: false,
                            plot_boll: false,
                            plot_ma: true,
                            ma_params: [5, 10, 20, 60],
                        }));
                    }
                },
                {
                    key: 'trend',
                    name: 'Ë∂ãÂäø',
                    description: 'Âè™ÁúãKÁ∫ø + ÂùáÁ∫øÔºå‰∏éMACD, KDJ ËæÖÂä©',
                    apply: () => {
                        setIndicators(prev => ({
                            ...prev,
                            plot_bi: false,
                            plot_seg: false,
                            plot_zs: false,
                            plot_bsp: false,
                            plot_macd: true,
                            plot_kdj: true,
                            plot_rsi: false,
                            plot_boll: false,
                            plot_volume: true,
                            plot_ma: true,
                            ma_params: [20, 60, 120],
                        }));
                    }
                },
                {
                    key: 'minimal',
                    name: 'ÁÆÄÊ¥Å',
                    description: 'Âè™ÊòæÁ§∫KÁ∫ø„ÄÅÁ¨îÂíå‰π∞ÂçñÁÇπ',
                    apply: () => {
                        setIndicators(prev => ({
                            ...prev,
                            plot_bi: true,
                            plot_seg: false,
                            plot_zs: false,
                            plot_bsp: true,
                            plot_macd: false,
                            plot_kdj: false,
                            plot_rsi: false,
                            plot_boll: false,
                            plot_volume: false,
                            plot_ma: false,
                        }));
                    }
                }
            ];

            const handleChange = (key, value) => {
                if (key === 'ma_params') {
                    const sanitized = (value || [])
                        .map(Number)
                        .filter(val => Number.isFinite(val) && val > 0)
                        .slice(0, 6)
                        .sort((a, b) => a - b);
                    setIndicators(prev => ({ ...prev, ma_params: sanitized }));
                    return;
                }
                setIndicators(prev => ({ ...prev, [key]: value }));
            };

            const handleSaveProfile = useCallback(() => {
                const name = profileName.trim();
                if (!name) {
                    message.warning('ËØ∑ËæìÂÖ•Ê®°ÊùøÂêçÁß∞');
                    return;
                }
                let snapshot = {};
                try {
                    snapshot = JSON.parse(JSON.stringify(indicators));
                } catch (err) {
                    snapshot = { ...indicators };
                }
                persistProfiles(prev => {
                    const filtered = prev.filter(profile => profile.name !== name);
                    return [
                        ...filtered,
                        {
                            id: Date.now(),
                            name,
                            config: snapshot,
                        },
                    ];
                });
                message.success(`Â∑≤‰øùÂ≠òÊ®°Êùø„Äå${name}„Äç`);
                setProfileName('');
            }, [indicators, persistProfiles, profileName]);

            const handleApplyProfile = useCallback((profile) => {
                if (!profile || !profile.config) {
                    return;
                }
                setIndicators(prev => ({ ...prev, ...profile.config }));
                message.success(`Â∑≤Â∫îÁî®Ê®°Êùø„Äå${profile.name}„Äç`);
            }, [setIndicators]);

            const handleDeleteProfile = useCallback((id) => {
                persistProfiles(prev => prev.filter(profile => profile.id !== id));
                message.success('Â∑≤Âà†Èô§Ê®°Êùø');
            }, [persistProfiles]);

            const handleTimeRangeChange = (range) => {
                setTimeRange(range);
                const now = new Date();
                let beginTime;
                
                switch(range) {
                    case '1m': beginTime = new Date(now.setMonth(now.getMonth() - 1)); break;
                    case '3m': beginTime = new Date(now.setMonth(now.getMonth() - 3)); break;
                    case '6m': beginTime = new Date(now.setMonth(now.getMonth() - 6)); break;
                    case '1y': beginTime = new Date(now.setFullYear(now.getFullYear() - 1)); break;
                    case '3y': beginTime = new Date(now.setFullYear(now.getFullYear() - 3)); break;
                    case 'all': beginTime = new Date('2020-01-01'); break;
                    case 'custom':
                        setTimeRange('custom');
                        return;
                    default: beginTime = new Date(now.setFullYear(now.getFullYear() - 1));
                }
                
                handleChange('begin_time', beginTime.toISOString().split('T')[0]);
                handleChange('end_time', null);
                setCustomRange([beginTime.toISOString().split('T')[0], null]);
                setTimeout(() => refreshAllCharts(), 100);
            };
            const applyCustomRange = () => {
                const [start, end] = customRange || [];
                if (start) {
                    handleChange('begin_time', start);
                }
                if (end) {
                    handleChange('end_time', end);
                } else {
                    handleChange('end_time', null);
                }
                setTimeRange('custom');
                setTimeout(() => refreshAllCharts(), 100);
            };

            const clearLimitCount = () => {
                setLimitCount(null);
                handleChange('limit_kl_count', null);
                message.success('Â∑≤ÂèñÊ∂àKÁ∫øÊï∞ÈáèÈôêÂà∂');
                setTimeout(() => refreshAllCharts(), 100);
            };

            const applyLimitCount = () => {
                if (limitCount === null || limitCount === undefined || limitCount === '') {
                    clearLimitCount();
                    return;
                }
                const numeric = Number(limitCount);
                if (!Number.isFinite(numeric)) {
                    message.warning('ËØ∑ËæìÂÖ•ÊúâÊïàÁöÑKÁ∫øÊï∞Èáè');
                    return;
                }
                const sanitized = Math.min(5000, Math.max(10, Math.round(numeric)));
                handleChange('limit_kl_count', sanitized);
                setLimitCount(sanitized);
                message.success(`Â∑≤ÈôêÂà∂Â±ïÁ§∫ÊúÄËøë ${sanitized} Ê†πKÁ∫ø`);
                setTimeout(() => refreshAllCharts(), 100);
            };

            const ColorPicker = ({ value, onChange }) => (
                <input
                    type="color"
                    value={value}
                    onChange={e => onChange(e.target.value)}
                    style={{ width: 32, height: 20, border: 'none', background: 'transparent', padding: 0 }}
                />
            );

            return (
                <div>
                    <div style={{ marginBottom: 16, padding: 12, background: '#f5f5f5', borderRadius: 8 }}>
                        <div style={{ marginBottom: 8, fontWeight: 600, fontSize: 13 }}>Êó∂Èó¥ËåÉÂõ¥</div>
                        <Space direction="vertical" size={8} style={{ width: '100%' }}>
                            <Radio.Group 
                                value={timeRange} 
                                onChange={e => handleTimeRangeChange(e.target.value)}
                                size="small"
                                buttonStyle="solid"
                            >
                                <Radio.Button value="1m">Ëøë1Êúà</Radio.Button>
                                <Radio.Button value="3m">Ëøë3Êúà</Radio.Button>
                                <Radio.Button value="6m">Ëøë6Êúà</Radio.Button>
                                <Radio.Button value="1y">Ëøë1Âπ¥</Radio.Button>
                                <Radio.Button value="3y">Ëøë3Âπ¥</Radio.Button>
                                <Radio.Button value="all">ÂÖ®ÈÉ®</Radio.Button>
                                <Radio.Button value="custom">Ëá™ÂÆö‰πâ</Radio.Button>
                            </Radio.Group>
                            <Space size="small" wrap>
                                <RangePicker
                                    size="small"
                                    value={(customRange || []).map(v => v ? dayjs(v) : null)}
                                    onChange={(dates, dateStrings) => {
                                        setCustomRange(dateStrings);
                                    }}
                                    allowEmpty={[true, true]}
                                    placeholder={['ÂºÄÂßãÊó•Êúü', 'ÁªìÊùüÊó•Êúü']}
                                />
                                <Button size="small" onClick={applyCustomRange}>Â∫îÁî®</Button>
                            </Space>
                            <Space size="small" align="center" wrap>
                                <span style={{ fontSize: 12, color: '#888' }}>KÁ∫øÊï∞Èáè‰∏äÈôê</span>
                                <InputNumber
                                    size="small"
                                    min={10}
                                    max={5000}
                                    step={50}
                                    style={{ width: 110 }}
                                    value={limitCount}
                                    placeholder="‰∏çÈôê"
                                    onChange={value => {
                                        if (value === null || value === undefined || value === '') {
                                            setLimitCount(null);
                                        } else {
                                            setLimitCount(Number(value));
                                        }
                                    }}
                                />
                                <Button size="small" type="primary" onClick={applyLimitCount}>Â∫îÁî®</Button>
                                <Button size="small" onClick={clearLimitCount} disabled={limitCount === null}>
                                    Ê∏ÖÈô§
                                </Button>
                            </Space>
                            <div style={{ fontSize: 11, color: '#999' }}>
                                Â∞ÜÊï∞ÈáèÈôêÂà∂ËÆæ‰∏∫ N Êó∂Ôºå‰ªÖÂä†ËΩΩÊúÄËøë N Ê†πKÁ∫øÂèäÂØπÂ∫îÁöÑÁ¨î/Á∫øÊÆµ/‰∏≠Êû¢‰∏éÊåáÊ†áÊï∞ÊçÆÔºå‰æø‰∫éËÅöÁÑ¶ÂΩìÂâçËµ∞Âäø„ÄÇ
                            </div>
                        </Space>
                    </div>

                    <div className="indicator-section">
                        <div className="indicator-section-title">Áº†ËÆ∫ÊåáÊ†á</div>
                        <div className="indicator-item">
                            <Checkbox checked={indicators.plot_bi} onChange={e => handleChange('plot_bi', e.target.checked)}>
                                Á¨î (Bi)
                            </Checkbox>
                        </div>
                        <div className="indicator-item">
                            <Checkbox checked={indicators.plot_seg} onChange={e => handleChange('plot_seg', e.target.checked)}>
                                Á∫øÊÆµ (Seg)
                            </Checkbox>
                        </div>
                        <div className="indicator-item">
                            <Checkbox checked={indicators.plot_zs} onChange={e => handleChange('plot_zs', e.target.checked)}>
                                ‰∏≠Êû¢ (ZS)
                            </Checkbox>
                        </div>
                        <div className="indicator-item">
                            <Checkbox checked={indicators.plot_bsp} onChange={e => handleChange('plot_bsp', e.target.checked)}>
                                ‰π∞ÂçñÁÇπ (BSP)
                            </Checkbox>
                        </div>
                        <div className="indicator-item">
                            <Checkbox checked={indicators.highlight_chan_kline} onChange={e => handleChange('highlight_chan_kline', e.target.checked)}>
                                Áº†ËÆ∫KÁ∫øËôöÁ∫øÂúà
                            </Checkbox>
                        </div>
                        {indicators.highlight_chan_kline && (
                            <div className="indicator-item" style={{ display: 'flex', alignItems: 'center', gap: 8 }}>
                                <span>ÂúàÂÆöÈ¢úËâ≤</span>
                                <input
                                    type="color"
                                    value={indicators.chan_kline_color || '#FF9800'}
                                    onChange={e => handleChange('chan_kline_color', e.target.value)}
                                    style={{ width: 36, height: 20, border: 'none', background: 'transparent', padding: 0, cursor: 'pointer' }}
                                />
                            </div>
                        )}
                    </div>

                    <div className="indicator-section">
                        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'baseline', marginBottom: 8 }}>
                            <div className="indicator-section-title" style={{ marginBottom: 0 }}>Áº†ËÆ∫Ê†∑Âºè</div>
                            <Popover
                                placement="bottomRight"
                                trigger="click"
                                content={
                                    <Space direction="vertical" style={{ maxWidth: 260 }}>
                                        {PRESET_INDICATORS.map(preset => (
                                            <Button
                                                key={preset.key}
                                                block
                                                size="small"
                                                onClick={() => preset.apply()}
                                            >
                                                {preset.name}
                                                <div style={{ fontSize: 11, color: '#888' }}>{preset.description}</div>
                                            </Button>
                                        ))}
                                    </Space>
                                }
                            >
                                <Button size="small" type="link">È¢ÑËÆæ</Button>
                            </Popover>
                        </div>
                        <div className="indicator-item" style={{ display: 'flex', flexDirection: 'column', gap: 8 }}>
                            <div style={{ fontWeight: 500 }}>Á¨îÊ†∑Âºè</div>
                            <Space size="small" wrap>
                                <span>È¢úËâ≤</span>
                                <ColorPicker value={indicators.bi_color} onChange={value => handleChange('bi_color', value)} />
                                <span>Á∫øÂûã</span>
                                <Select
                                    size="small"
                                    value={indicators.bi_line_style}
                                    style={{ width: 90 }}
                                    onChange={value => handleChange('bi_line_style', value)}
                                    options={LINE_STYLE_OPTIONS}
                                />
                                <span>Á∫øÂÆΩ</span>
                                <InputNumber
                                    min={1}
                                    max={6}
                                    size="small"
                                    value={indicators.bi_line_width}
                                    onChange={value => handleChange('bi_line_width', value || 1)}
                                />
                            </Space>
                        </div>
                        <div className="indicator-item" style={{ display: 'flex', flexDirection: 'column', gap: 8, marginTop: 12 }}>
                            <div style={{ fontWeight: 500 }}>Á∫øÊÆµÊ†∑Âºè</div>
                            <Space size="small" wrap>
                                <span>È¢úËâ≤</span>
                                <ColorPicker value={indicators.seg_color} onChange={value => handleChange('seg_color', value)} />
                                <span>Á∫øÂûã</span>
                                <Select
                                    size="small"
                                    value={indicators.seg_line_style}
                                    style={{ width: 90 }}
                                    onChange={value => handleChange('seg_line_style', value)}
                                    options={LINE_STYLE_OPTIONS}
                                />
                                <span>Á∫øÂÆΩ</span>
                                <InputNumber
                                    min={1}
                                    max={8}
                                    size="small"
                                    value={indicators.seg_line_width}
                                    onChange={value => handleChange('seg_line_width', value || 1)}
                                />
                            </Space>
                        </div>
                        <div className="indicator-item" style={{ display: 'flex', flexDirection: 'column', gap: 8, marginTop: 12 }}>
                            <div style={{ fontWeight: 500 }}>‰∏≠Êû¢Ê†∑Âºè</div>
                            <Space size="small" wrap>
                                <span>Êù•Ê∫ê</span>
                                <Select
                                    size="small"
                                    value={indicators.zs_source || 'bi'}
                                    style={{ width: 120 }}
                                    onChange={value => handleChange('zs_source', value)}
                                    options={[
                                        { value: 'bi', label: 'Á¨î‰∏≠Êû¢' },
                                        { value: 'seg', label: 'Á∫øÊÆµ‰∏≠Êû¢' },
                                        { value: 'both', label: 'ÂÖ®ÈÉ®' },
                                    ]}
                                />
                            </Space>
                            <Space size="small" wrap>
                                <span>Â°´ÂÖÖËâ≤</span>
                                <ColorPicker value={indicators.zs_fill_color} onChange={value => handleChange('zs_fill_color', value)} />
                                <span>ÈÄèÊòéÂ∫¶</span>
                                <Slider
                                    min={0}
                                    max={100}
                                    step={5}
                                    value={Math.round((indicators.zs_fill_opacity || 0) * 100)}
                                    onChange={value => handleChange('zs_fill_opacity', value / 100)}
                                    style={{ width: 120 }}
                                />
                            </Space>
                            <Space size="small" wrap>
                                <span>ËæπÊ°ÜËâ≤</span>
                                <ColorPicker value={indicators.zs_border_color} onChange={value => handleChange('zs_border_color', value)} />
                                <span>ËæπÊ°ÜÁ∫øÂûã</span>
                                <Select
                                    size="small"
                                    value={indicators.zs_border_style}
                                    style={{ width: 90 }}
                                    onChange={value => handleChange('zs_border_style', value)}
                                    options={LINE_STYLE_OPTIONS}
                                />
                                <span>ËæπÊ°ÜÂÆΩÂ∫¶</span>
                                <InputNumber
                                    min={1}
                                    max={4}
                                    size="small"
                                    value={indicators.zs_border_size}
                                    onChange={value => handleChange('zs_border_size', value || 1)}
                                />
                            </Space>
                            <Space size="small" wrap>
                                <Checkbox
                                    checked={indicators.zs_show_label}
                                    onChange={e => handleChange('zs_show_label', e.target.checked)}
                                >
                                    ÊòæÁ§∫‰∏≠Êû¢Á∫ßÂà´
                                </Checkbox>
                                {indicators.zs_show_label && (
                                    <>
                                        <span>ÊñáÂ≠óÈ¢úËâ≤</span>
                                        <ColorPicker value={indicators.zs_label_color} onChange={value => handleChange('zs_label_color', value)} />
                                    </>
                                )}
                            </Space>
                        </div>
                    </div>

                    <div className="indicator-section">
                        <div className="indicator-section-title">ÊäÄÊúØÊåáÊ†á</div>
                        <div className="indicator-item">
                            <Checkbox checked={indicators.plot_volume} onChange={e => handleChange('plot_volume', e.target.checked)}>
                                Êàê‰∫§Èáè (Volume)
                            </Checkbox>
                        </div>
                        <div className="indicator-item">
                            <Checkbox checked={indicators.plot_ma} onChange={e => handleChange('plot_ma', e.target.checked)}>
                                ÁßªÂä®Âπ≥ÂùáÁ∫ø (MA)
                            </Checkbox>
                            {indicators.plot_ma && (
                                <div style={{ marginTop: 8, paddingLeft: 16 }}>
                                    <Select
                                        mode="multiple"
                                        allowClear
                                        size="small"
                                        style={{ width: '100%' }}
                                        placeholder="ÈÄâÊã©Ë¶ÅÊòæÁ§∫ÁöÑMAÂë®Êúü"
                                        value={(indicators.ma_params || []).map(String)}
                                        onChange={values => handleChange('ma_params', values)}
                                        options={MA_OPTIONS.map(option => ({ value: String(option), label: `${option}` }))}
                                    />
                                </div>
                            )}
                        </div>
                        <div className="indicator-item">
                            <Checkbox checked={indicators.plot_macd} onChange={e => handleChange('plot_macd', e.target.checked)}>
                                MACD
                            </Checkbox>
                        </div>
                        <div className="indicator-item">
                            <Checkbox checked={indicators.plot_boll} onChange={e => handleChange('plot_boll', e.target.checked)}>
                                Â∏ÉÊûóÂ∏¶ (BOLL)
                            </Checkbox>
                        </div>
                        <div className="indicator-item">
                            <Checkbox checked={indicators.plot_kdj} onChange={e => handleChange('plot_kdj', e.target.checked)}>
                                KDJ
                            </Checkbox>
                        </div>
                        <div className="indicator-item">
                            <Checkbox checked={indicators.plot_rsi} onChange={e => handleChange('plot_rsi', e.target.checked)}>
                                RSI
                            </Checkbox>
                        </div>
                    </div>

                    <div className="indicator-section">
                        <div className="indicator-section-title">ÊåáÊ†áÊ®°Êùø</div>
                        <div className="indicator-item" style={{ display: 'flex', flexWrap: 'wrap', gap: 8 }}>
                            <Input
                                size="small"
                                placeholder="ËæìÂÖ•Ê®°ÊùøÂêçÁß∞"
                                value={profileName}
                                onChange={e => setProfileName(e.target.value)}
                                style={{ flex: '1 1 140px', minWidth: 140 }}
                            />
                            <Button size="small" type="primary" onClick={handleSaveProfile}>
                                ‰øùÂ≠òÂΩìÂâçËÆæÁΩÆ
                            </Button>
                        </div>
                        <div className="indicator-item" style={{ display: 'flex', flexDirection: 'column', gap: 8 }}>
                            {customProfiles.length === 0 ? (
                                <div className="chart-info-placeholder" style={{ margin: 0 }}>
                                    ÊöÇÊó†Ëá™ÂÆö‰πâÊ®°ÊùøÔºå‰øùÂ≠òÂêéÂèØ‰∏ÄÈîÆÂàáÊç¢
                                </div>
                            ) : (
                                customProfiles.map(profile => (
                                    <div
                                        key={profile.id}
                                        style={{
                                            display: 'flex',
                                            justifyContent: 'space-between',
                                            alignItems: 'center',
                                            padding: '6px 10px',
                                            border: '1px solid #f0f0f0',
                                            borderRadius: 6,
                                            background: '#fafafa',
                                        }}
                                    >
                                        <span style={{ fontWeight: 500 }}>{profile.name}</span>
                                        <Space size={4}>
                                            <Button size="small" type="link" onClick={() => handleApplyProfile(profile)}>
                                                Â∫îÁî®
                                            </Button>
                                            <Button size="small" type="link" danger onClick={() => handleDeleteProfile(profile.id)}>
                                                Âà†Èô§
                                            </Button>
                                        </Space>
                                    </div>
                                ))
                            )}
                        </div>
                    </div>

                    <div className="indicator-section">
                        <div className="indicator-section-title">ÊåáÊ†áÂ∏ÉÂ±Ä</div>
                        <div className="indicator-item" style={{ marginBottom: 12 }}>
                            <Radio.Group
                                size="small"
                                value={indicators.indicator_layout || 'stack'}
                                onChange={e => handleChange('indicator_layout', e.target.value)}
                                buttonStyle="solid"
                            >
                                <Radio.Button value="stack">Â†ÜÂè†</Radio.Button>
                                <Radio.Button value="tab">ÂçïÁ™óÂè£ÂàáÊç¢</Radio.Button>
                            </Radio.Group>
                        </div>
                        {indicators.indicator_layout === 'tab' && LOWER_INDICATOR_KEYS.some(key => indicators[`plot_${key}`]) && (
                            <div className="indicator-item" style={{ display: 'flex', flexDirection: 'column', gap: 8 }}>
                                <span style={{ fontSize: 12, color: '#888' }}>ÈªòËÆ§Â±ïÁ§∫ÁöÑÊåáÊ†á</span>
                                <Select
                                    size="small"
                                    value={indicators.indicator_tab}
                                    onChange={value => handleChange('indicator_tab', value)}
                                    options={LOWER_INDICATOR_KEYS.filter(key => indicators[`plot_${key}`]).map(key => ({
                                        value: key,
                                        label: key === 'macd' ? 'MACD' : key.toUpperCase(),
                                    }))}
                                />
                            </div>
                        )}
                    </div>
                </div>
            );
        });

        const ChanConfigPanel = memo(() => {
            const { chanConfig, setChanConfig } = useApp();
            const [jsonModalVisible, setJsonModalVisible] = useState(false);
            const [jsonEditorValue, setJsonEditorValue] = useState('');
            const [jsonParseError, setJsonParseError] = useState(null);
            const [structureView, setStructureView] = useState('bi');

            const mergeConfig = useCallback((patch) => {
                setChanConfig(prev => ({ ...prev, ...patch }));
            }, [setChanConfig]);

            const handleBoolean = useCallback((key) => (e) => {
                mergeConfig({ [key]: e.target.checked });
            }, [mergeConfig]);

            const handleNumber = useCallback((key) => (value) => {
                if (value === null || value === undefined) {
                    return;
                }
                const numeric = Number(value);
                if (Number.isFinite(numeric)) {
                    mergeConfig({ [key]: numeric });
                }
            }, [mergeConfig]);

            const handleSelect = useCallback((key) => (value) => {
                mergeConfig({ [key]: value });
            }, [mergeConfig]);

            const handleMacdChange = useCallback((field) => (value) => {
                if (value === null || value === undefined) return;
                const numeric = Number(value);
                if (!Number.isFinite(numeric)) return;
                setChanConfig(prev => ({
                    ...prev,
                    macd: {
                        ...prev.macd,
                        [field]: numeric,
                    },
                }));
            }, [setChanConfig]);

            const handleDemarkChange = useCallback((field) => (value) => {
                if (value === null || value === undefined) return;
                const numeric = Number(value);
                if (!Number.isFinite(numeric)) return;
                setChanConfig(prev => ({
                    ...prev,
                    demark: {
                        ...prev.demark,
                        [field]: numeric,
                    },
                }));
            }, [setChanConfig]);

            const handleDemarkToggle = useCallback((field) => (e) => {
                setChanConfig(prev => ({
                    ...prev,
                    demark: {
                        ...prev.demark,
                        [field]: e.target.checked,
                    },
                }));
            }, [setChanConfig]);

            const handleMeanMetricsChange = useCallback((values) => {
                const sanitized = Array.from(new Set((values || []).map(v => Number(v)).filter(Number.isFinite))).sort((a, b) => a - b);
                mergeConfig({ mean_metrics: sanitized });
            }, [mergeConfig]);

            const handleTrendMetricsChange = useCallback((values) => {
                const sanitized = Array.from(new Set((values || []).map(v => Number(v)).filter(Number.isFinite))).sort((a, b) => a - b);
                mergeConfig({ trend_metrics: sanitized });
            }, [mergeConfig]);

            const resetAllToDefault = useCallback(() => {
                setChanConfig(() => ({
                    ...DEFAULT_CHAN_CONFIG,
                    mean_metrics: [...(DEFAULT_CHAN_CONFIG.mean_metrics || [])],
                    trend_metrics: [...(DEFAULT_CHAN_CONFIG.trend_metrics || [])],
                    macd: { ...DEFAULT_CHAN_CONFIG.macd },
                    demark: { ...DEFAULT_CHAN_CONFIG.demark },
                }));
                message.success('Â∑≤ÊÅ¢Â§çÂÖ®ÈÉ®Áº†ËÆ∫ÈÖçÁΩÆÈªòËÆ§ÂÄº');
            }, [setChanConfig]);
            const resetCoreConfig = useCallback(() => {
                setChanConfig(prev => ({
                    ...prev,
                    ...CORE_CHAN_DEFAULTS,
                }));
                message.success('Â∑≤ÊÅ¢Â§çÊ†∏ÂøÉÁÆóÊ≥ïÈªòËÆ§ÂÄº');
            }, [setChanConfig]);

            const defaultBsTypeArray = useMemo(() => {
                if (typeof DEFAULT_CHAN_CONFIG.bs_type === 'string') {
                    return DEFAULT_CHAN_CONFIG.bs_type
                        .split(',')
                        .map(item => item.trim())
                        .filter(Boolean);
                }
                if (Array.isArray(DEFAULT_CHAN_CONFIG.bs_type)) {
                    return DEFAULT_CHAN_CONFIG.bs_type.filter(Boolean);
                }
                return [];
            }, []);

            const bsTypeOptions = useMemo(() => ([
                { label: 'T1', value: '1' },
                { label: 'T1P', value: '1p' },
                { label: 'T2', value: '2' },
                { label: 'T2S', value: '2s' },
                { label: 'T3A', value: '3a' },
                { label: 'T3B', value: '3b' },
            ]), []);

            const handleBsTypeChange = useCallback((values) => {
                mergeConfig({ bs_type: Array.isArray(values) ? values.join(',') : '' });
            }, [mergeConfig]);

            const bsTypeSelection = useMemo(() => {
                const raw = chanConfig.bs_type;
                if (typeof raw === 'string' && raw.trim().length > 0) {
                    const parsed = raw.split(',').map(item => item.trim()).filter(Boolean);
                    return parsed.length > 0 ? parsed : defaultBsTypeArray;
                }
                return defaultBsTypeArray;
            }, [chanConfig.bs_type, defaultBsTypeArray]);

            const configJson = useMemo(() => JSON.stringify(chanConfig, null, 2), [chanConfig]);
            const openJsonModal = useCallback(() => {
                setJsonEditorValue(JSON.stringify(chanConfig, null, 2));
                setJsonParseError(null);
                setJsonModalVisible(true);
            }, [chanConfig]);
            const closeJsonModal = useCallback(() => {
                setJsonModalVisible(false);
                setJsonParseError(null);
            }, []);
            const handleCopyJson = useCallback(() => {
                const copyText = async () => {
                    if (navigator?.clipboard?.writeText) {
                        await navigator.clipboard.writeText(jsonEditorValue || configJson);
                        message.success('Â∑≤Â§çÂà∂Âà∞Ââ™Ë¥¥Êùø');
                    } else {
                        throw new Error('clipboard api unavailable');
                    }
                };
                copyText().catch(() => {
                    try {
                        const textarea = document.createElement('textarea');
                        textarea.value = jsonEditorValue || configJson;
                        textarea.style.position = 'fixed';
                        textarea.style.opacity = '0';
                        document.body.appendChild(textarea);
                        textarea.focus();
                        textarea.select();
                        const succeeded = document.execCommand('copy');
                        document.body.removeChild(textarea);
                        if (succeeded) {
                            message.success('Â∑≤Â§çÂà∂Âà∞Ââ™Ë¥¥Êùø');
                            return;
                        }
                    } catch (err) {
                        // ignore
                    }
                    message.warning('Â§çÂà∂Â§±Ë¥•ÔºåËØ∑ÊâãÂä®ÈÄâ‰∏≠ÂÜÖÂÆπÂ§çÂà∂');
                });
            }, [configJson, jsonEditorValue]);
            const handleJsonChange = useCallback((event) => {
                setJsonEditorValue(event.target.value);
                setJsonParseError(null);
            }, []);
            const handleJsonApply = useCallback(() => {
                try {
                    const parsed = JSON.parse(jsonEditorValue || '{}');
                    if (!parsed || typeof parsed !== 'object' || Array.isArray(parsed)) {
                        throw new Error('ÈÖçÁΩÆÂøÖÈ°ªÊòØÂØπË±°');
                    }
                    setChanConfig(() => parsed);
                    message.success('Â∑≤Â∫îÁî®JSONÈÖçÁΩÆ');
                    setJsonParseError(null);
                } catch (err) {
                    const detail = err instanceof Error ? err.message : String(err);
                    setJsonParseError(detail);
                    message.error(`Ëß£ÊûêÂ§±Ë¥•Ôºö${detail}`);
                }
            }, [jsonEditorValue, setChanConfig]);

            const effectiveDivergenceRate = Number.isFinite(chanConfig.divergence_rate)
                ? chanConfig.divergence_rate
                : (Number.isFinite(DEFAULT_CHAN_CONFIG.divergence_rate) ? DEFAULT_CHAN_CONFIG.divergence_rate : Number.POSITIVE_INFINITY);
            const effectiveMinZsCnt = chanConfig.min_zs_cnt ?? DEFAULT_CHAN_CONFIG.min_zs_cnt ?? 0;
            const effectiveBsp1OnlyMultiBiZs = (chanConfig.bsp1_only_multibi_zs ?? DEFAULT_CHAN_CONFIG.bsp1_only_multibi_zs) ?? false;
            const effectiveBs1Peak = (chanConfig.bs1_peak ?? DEFAULT_CHAN_CONFIG.bs1_peak) ?? false;
            const effectiveBsp2Follow1 = (chanConfig.bsp2_follow_1 ?? DEFAULT_CHAN_CONFIG.bsp2_follow_1) ?? false;
            const effectiveBsp3Follow1 = (chanConfig.bsp3_follow_1 ?? DEFAULT_CHAN_CONFIG.bsp3_follow_1) ?? false;
            const effectiveBsp3Peak = (chanConfig.bsp3_peak ?? DEFAULT_CHAN_CONFIG.bsp3_peak) ?? false;
            const effectiveBsp2sFollow2 = (chanConfig.bsp2s_follow_2 ?? DEFAULT_CHAN_CONFIG.bsp2s_follow_2) ?? false;
            const effectiveStrictBsp3 = (chanConfig.strict_bsp3 ?? DEFAULT_CHAN_CONFIG.strict_bsp3) ?? false;
            const effectiveMaxBs2Rate = chanConfig.max_bs2_rate ?? DEFAULT_CHAN_CONFIG.max_bs2_rate;
            const effectiveMaxBsp2sLv = chanConfig.max_bsp2s_lv ?? DEFAULT_CHAN_CONFIG.max_bsp2s_lv;
            const effectiveMacdAlgo = chanConfig.macd_algo || DEFAULT_CHAN_CONFIG.macd_algo || 'peak';
            const effectiveBiAlgo = chanConfig.bi_algo || DEFAULT_CHAN_CONFIG.bi_algo || 'normal';
            const effectiveBiStrict = (chanConfig.bi_strict ?? DEFAULT_CHAN_CONFIG.bi_strict) ?? false ? true : false;
            const effectiveBiFxCheck = chanConfig.bi_fx_check || DEFAULT_CHAN_CONFIG.bi_fx_check || 'strict';
            const effectiveGapAsKl = (chanConfig.gap_as_kl ?? DEFAULT_CHAN_CONFIG.gap_as_kl) ?? false;
            const effectiveBiEndIsPeak = (chanConfig.bi_end_is_peak ?? DEFAULT_CHAN_CONFIG.bi_end_is_peak) ?? false;
            const effectiveBiAllowSubPeak = (chanConfig.bi_allow_sub_peak ?? DEFAULT_CHAN_CONFIG.bi_allow_sub_peak) ?? false;
            const effectiveSegAlgo = chanConfig.seg_algo || DEFAULT_CHAN_CONFIG.seg_algo || 'chan';
            const effectiveLeftSegMethod = chanConfig.left_seg_method || DEFAULT_CHAN_CONFIG.left_seg_method || 'peak';
            const effectiveZsCombine = (chanConfig.zs_combine ?? DEFAULT_CHAN_CONFIG.zs_combine) ?? false;
            const effectiveZsCombineMode = chanConfig.zs_combine_mode || DEFAULT_CHAN_CONFIG.zs_combine_mode || 'zs';
            const effectiveOneBiZs = (chanConfig.one_bi_zs ?? DEFAULT_CHAN_CONFIG.one_bi_zs) ?? false;
            const effectiveZsAlgo = chanConfig.zs_algo || DEFAULT_CHAN_CONFIG.zs_algo || 'normal';
            const effectiveTriggerStep = (chanConfig.trigger_step ?? DEFAULT_CHAN_CONFIG.trigger_step) ?? false;
            const effectiveSkipStep = chanConfig.skip_step ?? DEFAULT_CHAN_CONFIG.skip_step ?? 0;
            const effectiveKlDataCheck = (chanConfig.kl_data_check ?? DEFAULT_CHAN_CONFIG.kl_data_check) ?? false;
            const effectiveMaxKlMisalign = chanConfig.max_kl_misalgin_cnt ?? DEFAULT_CHAN_CONFIG.max_kl_misalgin_cnt ?? 0;
            const effectiveMaxKlInconsistent = chanConfig.max_kl_inconsistent_cnt ?? DEFAULT_CHAN_CONFIG.max_kl_inconsistent_cnt ?? 0;
            const effectiveAutoSkipIllegal = (chanConfig.auto_skip_illegal_sub_lv ?? DEFAULT_CHAN_CONFIG.auto_skip_illegal_sub_lv) ?? false;
            const effectivePrintWarning = (chanConfig.print_warning ?? DEFAULT_CHAN_CONFIG.print_warning) ?? false;
            const effectivePrintErrTime = (chanConfig.print_err_time ?? DEFAULT_CHAN_CONFIG.print_err_time) ?? false;

            const resetBspToDefault = useCallback(() => {
                setChanConfig(prev => ({
                    ...prev,
                    divergence_rate: DEFAULT_CHAN_CONFIG.divergence_rate,
                    min_zs_cnt: DEFAULT_CHAN_CONFIG.min_zs_cnt,
                    bsp1_only_multibi_zs: DEFAULT_CHAN_CONFIG.bsp1_only_multibi_zs,
                    max_bs2_rate: DEFAULT_CHAN_CONFIG.max_bs2_rate,
                    macd_algo: DEFAULT_CHAN_CONFIG.macd_algo,
                    bs1_peak: DEFAULT_CHAN_CONFIG.bs1_peak,
                    bs_type: DEFAULT_CHAN_CONFIG.bs_type,
                    bsp2_follow_1: DEFAULT_CHAN_CONFIG.bsp2_follow_1,
                    bsp3_follow_1: DEFAULT_CHAN_CONFIG.bsp3_follow_1,
                    bsp3_peak: DEFAULT_CHAN_CONFIG.bsp3_peak,
                    bsp2s_follow_2: DEFAULT_CHAN_CONFIG.bsp2s_follow_2,
                    max_bsp2s_lv: DEFAULT_CHAN_CONFIG.max_bsp2s_lv,
                    strict_bsp3: DEFAULT_CHAN_CONFIG.strict_bsp3,
                }));
                message.success('Â∑≤ÊÅ¢Â§ç‰π∞ÂçñÁÇπÈªòËÆ§ÈÖçÁΩÆ');
            }, [setChanConfig]);

            const basicContent = (
                <Space direction="vertical" size={16} style={{ width: '100%' }}>
                    <div className="config-section">
                        <div className="config-section-title" style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                            <span>Ê†∏ÂøÉÂèÇÊï∞</span>
                            <Space size={8}>
                                <Button size="small" onClick={openJsonModal}>Êü•ÁúãJSON</Button>
                                <Button size="small" onClick={resetCoreConfig}>Ê†∏ÂøÉÈáçÁΩÆ</Button>
                                <Button size="small" onClick={resetAllToDefault}>ÊÅ¢Â§çÈªòËÆ§</Button>
                            </Space>
                        </div>
                        <div className="config-grid config-grid--two">
                            <div className="config-field">
                                <label>Á¨îÁÆóÊ≥ï</label>
                                <Select
                                    size="small"
                                    value={effectiveBiAlgo}
                                    onChange={handleSelect('bi_algo')}
                                    options={BI_ALGO_OPTIONS}
                                />
                                <div className="config-hint">ÈªòËÆ§Ôºönormal</div>
                            </div>
                            <div className="config-field">
                                <label>Á∫øÊÆµÁÆóÊ≥ï</label>
                                <Select
                                    size="small"
                                    value={effectiveSegAlgo}
                                    onChange={handleSelect('seg_algo')}
                                    options={SEG_ALGO_OPTIONS}
                                />
                                <div className="config-hint">ÈªòËÆ§Ôºöchan</div>
                            </div>
                            <div className="config-field">
                                <label>‰∏≠Êû¢ÁÆóÊ≥ï</label>
                                <Select
                                    size="small"
                                    value={effectiveZsAlgo}
                                    onChange={handleSelect('zs_algo')}
                                    options={[
                                        { value: 'normal', label: 'Ê†áÂáÜ' },
                                        { value: 'over_seg', label: 'Ë∑®ÊÆµ' },
                                        { value: 'auto', label: 'Ëá™Âä®' },
                                    ]}
                                />
                                <div className="config-hint">ÈªòËÆ§ÔºöÊ†áÂáÜ</div>
                            </div>
                        </div>
                        <div className="config-hint" style={{ marginTop: 8 }}>
                            ËØ¶ÁªÜÁöÑÁ¨î‰∏é‰∏≠Êû¢Âà§ÂÆöËØ∑ÂâçÂæÄ‚ÄúÈ´òÁ∫ßËÆæÁΩÆ‚ÄùË∞ÉÊï¥
                        </div>
                    </div>

                    <div className="config-section">
                        <div className="config-section-title">ËøêË°åÊéßÂà∂</div>
                        <div className="config-checkbox-group config-checkbox-group--compact">
                            <Checkbox checked={!!effectiveTriggerStep} onChange={handleBoolean('trigger_step')}>Â¢ûÈáèËß¶Âèë</Checkbox>
                            <Checkbox checked={!!effectiveKlDataCheck} onChange={handleBoolean('kl_data_check')}>Ê£ÄÊü•KÁ∫ø‰∏ÄËá¥ÊÄßÔºàÈªòËÆ§Ôºâ</Checkbox>
                        </div>
                        <div className="config-hint" style={{ marginTop: 8 }}>
                            Êó•ÂøóËæìÂá∫ÂíåÂÆπÈîôÁ≠ñÁï•ËØ∑Âú®È´òÁ∫ßËÆæÁΩÆ‰∏≠Ë∞ÉÊï¥
                        </div>
                        <div className="config-grid config-grid--two" style={{ marginTop: 12 }}>
                            <div className="config-field">
                                <label>Ë∑≥ËøáÊ≠•Èïø</label>
                                <InputNumber size="small" min={0} value={effectiveSkipStep} onChange={handleNumber('skip_step')} />
                                <div className="config-hint">ÈªòËÆ§Ôºö0</div>
                            </div>
                            <div className="config-field">
                                <label>Â∏ÉÊûó N</label>
                                <InputNumber size="small" min={1} value={chanConfig.boll_n ?? DEFAULT_CHAN_CONFIG.boll_n} onChange={handleNumber('boll_n')} />
                                <div className="config-hint">ÈªòËÆ§Ôºö20</div>
                            </div>
                            <div className="config-field">
                                <label>Èîô‰ΩçÂÆπÂøç</label>
                                <InputNumber size="small" min={0} value={effectiveMaxKlMisalign} onChange={handleNumber('max_kl_misalgin_cnt')} />
                                <div className="config-hint">ÈªòËÆ§Ôºö2</div>
                            </div>
                            <div className="config-field">
                                <label>‰∏ç‰∏ÄËá¥ÂÆπÂøç</label>
                                <InputNumber size="small" min={0} value={effectiveMaxKlInconsistent} onChange={handleNumber('max_kl_inconsistent_cnt')} />
                                <div className="config-hint">ÈªòËÆ§Ôºö5</div>
                            </div>
                        </div>
                    </div>

                    <div className="config-section">
                        <div className="config-section-title">ÊåáÊ†á</div>
                        <Space size="small" wrap>
                            <LabelWithTip label="MACD" tip="Ë∞ÉÊï¥Âø´ÊÖ¢Á∫ø‰∏é‰ø°Âè∑Á∫øÂë®ÊúüÔºàÈªòËÆ§ 12/26/9Ôºâ" />
                            <InputNumber size="small" min={1} value={chanConfig.macd.fast ?? DEFAULT_CHAN_CONFIG.macd.fast} onChange={handleMacdChange('fast')} />
                            <InputNumber size="small" min={1} value={chanConfig.macd.slow ?? DEFAULT_CHAN_CONFIG.macd.slow} onChange={handleMacdChange('slow')} />
                            <InputNumber size="small" min={1} value={chanConfig.macd.signal ?? DEFAULT_CHAN_CONFIG.macd.signal} onChange={handleMacdChange('signal')} />
                        </Space>
                        <Space size="small" wrap style={{ marginTop: 8 }}>
                            <Checkbox checked={chanConfig.cal_rsi ?? DEFAULT_CHAN_CONFIG.cal_rsi} onChange={handleBoolean('cal_rsi')}>
                                <LabelWithTip label="RSI" tip="ÂºÄÂêØÂêéËÆ°ÁÆó RSI ÊåáÊ†áÔºàÈªòËÆ§ÂÖ≥Èó≠Ôºâ" />
                            </Checkbox>
                            <Checkbox checked={chanConfig.cal_kdj ?? DEFAULT_CHAN_CONFIG.cal_kdj} onChange={handleBoolean('cal_kdj')}>
                                <LabelWithTip label="KDJ" tip="ÂºÄÂêØÂêéËÆ°ÁÆó KDJ ÊåáÊ†áÔºàÈªòËÆ§ÂÖ≥Èó≠Ôºâ" />
                            </Checkbox>
                            <Checkbox checked={chanConfig.cal_demark ?? DEFAULT_CHAN_CONFIG.cal_demark} onChange={handleBoolean('cal_demark')}>
                                <LabelWithTip label="DeMark" tip="ÂºÄÂêØÂêéËÆ°ÁÆó DeMark ÊåáÊ†áÔºàÈªòËÆ§ÂÖ≥Èó≠Ôºâ" />
                            </Checkbox>
                        </Space>
                    </div>
                </Space>
            );
                        const advancedItems = [
                {
                    key: 'structure',
                    label: 'ÁªìÊûÑÂèÇÊï∞',
                    children: (
                        <div className="config-collapse-body">
                            <div className="config-section">
                                <div className="config-section-title" style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                                    <span>ÁªìÊûÑËßÜÂõæ</span>
                                    <Segmented
                                        size="small"
                                        value={structureView}
                                        onChange={setStructureView}
                                        options={[
                                            { label: 'Á¨î', value: 'bi' },
                                            { label: 'Á∫øÊÆµ', value: 'seg' },
                                            { label: '‰∏≠Êû¢', value: 'zs' },
                                        ]}
                                    />
                                </div>
                                <div className="config-hint">ÊåâÈúÄÂàáÊç¢‰∏çÂêåÁªìÊûÑÁª¥Â∫¶ÔºåÂáèÂ∞ë‰∏ÄÊ¨°ÊÄß‰ø°ÊÅØÈáè</div>
                            </div>
                            {structureView === 'bi' && (
                                <div className="config-section">
                                    <div className="config-grid config-grid--two">
                                        <div className="config-field">
                                            <label>
                                                <LabelWithTip label="ÂàÜÂûãÂà§ÂÆö" tip="ÂÜ≥ÂÆöÂàÜÂûãÁ°ÆËÆ§ÊñπÂºèÔºåÂΩ±ÂìçÁ¨îËØÜÂà´ÁöÑ‰∏•Ê†ºÁ®ãÂ∫¶" />
                                            </label>
                                            <Select
                                                size="small"
                                                value={effectiveBiFxCheck}
                                                onChange={handleSelect('bi_fx_check')}
                                                options={[
                                                    { value: 'strict', label: '‰∏•Ê†º' },
                                                    { value: 'half', label: 'Âçä‰∏•Ê†º' },
                                                    { value: 'loss', label: 'ÊùæÂºõ' },
                                                    { value: 'totally', label: 'ÂÖ®Èáè' },
                                                ]}
                                            />
                                            <div className="config-hint">ÈªòËÆ§Ôºö‰∏•Ê†º</div>
                                        </div>
                                        <div className="config-field config-field--full">
                                            <label>Á¨îÈÄâÈ°π</label>
                                            <div className="config-checkbox-group config-checkbox-group--compact">
                                                <Checkbox checked={!!effectiveBiStrict} onChange={handleBoolean('bi_strict')}>
                                                    ‰∏•Ê†ºÁ¨îÔºàÈªòËÆ§Ôºâ
                                                </Checkbox>
                                                <Checkbox checked={!!effectiveGapAsKl} onChange={handleBoolean('gap_as_kl')}>
                                                    <LabelWithTip label="Áº∫Âè£ËßÜ‰ΩúKÁ∫ø" tip="Â∞Ü‰ª∑Ê†ºË∑≥Á©∫ËßÜ‰ΩúÁã¨Á´ãKÁ∫øÂ§ÑÁêÜ" />
                                                </Checkbox>
                                                <Checkbox checked={!!effectiveBiEndIsPeak} onChange={handleBoolean('bi_end_is_peak')}>
                                                    <LabelWithTip label="Á¨îÂ∞æÂøÖÈ°ªÈ°∂/Â∫ï" tip="Á¨îÁªìÊùüÊó∂ÂøÖÈ°ªÊª°Ë∂≥È°∂/Â∫ïÊù°‰ª∂" />
                                                </Checkbox>
                                                <Checkbox checked={!!effectiveBiAllowSubPeak} onChange={handleBoolean('bi_allow_sub_peak')}>
                                                    <LabelWithTip label="ÂÖÅËÆ∏Ê¨°Á∫ßÂà´È°∂Â∫ï" tip="ÂÖÅËÆ∏‰ΩøÁî®Ê¨°Á∫ßÂà´ÁöÑÈ°∂Â∫ïÂÆåÊàêÁ¨î" />
                                                </Checkbox>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            )}
                            {structureView === 'seg' && (
                                <div className="config-section">
                                    <div className="config-grid config-grid--two">
                                        <div className="config-field">
                                            <label>
                                                <LabelWithTip label="Á∫øÊÆµÁÆóÊ≥ï" tip="Ë∞ÉÊï¥Á∫øÊÆµÂàíÂàÜÈÄªËæëÔºàÈªòËÆ§ ChanÔºâ" />
                                            </label>
                                            <Select
                                                size="small"
                                                value={effectiveSegAlgo}
                                                onChange={handleSelect('seg_algo')}
                                                options={SEG_ALGO_OPTIONS}
                                            />
                                            <div className="config-hint">ÈªòËÆ§Ôºöchan</div>
                                        </div>
                                        <div className="config-field">
                                            <label>
                                                <LabelWithTip label="Á∫øÊÆµÂ∑¶Á´Ø" tip="ÂÜ≥ÂÆöÁ∫øÊÆµËµ∑ÁÇπÁöÑËÆ°ÁÆóÊñπÂºèÔºàÈªòËÆ§Â≥∞ÂÄºÔºâ" />
                                            </label>
                                            <Select
                                                size="small"
                                                value={effectiveLeftSegMethod}
                                                onChange={handleSelect('left_seg_method')}
                                                options={[
                                                    { value: 'peak', label: 'Â≥∞ÂÄº' },
                                                    { value: 'all', label: 'ÂÖ®Èáè' },
                                                ]}
                                            />
                                            <div className="config-hint">ÈªòËÆ§ÔºöÂ≥∞ÂÄº</div>
                                        </div>
                                    </div>
                                </div>
                            )}
                            {structureView === 'zs' && (
                                <div className="config-section">
                                    <div className="config-grid config-grid--two">
                                        <div className="config-field">
                                            <label>
                                                <LabelWithTip label="‰∏≠Êû¢ÁÆóÊ≥ï" tip="Ë∞ÉÊï¥‰∏≠Êû¢ËØÜÂà´ÁÆóÊ≥ïÔºàÊ†áÂáÜ/Ë∑®ÊÆµ/Ëá™Âä®Ôºâ" />
                                            </label>
                                            <Select
                                                size="small"
                                                value={effectiveZsAlgo}
                                                onChange={handleSelect('zs_algo')}
                                                options={[
                                                    { value: 'normal', label: 'Ê†áÂáÜ' },
                                                    { value: 'over_seg', label: 'Ë∑®ÊÆµ' },
                                                    { value: 'auto', label: 'Ëá™Âä®' },
                                                ]}
                                            />
                                            <div className="config-hint">ÈªòËÆ§ÔºöÊ†áÂáÜ</div>
                                        </div>
                                        <div className="config-field">
                                            <label>
                                                <LabelWithTip label="ÂêàÂπ∂Ê®°Âºè" tip="‰∏≠Êû¢ÂêàÂπ∂ÂêéÁöÑÁªìÊûú‰ª•‰∏≠Êû¢Ëá™Ë∫´ÊàñÁ∫øÊÆµÊõø‰ª£" />
                                            </label>
                                            <Select
                                                size="small"
                                                value={effectiveZsCombineMode}
                                                onChange={handleSelect('zs_combine_mode')}
                                                options={[
                                                    { value: 'zs', label: '‰∏≠Êû¢' },
                                                    { value: 'seg', label: 'Á∫øÊÆµ' },
                                                ]}
                                                disabled={!effectiveZsCombine}
                                            />
                                            <div className="config-hint">ÈªòËÆ§Ôºö‰∏≠Êû¢</div>
                                        </div>
                                        <div className="config-field config-field--full">
                                            <label>‰∏≠Êû¢ÈÄâÈ°π</label>
                                            <div className="config-checkbox-group config-checkbox-group--compact">
                                                <Checkbox checked={!!effectiveZsCombine} onChange={handleBoolean('zs_combine')}>
                                                    ÂêàÂπ∂‰∏≠Êû¢ÔºàÈªòËÆ§Ôºâ
                                                </Checkbox>
                                                <Checkbox checked={!!effectiveOneBiZs} onChange={handleBoolean('one_bi_zs')}>
                                                    ÂçïÁ¨î‰∏≠Êû¢
                                                </Checkbox>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            )}
                        </div>
                    ),
                },
                {
                    key: 'bsp',
                    label: '‰π∞ÂçñÁÇπ',
                    children: (
                        <div className="config-collapse-body">
                            <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'flex-start', gap: 12 }}>
                                <div style={{ fontSize: 12, color: '#888', lineHeight: 1.6 }}>
                                    Êé®ËçêÂü∫Á∫øÔºöÊúÄÂ∞è‰∏≠Êû¢Êï∞ 1ÔºåÂºÄÂêØÂ§öÁ¨î‰∏≠Êû¢ + Â≥∞ÂÄºÁ™ÅÁ†¥ÔºåT1/T1P ‰∏∫‰∏ª‰ø°Âè∑ÔºåÊ†πÊçÆÈúÄË¶ÅÂÜçÊîæÂºÄÂÖ∂‰ªñÁ±ªÂûã„ÄÇ
                                </div>
                                <Button size="small" onClick={resetBspToDefault}>ÊÅ¢Â§çÈªòËÆ§</Button>
                            </div>
                            <div className="config-grid config-grid--two">
                                <div className="config-field">
                                    <label>
                                        <LabelWithTip label="ËÉåÈ©∞ÈòàÂÄº" tip="ËÆæÁΩÆËÉåÈ©∞Âà§ÂÆöÁöÑÊúÄÂ§ßÊØîÁéáÔºåÈªòËÆ§ Infinity Ë°®Á§∫ÂÖ≥Èó≠ÈòàÂÄºÈôêÂà∂" />
                                    </label>
                                    <InputNumber
                                        size="small"
                                        min={0}
                                        value={Number.isFinite(effectiveDivergenceRate) ? effectiveDivergenceRate : undefined}
                                        placeholder="‚àû"
                                        onChange={(value) => {
                                            if (value === null || value === undefined || value === '') {
                                                mergeConfig({ divergence_rate: Number.POSITIVE_INFINITY });
                                                return;
                                            }
                                            const numeric = Number(value);
                                            if (Number.isFinite(numeric) && numeric >= 0) {
                                                mergeConfig({ divergence_rate: numeric });
                                            }
                                        }}
                                    />
                                    <div className="config-hint">ÈªòËÆ§Ôºö‚àû</div>
                                </div>
                                <div className="config-field">
                                    <label>
                                        <LabelWithTip label="ÊúÄÂ∞è‰∏≠Êû¢Êï∞" tip="ËÆæÁΩÆËß¶Âèë‰π∞ÂçñÁÇπÊâÄÈúÄÁöÑÊúÄ‰Ωé‰∏≠Êû¢Êï∞Èáè" />
                                    </label>
                                    <InputNumber size="small" min={0} value={effectiveMinZsCnt} onChange={handleNumber('min_zs_cnt')} />
                                    <div className="config-hint">ÈªòËÆ§Ôºö1</div>
                                </div>
                                <div className="config-field">
                                    <label>
                                        <LabelWithTip label="MACD Âà§ÂÆö" tip="ËÉåÈ©∞ËÆ°ÁÆóÊâÄ‰ΩøÁî®ÁöÑ MACD ÊåáÊ†á" />
                                    </label>
                                    <Select
                                        size="small"
                                        value={effectiveMacdAlgo}
                                        style={{ width: 160 }}
                                        onChange={handleSelect('macd_algo')}
                                        options={[
                                            { value: 'peak', label: 'peak (Â≥∞ÂÄº)' },
                                            { value: 'area', label: 'area (Èù¢ÁßØ)' },
                                            { value: 'diff', label: 'diff (Â∑ÆÂÄº)' },
                                            { value: 'slope', label: 'slope (ÊñúÁéá)' },
                                            { value: 'amp', label: 'amp (ÊåØÂπÖ)' },
                                        ]}
                                    />
                                    <div className="config-hint">ÈªòËÆ§Ôºöpeak</div>
                                </div>
                                <div className="config-field">
                                    <label>
                                        <LabelWithTip label="T2ÊúÄÂ§ßÊØî‰æã" tip="T2/T2S Ëß¶ÂèëÊó∂ÂÖÅËÆ∏ÁöÑÊúÄÂ§ßÂõûÊí§ÊØî‰æã" />
                                    </label>
                                    <InputNumber size="small" min={0} max={1} step={0.01} value={effectiveMaxBs2Rate} onChange={handleNumber('max_bs2_rate')} />
                                    <div className="config-hint">ÈªòËÆ§Ôºö0.9999</div>
                                </div>
                                <div className="config-field">
                                    <label>
                                        <LabelWithTip label="T2ÊúÄÂ§ßÂ±ÇÁ∫ß" tip="ÈôêÂà∂ T2/T2S ‰ø°Âè∑Ë∑ùÂΩìÂâç‰ΩçÁΩÆÁöÑÊúÄÂ§ßÂ±ÇÁ∫ßÔºåÁïôÁ©∫Âàô‰∏çÈôêÂà∂" />
                                    </label>
                                    <InputNumber
                                        size="small"
                                        min={0}
                                        value={effectiveMaxBsp2sLv ?? null}
                                        placeholder="‰∏çÈôê"
                                        onChange={(value) => {
                                            if (value === null || value === undefined || value === '') {
                                                mergeConfig({ max_bsp2s_lv: null });
                                                return;
                                            }
                                            const numeric = Number(value);
                                            if (Number.isFinite(numeric) && numeric >= 0) {
                                                mergeConfig({ max_bsp2s_lv: numeric });
                                            }
                                        }}
                                    />
                                    <div className="config-hint">ÈªòËÆ§Ôºö‰∏çÈôê</div>
                                </div>
                                <div className="config-field config-field--full">
                                    <label>‰π∞ÂçñÁÇπÂºÄÂÖ≥</label>
                                    <div className="config-checkbox-group config-checkbox-group--compact">
                                        <Checkbox checked={!!effectiveBsp1OnlyMultiBiZs} onChange={handleBoolean('bsp1_only_multibi_zs')}>
                                            <LabelWithTip label="‰ªÖÂ§öÁ¨î‰∏≠Êû¢" tip="‰ªÖÂú®Â≠òÂú®Â§öÁ¨î‰∏≠Êû¢Êó∂ËÆ°ÁÆó BSP1/T1ÔºàÈªòËÆ§ÂêØÁî®Ôºâ" />
                                        </Checkbox>
                                        <Checkbox checked={!!effectiveBs1Peak} onChange={handleBoolean('bs1_peak')}>
                                            <LabelWithTip label="‰ªÖÂ≥∞ÂÄºÁ™ÅÁ†¥" tip="T1 ÂøÖÈ°ªÁ™ÅÁ†¥‰∏≠Êû¢Â≥∞ÂÄºÊâçÁÆóËÉåÈ©∞ÔºàÈªòËÆ§ÂêØÁî®Ôºâ" />
                                        </Checkbox>
                                        <Checkbox checked={!!effectiveBsp2Follow1} onChange={handleBoolean('bsp2_follow_1')}>
                                            <LabelWithTip label="T2Ë∑üÈöèT1" tip="T2 ÈúÄË¶ÅÂú® T1 Âá∫Áé∞ÂêéÊâçÁîüÊïàÔºàÈªòËÆ§ÂêØÁî®Ôºâ" />
                                        </Checkbox>
                                        <Checkbox checked={!!effectiveBsp3Follow1} onChange={handleBoolean('bsp3_follow_1')}>
                                            <LabelWithTip label="T3Ë∑üÈöèT1" tip="T3 ÈúÄË¶ÅÂú® T1 Âá∫Áé∞ÂêéÊâçÁîüÊïàÔºàÈªòËÆ§ÂêØÁî®Ôºâ" />
                                        </Checkbox>
                                        <Checkbox checked={!!effectiveBsp3Peak} onChange={handleBoolean('bsp3_peak')}>
                                            <LabelWithTip label="T3ÈúÄÁ™ÅÁ†¥Â≥∞ÂÄº" tip="T3 ÂøÖÈ°ªÁ™ÅÁ†¥‰∏≠Êû¢Â≥∞ÂÄºÔºàÈªòËÆ§ÂÖ≥Èó≠Ôºâ" />
                                        </Checkbox>
                                        <Checkbox checked={!!effectiveBsp2sFollow2} onChange={handleBoolean('bsp2s_follow_2')}>
                                            <LabelWithTip label="T2SË∑üÈöèT2" tip="T2S ‰ø°Âè∑ÈúÄÂú® T2 ÂêéÂá∫Áé∞ÔºàÈªòËÆ§ÂÖ≥Èó≠Ôºâ" />
                                        </Checkbox>
                                        <Checkbox checked={!!effectiveStrictBsp3} onChange={handleBoolean('strict_bsp3')}>
                                            <LabelWithTip label="‰∏•Ê†º T3" tip="‰∏•Ê†ºË¶ÅÊ±Ç T3 ÁöÑËøõÂá∫‰ΩçÁΩÆËøûÁª≠ÔºàÈªòËÆ§ÂÖ≥Èó≠Ôºâ" />
                                        </Checkbox>
                                    </div>
                                </div>
                                <div className="config-field config-field--full">
                                    <label>‰π∞ÂçñÁÇπÁ±ªÂûã</label>
                                    <Checkbox.Group
                                        options={bsTypeOptions}
                                        value={bsTypeSelection.length > 0 ? bsTypeSelection : defaultBsTypeArray}
                                        onChange={handleBsTypeChange}
                                    />
                                    <div className="config-hint">ÈªòËÆ§Ôºö{defaultBsTypeArray.join(', ')}</div>
                                </div>
                            </div>
                        </div>
                    ),
                },
                {
                    key: 'runtime',
                    label: 'ËøêË°å‰∏éÊ†°È™å',
                    children: (
                        <div className="config-collapse-body">
                            <div className="config-section">
                                <div className="config-section-title">Êó•ÂøóËæìÂá∫</div>
                                <div className="config-checkbox-group config-checkbox-group--compact">
                                    <Checkbox checked={!!effectivePrintWarning} onChange={handleBoolean('print_warning')}>
                                        ÊâìÂç∞Ë≠¶ÂëäÔºàÈªòËÆ§Ôºâ
                                    </Checkbox>
                                    <Checkbox checked={!!effectivePrintErrTime} onChange={handleBoolean('print_err_time')}>
                                        ÊâìÂç∞ÂºÇÂ∏∏Êó∂Èó¥ÔºàÈªòËÆ§Ôºâ
                                    </Checkbox>
                                </div>
                                <div className="config-hint">ÂºÄÂêØÂêéÂèØÂø´ÈÄüÂÆö‰ΩçÊï∞ÊçÆÁº∫Â§±ÊàñÂõûÊîæÂºÇÂ∏∏</div>
                            </div>
                            <div className="config-section">
                                <div className="config-section-title">ÂÆπÈîôÁ≠ñÁï•</div>
                                <div className="config-checkbox-group config-checkbox-group--compact">
                                    <Checkbox checked={!!effectiveAutoSkipIllegal} onChange={handleBoolean('auto_skip_illegal_sub_lv')}>
                                        Ëá™Âä®Ë∑≥ËøáÈùûÊ≥ïÂ≠êÁ∫ßÂà´
                                    </Checkbox>
                                </div>
                                <div className="config-hint">Â≠êÁ∫ßÂà´Êï∞ÊçÆÁº∫Â§±Êó∂Ëá™Âä®ÂâîÈô§ÂØπÂ∫îÁ∫ßÂà´ÔºåÈò≤Ê≠¢Êï¥Â•óËÆ°ÁÆó‰∏≠Êñ≠</div>
                            </div>
                        </div>
                    ),
                },
                {
                    key: 'metrics',
                    label: 'ÊåáÊ†áÂèÇÊï∞',
                    children: (
                        <div className="config-collapse-body">
                            <div className="config-grid config-grid--two">
                                <div className="config-field">
                                    <label>
                                        <LabelWithTip label="ÂùáÂÄºÁ™óÂè£" tip="Áî®‰∫éÂùáÂÄºÂ∫èÂàóÁöÑÁ™óÂè£ÈïøÂ∫¶ÔºåÂèØËæìÂÖ•Â§ö‰∏™Êï∞ÂÄº" />
                                    </label>
                                    <Select
                                        mode="tags"
                                        size="small"
                                        placeholder="Â¶Ç 5,10,20"
                                        style={{ minWidth: 200 }}
                                        value={(chanConfig.mean_metrics || []).map(String)}
                                        onChange={handleMeanMetricsChange}
                                    />
                                </div>
                                <div className="config-field">
                                    <label>
                                        <LabelWithTip label="Ë∂ãÂäøÁ™óÂè£" tip="Ë∂ãÂäøÊåáÊ†á‰ΩøÁî®ÁöÑÊúÄÂ§ß/ÊúÄÂ∞èÁ™óÂè£ÈïøÂ∫¶" />
                                    </label>
                                    <Select
                                        mode="tags"
                                        size="small"
                                        placeholder="Â¶Ç 55, 89"
                                        style={{ minWidth: 200 }}
                                        value={(chanConfig.trend_metrics || []).map(String)}
                                        onChange={handleTrendMetricsChange}
                                    />
                                </div>
                                <div className="config-field">
                                    <label>
                                        <LabelWithTip label="RSIÂë®Êúü" tip="RSI ÊåáÊ†áÁöÑÂë®ÊúüÈïøÂ∫¶" />
                                    </label>
                                    <InputNumber size="small" min={1} value={chanConfig.rsi_cycle ?? DEFAULT_CHAN_CONFIG.rsi_cycle} onChange={handleNumber('rsi_cycle')} disabled={!(chanConfig.cal_rsi ?? DEFAULT_CHAN_CONFIG.cal_rsi)} />
                                </div>
                                <div className="config-field">
                                    <label>
                                        <LabelWithTip label="KDJÂë®Êúü" tip="KDJ ÊåáÊ†áÁöÑÂë®ÊúüÈïøÂ∫¶" />
                                    </label>
                                    <InputNumber size="small" min={1} value={chanConfig.kdj_cycle ?? DEFAULT_CHAN_CONFIG.kdj_cycle} onChange={handleNumber('kdj_cycle')} disabled={!(chanConfig.cal_kdj ?? DEFAULT_CHAN_CONFIG.cal_kdj)} />
                                </div>
                                <div className="config-field config-field--full">
                                    <label>
                                        <LabelWithTip label="DeMark" tip="DeMark ÊåáÊ†áÂèÇÊï∞Ë∞ÉÊï¥" />
                                    </label>
                                    <div className="config-grid config-grid--two" style={{ gap: 8 }}>
                                        <InputNumber size="small" min={1} value={chanConfig.demark?.demark_len ?? DEFAULT_CHAN_CONFIG.demark.demark_len} onChange={handleDemarkChange('demark_len')} disabled={!(chanConfig.cal_demark ?? DEFAULT_CHAN_CONFIG.cal_demark)} />
                                        <InputNumber size="small" min={0} value={chanConfig.demark?.setup_bias ?? DEFAULT_CHAN_CONFIG.demark.setup_bias} onChange={handleDemarkChange('setup_bias')} disabled={!(chanConfig.cal_demark ?? DEFAULT_CHAN_CONFIG.cal_demark)} />
                                        <InputNumber size="small" min={0} value={chanConfig.demark?.countdown_bias ?? DEFAULT_CHAN_CONFIG.demark.countdown_bias} onChange={handleDemarkChange('countdown_bias')} disabled={!(chanConfig.cal_demark ?? DEFAULT_CHAN_CONFIG.cal_demark)} />
                                        <InputNumber size="small" min={1} value={chanConfig.demark?.max_countdown ?? DEFAULT_CHAN_CONFIG.demark.max_countdown} onChange={handleDemarkChange('max_countdown')} disabled={!(chanConfig.cal_demark ?? DEFAULT_CHAN_CONFIG.cal_demark)} />
                                    </div>
                                    <div className="config-checkbox-group config-checkbox-group--compact" style={{ marginTop: 8 }}>
                                        <Checkbox checked={chanConfig.demark?.tiaokong_st ?? DEFAULT_CHAN_CONFIG.demark.tiaokong_st} onChange={handleDemarkToggle('tiaokong_st')} disabled={!(chanConfig.cal_demark ?? DEFAULT_CHAN_CONFIG.cal_demark)}>
                                            <LabelWithTip label="Ë∑≥Á©∫ÁÆó Setup" tip="Âú® Setup ËÆ°Êï∞Êó∂Â∞ÜË∑≥Á©∫ËßÜ‰ΩúÊª°Ë∂≥Êù°‰ª∂ÔºàÈªòËÆ§ÂºÄÂêØÔºâ" />
                                        </Checkbox>
                                        <Checkbox checked={chanConfig.demark?.setup_cmp2close ?? DEFAULT_CHAN_CONFIG.demark.setup_cmp2close} onChange={handleDemarkToggle('setup_cmp2close')} disabled={!(chanConfig.cal_demark ?? DEFAULT_CHAN_CONFIG.cal_demark)}>
                                            <LabelWithTip label="Setup ÊØîËæÉÊî∂Áõò‰ª∑" tip="Setup ÊØîËæÉ‰ΩøÁî®Êî∂Áõò‰ª∑ËÄåÈùûÊúÄÈ´ò/ÊúÄ‰ΩéÔºàÈªòËÆ§ÂºÄÂêØÔºâ" />
                                        </Checkbox>
                                        <Checkbox checked={chanConfig.demark?.countdown_cmp2close ?? DEFAULT_CHAN_CONFIG.demark.countdown_cmp2close} onChange={handleDemarkToggle('countdown_cmp2close')} disabled={!(chanConfig.cal_demark ?? DEFAULT_CHAN_CONFIG.cal_demark)}>
                                            <LabelWithTip label="Countdown ÊØîËæÉÊî∂Áõò‰ª∑" tip="Countdown ËÆ°Êï∞‰ΩøÁî®Êî∂Áõò‰ª∑ÊØîËæÉÔºàÈªòËÆ§ÂºÄÂêØÔºâ" />
                                        </Checkbox>
                                    </div>
                                </div>
                            </div>
                        </div>
                    ),
                },
            ];

            return (
                <>
                    <Tabs
                        size="small"
                        defaultActiveKey="basic"
                        items={[
                            { key: 'basic', label: 'Âü∫Á°ÄËÆæÁΩÆ', children: basicContent },
                            { key: 'advanced', label: 'È´òÁ∫ßËÆæÁΩÆ', children: <Collapse ghost defaultActiveKey={[]} items={advancedItems} /> },
                        ]}
                    />
                    <Modal
                        width={720}
                        title="Áº†ËÆ∫ÈÖçÁΩÆ JSON"
                        open={jsonModalVisible}
                        onCancel={closeJsonModal}
                        destroyOnClose
                        footer={[
                            <Button key="copy" onClick={handleCopyJson}>Â§çÂà∂</Button>,
                            <Button key="apply" type="primary" onClick={handleJsonApply}>Â∫îÁî®</Button>,
                            <Button key="close" onClick={closeJsonModal}>ÂÖ≥Èó≠</Button>,
                        ]}
                    >
                        <Input.TextArea
                            value={jsonEditorValue}
                            onChange={handleJsonChange}
                            autoSize={{ minRows: 12, maxRows: 18 }}
                            spellCheck={false}
                        />
                        {jsonParseError && (
                            <div style={{ marginTop: 8, color: '#d4380d', fontSize: 12 }}>
                                {jsonParseError}
                            </div>
                        )}
                    </Modal>
                </>
            );
        });

        const AlertPanel = memo(() => {
            const { alertHistory, alertConnected, alertError, alertStrategies, refreshAlertHistory } = useApp();
            const severityColorMap = {
                info: 'processing',
                warning: 'warning',
                critical: 'error',
            };

            return (
                <div className="alert-panel">
                    <div className="alert-status">
                        <span className="alert-status-indicator">
                            <span className={`status-dot ${alertConnected ? 'status-dot--online' : 'status-dot--offline'}`} />
                            {alertConnected ? 'ÂÆûÊó∂ËøûÊé•Ê≠£Â∏∏' : 'Á≠âÂæÖÂÆûÊó∂Êï∞ÊçÆ...'}
                        </span>
                        <Button size="small" onClick={refreshAlertHistory}>Âà∑Êñ∞</Button>
                    </div>
                    {alertError && <div className="alert-error-text">{alertError}</div>}
                    <div>
                        <div className="config-section-title">Â∑≤ÂêØÁî®Á≠ñÁï•</div>
                        <div className="alert-strategy-tags">
                            {alertStrategies.length === 0 ? (
                                <div className="chart-info-placeholder">ÊöÇÊó†Á≠ñÁï•</div>
                            ) : (
                                alertStrategies.map(strategy => (
                                    <Tag key={strategy.id}>{strategy.name}</Tag>
                                ))
                            )}
                        </div>
                    </div>
                    <div>
                        <div className="config-section-title">ÂÆûÊó∂Êä•Ë≠¶</div>
                        <div className="alert-history">
                            {alertHistory.length === 0 ? (
                                <div className="chart-info-placeholder">ÊöÇÊó†Êä•Ë≠¶ÔºåÁ≠ñÁï•ËøêË°å‰∏≠...</div>
                            ) : (
                                alertHistory.map((alert, idx) => (
                                    <div key={`${alert.strategy_id}-${alert.created_at}-${idx}`} className="alert-card">
                                        <div className="alert-card-header">
                                            <span className="alert-card-title">{alert.strategy_name || alert.strategy_id}</span>
                                            <Tag color={severityColorMap[alert.severity] || 'default'}>
                                                {(alert.severity || 'info').toUpperCase()}
                                            </Tag>
                                        </div>
                                        <div className="alert-card-message">{alert.message}</div>
                                        <div className="alert-card-meta">
                                            <span>{alert.symbol} ¬∑ {alert.level}</span>
                                            <span>{alert.created_at ? dayjs(alert.created_at).format('MM-DD HH:mm:ss') : '--'}</span>
                                        </div>
                                    </div>
                                ))
                            )}
                        </div>
                    </div>
                </div>
            );
        });

        const RightSidebar = memo(() => (
            <Tabs
                size="small"
                defaultActiveKey="view"
                items={[
                    { key: 'view', label: 'ÊòæÁ§∫ËÆæÁΩÆ', children: <IndicatorConfig /> },
                    { key: 'chan', label: 'Áº†ËÆ∫ÈÖçÁΩÆ', children: <ChanConfigPanel /> },
                    { key: 'backtest', label: 'ÂõûÊµãÂ∑•ÂÖ∑', children: <BacktestConsole /> },
                    { key: 'alerts', label: 'ÁõØÁõòÊä•Ë≠¶', children: <AlertPanel /> },
                ]}
            />
        ));

        // ============= Chart Grid Component =============
        const ChartGrid = () => (
            <div className="chart-grid chart-grid-1x1">
                <ActiveStockPanel />
            </div>
        );

        // ============= Main App Component =============
        const App = () => {
            const savedConfig = loadConfig();

            const hydrateStocks = (rawStocks = []) => {
                const timestampBase = Date.now();
                return rawStocks
                    .filter(stock => stock && stock.code)
                    .map((stock, idx) => ({
                        id: stock.id ?? (timestampBase + idx),
                        code: stock.code,
                        name: stock.name || '',
                    }));
            };

            const initialStocks = useMemo(() => hydrateStocks(savedConfig?.stocks), []);
            const savedIndicators = sanitizeIndicators(savedConfig?.indicators);

            const [stocks, setStocks] = useState(initialStocks);
            const [activeStockCode, setActiveStockCode] = useState(() => {
                const stored = savedConfig?.ui?.activeStockCode;
                if (stored) {
                    return stored;
                }
                return initialStocks[0]?.code ?? null;
            });
            const [activeLevels, setActiveLevels] = useState(() => {
                const stored = savedConfig?.chart?.activeLevels;
                if (Array.isArray(stored) && stored.length > 0) {
                    return Array.from(new Set(stored));
                }
                return [DEFAULT_LEVEL];
            });
            const [levelLayout, setLevelLayout] = useState(savedConfig?.chart?.layout || 'stack');
            const initialChartDensity = useMemo(() => {
                const saved = savedConfig?.chart?.density;
                return ['wide', 'ultra', 'mega'].includes(saved) ? saved : 'mega';
            }, []);
            const [chartDensity, setChartDensity] = useState(initialChartDensity);
            const [indicators, setIndicators] = useState(() => ({
                ...DEFAULT_INDICATORS,
                ...savedIndicators,
                bsp_filters: {
                    ...(savedIndicators?.bsp_filters
                        ? {
                            directions: [...(savedIndicators.bsp_filters.directions || DEFAULT_BSP_FILTERS.directions)],
                            types: [...(savedIndicators.bsp_filters.types || [])],
                        }
                        : { ...DEFAULT_BSP_FILTERS }),
                },
            }));
            const [chanConfig, setChanConfig] = useState(() => {
                const savedChan = savedConfig?.chanConfig || {};
                return {
                    ...DEFAULT_CHAN_CONFIG,
                    ...savedChan,
                    macd: {
                        ...DEFAULT_CHAN_CONFIG.macd,
                        ...(savedChan.macd || {}),
                    },
                    demark: {
                        ...DEFAULT_CHAN_CONFIG.demark,
                        ...(savedChan.demark || {}),
                    },
                };
            });
            const focusRequestIdRef = useRef(0);
            const [chartFocusRequest, setChartFocusRequest] = useState(null);
            const requestChartFocus = useCallback(({ stockCode, level, timestamp }) => {
                if (!stockCode || !level || !Number.isFinite(timestamp)) {
                    message.warning('Êó†Ê≥ïÂÆö‰Ωç‰ø°Âè∑Ôºö‰ø°ÊÅØ‰∏çÂÆåÊï¥');
                    return;
                }
                focusRequestIdRef.current += 1;
                setChartFocusRequest({ id: focusRequestIdRef.current, stockCode, level, timestamp, acknowledged: false });
            }, []);
            const acknowledgeChartFocus = useCallback((id) => {
                setChartFocusRequest(prev => (prev && prev.id === id ? { ...prev, acknowledged: true } : prev));
            }, []);
            const [chartData, setChartData] = useState({});
            const [loadingCharts, setLoadingCharts] = useState({});
            const [theme, setTheme] = useState(savedConfig?.theme || 'light');
            const [debugLogging, setDebugLogging] = useState(() => (typeof window !== 'undefined' && window.__CHAN_DEBUG__?.isEnabled?.() ? window.__CHAN_DEBUG__.isEnabled() : false));
            const [leftCollapsed, setLeftCollapsed] = useState(savedConfig?.ui?.leftCollapsed || false);
            const [rightCollapsed, setRightCollapsed] = useState(savedConfig?.ui?.rightCollapsed || false);
            const [leftWidth, setLeftWidth] = useState(savedConfig?.ui?.leftWidth || 280);
            const [rightWidth, setRightWidth] = useState(savedConfig?.ui?.rightWidth || 320);
            const [dragging, setDragging] = useState(null);
            const layoutRef = useRef(null);
            const [alertHistory, setAlertHistory] = useState([]);
            const [alertConnected, setAlertConnected] = useState(false);
            const [alertError, setAlertError] = useState(null);
            const [alertStrategies, setAlertStrategies] = useState([]);
            const alertWsRef = useRef(null);
            const reconnectTimerRef = useRef(null);
            const chartRegistryRef = useRef(new Map());
            const syncLockRef = useRef(false);
            const latestRangeRef = useRef(null);

            useEffect(() => {
                if (typeof window === 'undefined' || !window.__CHAN_DEBUG__?.subscribe) {
                    return undefined;
                }
                const unsubscribe = window.__CHAN_DEBUG__.subscribe((value) => {
                    setDebugLogging(!!value);
                });
                return () => {
                    if (typeof unsubscribe === 'function') {
                        unsubscribe();
                    }
                };
            }, []);

            const toggleDebugLogging = useCallback(() => {
                if (typeof window === 'undefined' || !window.__CHAN_DEBUG__) {
                    message.warning('Ë∞ÉËØïÊ®°Âùó‰∏çÂèØÁî®');
                    return;
                }
                if (window.__CHAN_DEBUG__.isEnabled()) {
                    window.__CHAN_DEBUG__.disable();
                } else {
                    window.__CHAN_DEBUG__.enable();
                }
            }, []);

            const activeStock = useMemo(() => {
                if (!activeStockCode) {
                    return null;
                }
                return stocks.find(stock => stock.code === activeStockCode) || null;
            }, [stocks, activeStockCode]);

            useEffect(() => {
                try {
                    const config = {
                        stocks,
                        indicators: sanitizeIndicators(indicators),
                        chanConfig,
                        theme,
                        ui: { leftCollapsed, rightCollapsed, leftWidth, rightWidth, activeStockCode },
                        chart: { activeLevels, layout: levelLayout, density: chartDensity },
                    };
                    localStorage.setItem('chanlun_config', JSON.stringify(config));
                } catch (e) {
                    debugError('Failed to save config:', e);
                }
            }, [stocks, indicators, chanConfig, theme, leftCollapsed, rightCollapsed, leftWidth, rightWidth, activeStockCode, activeLevels, levelLayout, chartDensity]);

            useEffect(() => {
                if (stocks.length === 0) {
                    if (activeStockCode !== null) {
                        setActiveStockCode(null);
                    }
                    return;
                }
                if (!activeStockCode || !stocks.some(stock => stock.code === activeStockCode)) {
                    setActiveStockCode(stocks[0].code);
                }
            }, [stocks, activeStockCode]);

            const analyzeStock = useCallback(async (code, level, forceRefresh = false) => {
                const key = `${code}-${level}`;

                if (!forceRefresh) {
                    const cachedData = DataCache.get(key);
                    if (cachedData) {
                        setChartData(prev => ({ ...prev, [key]: cachedData }));
                        return;
                    }
                }

                setLoadingCharts(prev => ({ ...prev, [key]: true }));

                try {
                    const params = {
                        code,
                        lv_list: [level],
                        data_src: 'BAO_STOCK',
                        ...indicators,
                        chan_config: chanConfig,
                    };
                    debugLog('üß™ ChanConfig snapshot', {
                        min_zs_cnt: chanConfig.min_zs_cnt,
                        bsp1_only_multibi_zs: chanConfig.bsp1_only_multibi_zs,
                        bs1_peak: chanConfig.bs1_peak,
                        bsp2_follow_1: chanConfig.bsp2_follow_1,
                        bsp3_follow_1: chanConfig.bsp3_follow_1,
                        bs_type: chanConfig.bs_type,
                        macd_algo: chanConfig.macd_algo,
                        max_bs2_rate: chanConfig.max_bs2_rate,
                        divergence_rate: chanConfig.divergence_rate,
                    });

                    const result = await api.calculateChan(params);
                    setChartData(prev => ({ ...prev, [key]: result }));
                    DataCache.set(key, result);
                } catch (error) {
                    debugError('Analysis failed:', error);
                    message.error(`${code} ${level} ÂàÜÊûêÂ§±Ë¥•: ${error.message}`);
                } finally {
                    setLoadingCharts(prev => ({ ...prev, [key]: false }));
                }
            }, [indicators, chanConfig]);

            const refreshAllCharts = useCallback(() => {
                if (!activeStock) {
                    message.info('ËØ∑ÈÄâÊã©ËÇ°Á•®ÂêéÂÜçÂà∑Êñ∞');
                    return;
                }
                DataCache.clear();
                activeLevels.forEach(level => analyzeStock(activeStock.code, level, true));
                message.info(`Ê≠£Âú®Âà∑Êñ∞ ${activeStock.code}...`);
            }, [activeStock, activeLevels, analyzeStock]);

            const prevIndicatorsRef = useRef(indicators);
            useEffect(() => {
                const prev = prevIndicatorsRef.current;
                const changed = ['plot_bi', 'plot_seg', 'plot_zs', 'plot_bsp', 'plot_ma', 'plot_macd', 'plot_boll', 'plot_kdj', 'plot_rsi', 'plot_volume', 'bsp_filters']
                    .some(key => prev[key] !== indicators[key]);

                if (changed && Object.keys(prev).length > 0 && activeStock) {
                    setTimeout(() => refreshAllCharts(), 100);
                }
                prevIndicatorsRef.current = indicators;
            }, [indicators, activeStock, refreshAllCharts]);

            useEffect(() => {
                if (indicators.indicator_layout !== 'tab') {
                    return;
                }
                const available = LOWER_INDICATOR_KEYS.filter(key => indicators[`plot_${key}`]);
                if (available.length === 0) {
                    if (indicators.indicator_tab) {
                        setIndicators(prev => ({ ...prev, indicator_tab: null }));
                    }
                    return;
                }
                if (!available.includes(indicators.indicator_tab)) {
                    setIndicators(prev => ({ ...prev, indicator_tab: available[0] }));
                }
            }, [indicators.indicator_layout, indicators.plot_macd, indicators.plot_kdj, indicators.plot_rsi, indicators.indicator_tab, setIndicators]);

            const prevChanConfigRef = useRef(chanConfig);
            useEffect(() => {
                if (prevChanConfigRef.current !== chanConfig && activeStock) {
                    debugLog('‚öôÔ∏è Chan config changed, refreshing charts...');
                    setTimeout(() => refreshAllCharts(), 120);
                }
                prevChanConfigRef.current = chanConfig;
            }, [chanConfig, activeStock, refreshAllCharts]);

            useEffect(() => {
                if (dragging) {
                    document.body.style.cursor = 'col-resize';
                } else {
                    document.body.style.cursor = '';
                }
                return () => {
                    document.body.style.cursor = '';
                };
            }, [dragging]);

            useEffect(() => {
                api.listAlertStrategies()
                    .then(res => setAlertStrategies(res.items || []))
                    .catch(err => debugWarn('‚ö†Ô∏è Failed to load alert strategies:', err));
            }, []);

            const addStock = useCallback((stockInfo = {}) => {
                const code = (stockInfo.code || '').trim();
                if (!code) {
                    message.warning('ËÇ°Á•®‰ª£Á†ÅÊó†Êïà');
                    return 'invalid';
                }

                const displayName = (stockInfo.name || '').trim();
                const existing = stocks.find(s => s.code === code);
                if (existing) {
                    if (displayName && displayName !== existing.name) {
                        setStocks(prev => prev.map(s => s.code === code ? { ...s, name: displayName } : s));
                        return 'updated';
                    }
                    return 'unchanged';
                }

                const newStock = {
                    id: Date.now() + Math.floor(Math.random() * 1000),
                    code,
                    name: displayName,
                };
                setStocks(prev => [...prev, newStock]);
                return 'new';
            }, [stocks]);

            const removeStock = useCallback((stockId) => {
                setStocks(prev => prev.filter(s => s.id !== stockId));
            }, []);

            const toggleLeftSidebar = () => setLeftCollapsed(prev => !prev);
            const toggleRightSidebar = () => setRightCollapsed(prev => !prev);

            const registerChartInstance = useCallback((key, entry) => {
                if (!key || !entry || !entry.chart || typeof entry.getIndexRange !== 'function') {
                    return;
                }
                chartRegistryRef.current.set(key, entry);
                debugLog('üìå [Registry] add', key, 'total:', chartRegistryRef.current.size);
                const latest = latestRangeRef.current;
                if (!latest || latest.sourceKey === key) {
                    if (latest) {
                        debugLog('‚ÑπÔ∏è [Registry] latest from', latest.sourceKey, 'skipped for', key);
                    }
                    return;
                }
                const range = entry.getIndexRange(latest.fromTs, latest.toTs);
                if (!Array.isArray(range)) {
                    debugWarn('‚ö†Ô∏è [Registry] no range when restoring', key, latest);
                    return;
                }
                const [fromIdx, toIdx] = range;
                if (!Number.isFinite(fromIdx) || !Number.isFinite(toIdx)) {
                    debugWarn('‚ö†Ô∏è [Registry] invalid range when restoring', key, range);
                    return;
                }
                try {
                    let applied = false;
                    if (typeof entry.applyIndexRange === 'function') {
                        applied = entry.applyIndexRange(fromIdx, toIdx, latest);
                    }
                    if (!applied) {
                        if (typeof entry.chart.scrollToDataIndex === 'function') {
                            if (typeof entry.suppressNextBroadcast === 'function') {
                                entry.suppressNextBroadcast();
                            }
                            entry.chart.scrollToDataIndex(Math.max(fromIdx, toIdx), 0);
                            applied = true;
                        } else if (typeof entry.chart.scrollToTimestamp === 'function' && Number.isFinite(latest.toTs)) {
                            if (typeof entry.suppressNextBroadcast === 'function') {
                                entry.suppressNextBroadcast();
                            }
                            entry.chart.scrollToTimestamp(latest.toTs, 0);
                            applied = true;
                        }
                    }
                    if (applied) {
                        debugLog('‚è™ [Registry] restore', key, { fromIdx, toIdx, fromTs: latest.fromTs, toTs: latest.toTs });
                    } else {
                        debugWarn('‚ö†Ô∏è [Registry] unable to apply synced range', key);
                    }
                } catch (err) {
                    debugWarn('‚ö†Ô∏è Failed to apply synced range on register', err);
                }
            }, []);

            const unregisterChartInstance = useCallback((key) => {
                chartRegistryRef.current.delete(key);
                debugLog('üóë [Registry] remove', key, 'total:', chartRegistryRef.current.size);
            }, []);

            const syncVisibleRange = useCallback((sourceKey, fromTs, toTs) => {
                if (!Number.isFinite(fromTs) || !Number.isFinite(toTs)) {
                    return;
                }
                if (syncLockRef.current) {
                    return;
                }
                syncLockRef.current = true;
                debugLog('üì° [Sync] broadcast', sourceKey, { fromTs, toTs });
                latestRangeRef.current = { sourceKey, fromTs, toTs };
                try {
                    chartRegistryRef.current.forEach((entry, key) => {
                        if (key === sourceKey) {
                            return;
                        }
                        if (!entry || !entry.chart) {
                            debugWarn('‚ö†Ô∏è [Sync] skip chart', key, 'missing instance');
                            return;
                        }
                        const range = entry.getIndexRange(fromTs, toTs);
                        if (!Array.isArray(range)) {
                            debugWarn('‚ö†Ô∏è [Sync] no range for target', key, { fromTs, toTs });
                            return;
                        }
                        const [fromIdx, toIdx] = range;
                        if (!Number.isFinite(fromIdx) || !Number.isFinite(toIdx)) {
                            debugWarn('‚ö†Ô∏è [Sync] invalid indices for target', key, range);
                            return;
                        }
                        try {
                            let applied = false;
                            if (typeof entry.applyIndexRange === 'function') {
                                applied = entry.applyIndexRange(fromIdx, toIdx, { fromTs, toTs, sourceKey });
                            }
                            if (!applied) {
                                if (typeof entry.chart.scrollToDataIndex === 'function') {
                                    if (typeof entry.suppressNextBroadcast === 'function') {
                                        entry.suppressNextBroadcast();
                                    }
                                    entry.chart.scrollToDataIndex(Math.max(fromIdx, toIdx), 0);
                                    applied = true;
                                } else if (typeof entry.chart.scrollToTimestamp === 'function' && Number.isFinite(toTs)) {
                                    if (typeof entry.suppressNextBroadcast === 'function') {
                                        entry.suppressNextBroadcast();
                                    }
                                    entry.chart.scrollToTimestamp(toTs, 0);
                                    applied = true;
                                }
                            }
                            if (applied) {
                                debugLog('üéØ [Sync] apply', key, { fromIdx, toIdx });
                            } else {
                                debugWarn('‚ö†Ô∏è [Sync] no method to apply range', key);
                            }
                        } catch (err) {
                            debugWarn('‚ö†Ô∏è Failed to sync visible range', err);
                        }
                    });
                } finally {
                    syncLockRef.current = false;
                }
            }, []);

            const startResize = useCallback((side) => (event) => {
                if (side === 'left' && leftCollapsed) return;
                if (side === 'right' && rightCollapsed) return;
                if (!layoutRef.current) return;
                event.preventDefault();
                setDragging(side);

                const handleMove = (e) => {
                    if (!layoutRef.current) return;
                    const currentRect = layoutRef.current.getBoundingClientRect();
                    const minMain = 400;
                    const currentLeftWidth = leftCollapsed ? 0 : (layoutRef.current.querySelector('.left-sidebar')?.getBoundingClientRect().width || leftWidth);
                    const currentRightWidth = rightCollapsed ? 0 : (layoutRef.current.querySelector('.right-sidebar')?.getBoundingClientRect().width || rightWidth);
                    if (side === 'left') {
                        const maxLeft = currentRect.width - currentRightWidth - minMain;
                        const newWidth = clamp(e.clientX - currentRect.left, 200, Math.max(200, maxLeft));
                        setLeftWidth(newWidth);
                    } else {
                        const maxRight = currentRect.width - currentLeftWidth - minMain;
                        const newWidth = clamp(currentRect.right - e.clientX, 220, Math.max(220, maxRight));
                        setRightWidth(newWidth);
                    }
                };

                const handleUp = () => {
                    setDragging(null);
                    window.removeEventListener('mousemove', handleMove);
                    window.removeEventListener('mouseup', handleUp);
                };

                window.addEventListener('mousemove', handleMove);
                window.addEventListener('mouseup', handleUp);
            }, [leftCollapsed, rightCollapsed, rightWidth, leftWidth]);

            const refreshAlertHistory = useCallback(async () => {
                try {
                    const result = await api.getAlertHistory(50);
                    setAlertHistory(Array.isArray(result.items) ? result.items.slice(0, ALERT_HISTORY_LIMIT) : []);
                    setAlertError(null);
                } catch (error) {
                    debugError('‚ö†Ô∏è Failed to fetch alert history:', error);
                    setAlertError('Êó†Ê≥ïËé∑ÂèñÊä•Ë≠¶ÂéÜÂè≤');
                }
            }, []);

            useEffect(() => {
                refreshAlertHistory();
                let shouldReconnect = true;
                const wsUrl = `${API_BASE.replace(/^http/, 'ws')}/api/alerts/stream`;

                const connect = () => {
                    const ws = new WebSocket(wsUrl);
                    alertWsRef.current = ws;

                    ws.onopen = () => {
                        setAlertConnected(true);
                        setAlertError(null);
                    };

                    ws.onmessage = (event) => {
                        try {
                            const payload = JSON.parse(event.data);
                            if (payload.type === 'history') {
                                if (Array.isArray(payload.data)) {
                                    setAlertHistory(payload.data.slice(0, ALERT_HISTORY_LIMIT));
                                }
                            } else if (payload.type === 'alert' && payload.data) {
                                setAlertHistory(prev => {
                                    const next = [payload.data, ...prev];
                                    return next.slice(0, ALERT_HISTORY_LIMIT);
                                });
                            }
                        } catch (err) {
                            debugError('‚ö†Ô∏è Failed to parse alert payload:', err);
                        }
                    };

                    ws.onerror = () => {
                        setAlertError('ÂÆûÊó∂ËøûÊé•ÂºÇÂ∏∏');
                    };

                    ws.onclose = () => {
                        setAlertConnected(false);
                        if (shouldReconnect) {
                            reconnectTimerRef.current = setTimeout(connect, 5000);
                        }
                    };
                };

                connect();

                return () => {
                    shouldReconnect = false;
                    if (alertWsRef.current) {
                        alertWsRef.current.close();
                        alertWsRef.current = null;
                    }
                    if (reconnectTimerRef.current) {
                        clearTimeout(reconnectTimerRef.current);
                        reconnectTimerRef.current = null;
                    }
                };
            }, [refreshAlertHistory]);

            const contextValue = {
                stocks,
                addStock,
                removeStock,
                activeStock,
                activeStockCode,
                setActiveStockCode,
                activeLevels,
                setActiveLevels,
                levelLayout,
                setLevelLayout,
                chartDensity,
                setChartDensity,
                indicators,
                setIndicators,
                chanConfig,
                setChanConfig,
                chartData,
                loadingCharts,
                analyzeStock,
                refreshAllCharts,
                registerChartInstance,
                unregisterChartInstance,
                syncVisibleRange,
                chartFocusRequest,
                requestChartFocus,
                acknowledgeChartFocus,
                theme,
                alertHistory,
                alertConnected,
                alertError,
                alertStrategies,
                refreshAlertHistory,
            };

            return (
                <AppContext.Provider value={contextValue}>
                    <Layout ref={layoutRef} className={`app-layout ${theme === 'dark' ? 'dark-theme' : ''}`}>
                        <Header className="app-header">
                            <div className="app-logo">
                                <span>üìà</span>
                                <span>Áº†ËÆ∫Âú®Á∫øÂàÜÊûêÁ≥ªÁªü (KLineChartÁâà)</span>
                            </div>
                            <div className="app-header-actions">
                                <Tooltip title={leftCollapsed ? 'Â±ïÂºÄËá™ÈÄâÈù¢Êùø' : 'Êî∂Ëµ∑Ëá™ÈÄâÈù¢Êùø'}>
                                    <Button size="small" onClick={toggleLeftSidebar}>
                                        {leftCollapsed ? 'üìÇ Â±ïÂºÄ' : 'üìÅ Êî∂Ëµ∑'}
                                    </Button>
                                </Tooltip>
                                <Tooltip title={debugLogging ? 'ÂÖ≥Èó≠Ë∞ÉËØïÊó•ÂøóÔºàÂà∑Êñ∞Âêé‰øùÁïôÔºâ' : 'ÂºÄÂêØË∞ÉËØïÊó•ÂøóÔºàÂà∑Êñ∞Âêé‰øùÁïôÔºâ'}>
                                    <Button
                                        size="small"
                                        type={debugLogging ? 'primary' : 'default'}
                                        onClick={toggleDebugLogging}
                                    >
                                        {debugLogging ? 'üìù Ë∞ÉËØïÂºÄ' : 'üìù Ë∞ÉËØïÂÖ≥'}
                                    </Button>
                                </Tooltip>
                                <Tooltip title="ÂàáÊç¢‰∏ªÈ¢ò">
                                    <Button
                                        size="small"
                                        onClick={() => setTheme(prev => prev === 'light' ? 'dark' : 'light')}
                                    >
                                        {theme === 'light' ? 'üåô' : '‚òÄÔ∏è'}
                                    </Button>
                                </Tooltip>
                                <Tooltip title="Âà∑Êñ∞ÊâÄÊúâÂõæË°®">
                                    <Button size="small" onClick={refreshAllCharts}>
                                        üîÑ Âà∑Êñ∞
                                    </Button>
                                </Tooltip>
                                <Tooltip title="Ê∏ÖÁ©∫ÊâÄÊúâËÇ°Á•®">
                                    <Button size="small" danger onClick={() => setStocks([])}>
                                        Ê∏ÖÁ©∫
                                    </Button>
                                </Tooltip>
                                <Tooltip title={rightCollapsed ? 'Â±ïÂºÄÊåáÊ†áÈÖçÁΩÆ' : 'Êî∂Ëµ∑ÊåáÊ†áÈÖçÁΩÆ'}>
                                    <Button size="small" onClick={toggleRightSidebar}>
                                        {rightCollapsed ? 'üõ† Â±ïÂºÄ' : 'üõ† Êî∂Ëµ∑'}
                                    </Button>
                                </Tooltip>
                            </div>
                        </Header>
                        <div className="app-content">
                            {!leftCollapsed && (
                                <>
                                    <div className="sidebar left-sidebar" style={{ width: leftWidth }}>
                                        <StockManager />
                                    </div>
                                    <div
                                        className={`sidebar-resizer ${dragging === 'left' ? 'dragging' : ''}`}
                                        onMouseDown={startResize('left')}
                                    />
                                </>
                            )}
                            <div className="main-content">
                                <ChartGrid />
                            </div>
                            {!rightCollapsed && (
                                <>
                                    <div
                                        className={`sidebar-resizer ${dragging === 'right' ? 'dragging' : ''}`}
                                        onMouseDown={startResize('right')}
                                    />
                                    <div className="sidebar right-sidebar" style={{ width: rightWidth }}>
                                        <RightSidebar />
                                    </div>
                                </>
                            )}
                        </div>
                    </Layout>
                </AppContext.Provider>
            );
        };

        // Render app
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
