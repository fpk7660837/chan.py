<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>Áº†ËÆ∫ÂàÜÊûêÂπ≥Âè∞ - Chan Theory Analysis</title>
    
    <!-- Vue 3 -->
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    
    <!-- Element Plus -->
    <link rel="stylesheet" href="https://unpkg.com/element-plus/dist/index.css">
    <script src="https://unpkg.com/element-plus"></script>
    
    <!-- TradingView Lightweight Charts - ‰ΩøÁî®Á®≥ÂÆöÁâàÊú¨3.8.0 -->
    <script src="https://unpkg.com/lightweight-charts@3.8.0/dist/lightweight-charts.standalone.production.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei", sans-serif;
            background: #ffffff;
            color: #333333;
        }
        
        #app {
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }
        
        /* Header */
        .header {
            background: linear-gradient(135deg, #1e3a8a 0%, #7c3aed 100%);
            padding: 20px 30px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            position: sticky;
            top: 0;
            z-index: 1000;
        }
        
        .header-content {
            max-width: 1800px;
            margin: 0 auto;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        .logo {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        .logo-icon {
            font-size: 36px;
        }
        
        .logo-text h1 {
            font-size: 24px;
            font-weight: 600;
            color: white;
            margin: 0;
        }
        
        .logo-text p {
            font-size: 12px;
            color: rgba(255,255,255,0.8);
            margin: 0;
        }
        
        /* Main Content */
        .main-content {
            flex: 1;
            max-width: 1800px;
            width: 100%;
            margin: 0 auto;
            padding: 20px;
            display: flex;
            gap: 20px;
            background: #f5f5f5;
        }
        
        /* Left Panel - Controls */
        .left-panel {
            width: 320px;
            background: #ffffff;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.06);
            max-height: calc(100vh - 140px);
            overflow-y: auto;
            border: 1px solid #e5e7eb;
        }
        
        .left-panel::-webkit-scrollbar {
            width: 6px;
        }
        
        .left-panel::-webkit-scrollbar-thumb {
            background: #d1d5db;
            border-radius: 3px;
        }
        
        /* Right Panel - Chart */
        .right-panel {
            flex: 1;
            background: #ffffff;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.06);
            display: flex;
            flex-direction: column;
            border: 1px solid #e5e7eb;
        }
        
        .panel-title {
            font-size: 16px;
            font-weight: 600;
            color: #1f2937;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid #e5e7eb;
        }
        
        /* Chart Container */
        #chart-container {
            flex: 1;
            position: relative;
            min-height: 600px;
        }
        
        #tradingview-chart {
            width: 100%;
            height: 100%;
            min-height: 600px;
        }
        
        /* MACD Chart Container */
        #macd-container {
            margin-top: 20px;
            min-height: 200px;
            position: relative;
        }
        
        #macd-chart {
            width: 100%;
            height: 200px;
        }
        
        /* Stats Bar */
        .stats-bar {
            display: flex;
            gap: 20px;
            padding: 15px;
            background: #f9fafb;
            border-radius: 6px;
            margin-bottom: 15px;
            flex-wrap: wrap;
            border: 1px solid #e5e7eb;
        }
        
        .stat-item {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        
        .stat-label {
            font-size: 12px;
            color: #6b7280;
        }
        
        .stat-value {
            font-size: 18px;
            font-weight: 600;
            color: #2962ff;
        }
        
        /* Form Styling */
        .el-input__wrapper {
            background: #ffffff !important;
            box-shadow: none !important;
            border: 1px solid #d1d5db !important;
        }
        
        .el-input__inner {
            color: #1f2937 !important;
        }
        
        .el-select {
            width: 100%;
        }
        
        .el-select .el-input__wrapper {
            background: #ffffff !important;
        }
        
        .el-date-editor {
            width: 100%;
        }
        
        .el-form-item__label {
            color: #374151 !important;
            font-weight: 500;
        }
        
        .el-checkbox__label {
            color: #374151 !important;
        }
        
        .el-button--primary {
            background: linear-gradient(135deg, #2962ff 0%, #7c3aed 100%);
            border: none;
            font-weight: 600;
        }
        
        .el-button--primary:hover {
            background: linear-gradient(135deg, #1e4ed8 0%, #6d28d9 100%);
        }
        
        /* Loading */
        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 255, 255, 0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
            border-radius: 8px;
        }
        
        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 4px solid #e5e7eb;
            border-top: 4px solid #2962ff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .loading-text {
            margin-top: 20px;
            font-size: 14px;
            color: #6b7280;
        }
        
        /* Legend */
        .legend {
            display: flex;
            gap: 20px;
            margin-top: 15px;
            padding: 12px;
            background: #f9fafb;
            border-radius: 6px;
            flex-wrap: wrap;
            border: 1px solid #e5e7eb;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 13px;
            color: #374151;
        }
        
        .legend-color {
            width: 20px;
            height: 3px;
            border-radius: 2px;
        }
        
        /* Empty State */
        .empty-state {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: #9ca3af;
            padding: 60px 20px;
        }
        
        .empty-icon {
            font-size: 80px;
            margin-bottom: 20px;
            opacity: 0.3;
        }
        
        .empty-text {
            font-size: 16px;
            margin-bottom: 8px;
            color: #6b7280;
        }
        
        .empty-hint {
            font-size: 13px;
            color: #9ca3af;
        }
    </style>
</head>
<body>
    <div id="app">
        <!-- Header -->
        <div class="header">
            <div class="header-content">
                <div class="logo">
                    <div class="logo-icon">üìà</div>
                    <div class="logo-text">
                        <h1>Áº†ËÆ∫ÂàÜÊûêÂπ≥Âè∞</h1>
                        <p>Chan Theory Analysis Platform ¬∑ AËÇ°ÂÆûÊó∂ÂàÜÊûê</p>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Main Content -->
        <div class="main-content">
            <!-- Left Panel - Controls -->
            <div class="left-panel">
                <div class="panel-title">üìä ÂàÜÊûêÂèÇÊï∞</div>
                
                <el-form :model="form" label-position="top" size="default">
                    <!-- Stock Code -->
                    <el-form-item label="ËÇ°Á•®‰ª£Á†Å">
                        <el-input 
                            v-model="form.code" 
                            placeholder="Â¶Ç: sz.000001 Êàñ sh.600000"
                            clearable>
                            <template #prefix>üîç</template>
                        </el-input>
                    </el-form-item>
                    
                    <!-- Date Range -->
                    <el-form-item label="ÂºÄÂßãÊó•Êúü">
                        <el-date-picker 
                            v-model="form.begin_time" 
                            type="date" 
                            placeholder="ÈÄâÊã©ÂºÄÂßãÊó•Êúü"
                            style="width: 100%;">
                        </el-date-picker>
                    </el-form-item>
                    
                    <!-- Data Source -->
                    <el-form-item label="Êï∞ÊçÆÊ∫ê">
                        <el-select v-model="form.data_src">
                            <el-option label="BaoStock (AËÇ°)" value="BAO_STOCK"></el-option>
                            <el-option label="Êú¨Âú∞CSV" value="CSV"></el-option>
                        </el-select>
                    </el-form-item>
                    
                    <!-- K-line Level -->
                    <el-form-item label="KÁ∫øÁ∫ßÂà´">
                        <el-select v-model="form.lv_list" multiple collapse-tags>
                            <el-option label="Êó•Á∫ø" value="day"></el-option>
                            <el-option label="60ÂàÜÈíü" value="60m"></el-option>
                            <el-option label="30ÂàÜÈíü" value="30m"></el-option>
                            <el-option label="15ÂàÜÈíü" value="15m"></el-option>
                            <el-option label="5ÂàÜÈíü" value="5m"></el-option>
                        </el-select>
                    </el-form-item>
                    
                    <!-- Seg Algorithm -->
                    <el-form-item label="Á∫øÊÆµÁÆóÊ≥ï">
                        <el-select v-model="form.seg_algo">
                            <el-option label="Áº†ËÆ∫ÁâπÂæÅÂ∫èÂàó" value="chan"></el-option>
                            <el-option label="Á¨îÁ†¥Âùè" value="break"></el-option>
                            <el-option label="1+1ÁªàÁªì" value="1+1"></el-option>
                        </el-select>
                    </el-form-item>
                    
                    <!-- ZhongShu Algorithm -->
                    <el-form-item label="‰∏≠Êû¢ÁÆóÊ≥ï">
                        <el-select v-model="form.zs_algo">
                            <el-option label="ÊÆµÂÜÖ‰∏≠Êû¢" value="normal"></el-option>
                            <el-option label="Ë∑®ÊÆµ‰∏≠Êû¢" value="over_seg"></el-option>
                            <el-option label="Ëá™Âä®" value="auto"></el-option>
                        </el-select>
                    </el-form-item>
                    
                    <!-- Display Options -->
                    <el-form-item label="ÊòæÁ§∫ÂÖÉÁ¥†">
                        <el-checkbox-group v-model="form.plotOptions">
                            <el-checkbox label="bi">Á¨î (Bi)</el-checkbox>
                            <el-checkbox label="seg">Á∫øÊÆµ (Seg)</el-checkbox>
                            <el-checkbox label="zs">‰∏≠Êû¢ (ZS)</el-checkbox>
                            <el-checkbox label="bsp">‰π∞ÂçñÁÇπ (BSP)</el-checkbox>
                        </el-checkbox-group>
                    </el-form-item>
                    
                    <!-- Action Buttons -->
                    <el-form-item>
                        <el-button 
                            type="primary" 
                            @click="analyze" 
                            :loading="loading" 
                            style="width: 100%; height: 44px; font-size: 15px;">
                            <span v-if="!loading">üöÄ ÂºÄÂßãÂàÜÊûê</span>
                            <span v-else>ÂàÜÊûê‰∏≠...</span>
                        </el-button>
                    </el-form-item>
                </el-form>
            </div>
            
            <!-- Right Panel - Chart -->
            <div class="right-panel">
                <div class="panel-title">üìâ KÁ∫øÂõæË°®‰∏éÁº†ËÆ∫ÊåáÊ†á</div>
                
                <!-- Stats Bar -->
                <div v-if="stats" class="stats-bar">
                    <div class="stat-item">
                        <div class="stat-label">KÁ∫øÊï∞Èáè</div>
                        <div class="stat-value">{{ stats.total_klines }}</div>
                    </div>
                    <div class="stat-item" v-if="stats.bi_count !== undefined">
                        <div class="stat-label">Á¨î</div>
                        <div class="stat-value" style="color: #2196f3;">{{ stats.bi_count }}</div>
                    </div>
                    <div class="stat-item" v-if="stats.seg_count !== undefined">
                        <div class="stat-label">Á∫øÊÆµ</div>
                        <div class="stat-value" style="color: #9c27b0;">{{ stats.seg_count }}</div>
                    </div>
                    <div class="stat-item" v-if="stats.zs_count !== undefined">
                        <div class="stat-label">‰∏≠Êû¢</div>
                        <div class="stat-value" style="color: #ff9800;">{{ stats.zs_count }}</div>
                    </div>
                    <div class="stat-item" v-if="stats.bsp_count !== undefined">
                        <div class="stat-label">‰π∞ÂçñÁÇπ</div>
                        <div class="stat-value" style="color: #f44336;">{{ stats.bsp_count }}</div>
                    </div>
                </div>
                
                <!-- Chart Container -->
                <div id="chart-container">
                    <div v-if="loading" class="loading-overlay">
                        <div class="loading-spinner"></div>
                        <div class="loading-text">Ê≠£Âú®ËÆ°ÁÆóÁº†ËÆ∫ÊåáÊ†á...</div>
                    </div>
                    
                    <div v-if="!chartData && !loading" class="empty-state">
                        <div class="empty-icon">üìä</div>
                        <div class="empty-text">ÊöÇÊó†Êï∞ÊçÆ</div>
                        <div class="empty-hint">ËØ∑ËæìÂÖ•ËÇ°Á•®‰ª£Á†ÅÂπ∂ÁÇπÂáª"ÂºÄÂßãÂàÜÊûê"</div>
                    </div>
                    
                    <div id="tradingview-chart" v-show="chartData && !loading"></div>
                    
                    <!-- MACD Chart -->
                    <div id="macd-container" v-show="chartData && !loading">
                        <div id="macd-chart"></div>
                    </div>
                </div>
                
                <!-- Legend -->
                <div v-if="chartData" class="legend">
                    <div class="legend-item" v-if="form.plotOptions.includes('bi')">
                        <div class="legend-color" style="background: #2196f3;"></div>
                        <span>Á¨î (Bi)</span>
                    </div>
                    <div class="legend-item" v-if="form.plotOptions.includes('seg')">
                        <div class="legend-color" style="background: #9c27b0; height: 4px;"></div>
                        <span>Á∫øÊÆµ (Seg)</span>
                    </div>
                    <div class="legend-item" v-if="form.plotOptions.includes('zs')">
                        <div class="legend-color" style="background: #ff9800; height: 8px;"></div>
                        <span>‰∏≠Êû¢ (ZS)</span>
                    </div>
                    <div class="legend-item" v-if="form.plotOptions.includes('bsp')">
                        <div class="legend-color" style="background: #f44336;"></div>
                        <span>‰π∞ÁÇπ</span>
                    </div>
                    <div class="legend-item" v-if="form.plotOptions.includes('bsp')">
                        <div class="legend-color" style="background: #4caf50;"></div>
                        <span>ÂçñÁÇπ</span>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        const { createApp } = Vue;
        
        createApp({
            data() {
                return {
                    form: {
                        code: 'sz.000001',
                        begin_time: new Date('2023-01-01'),
                        data_src: 'BAO_STOCK',
                        lv_list: ['day'],
                        seg_algo: 'chan',
                        zs_algo: 'normal',
                        bi_strict: true,
                        plotOptions: ['bi', 'seg', 'zs', 'bsp']
                    },
                    loading: false,
                    stats: null,
                    chartData: null,
                    chart: null,
                    macdChart: null,
                    series: {},
                    apiBase: 'http://localhost:8000'
                }
            },
            methods: {
                async analyze() {
                    if (!this.form.code) {
                        ElementPlus.ElMessage.warning('ËØ∑ËæìÂÖ•ËÇ°Á•®‰ª£Á†Å');
                        return;
                    }
                    
                    this.loading = true;
                    this.chartData = null;
                    
                    try {
                        const beginTime = this.form.begin_time.toISOString().split('T')[0];
                        
                        const request = {
                            code: this.form.code,
                            begin_time: beginTime,
                            end_time: null,
                            data_src: this.form.data_src,
                            lv_list: this.form.lv_list,
                            seg_algo: this.form.seg_algo,
                            zs_algo: this.form.zs_algo,
                            bi_strict: this.form.bi_strict,
                            plot_bi: this.form.plotOptions.includes('bi'),
                            plot_seg: this.form.plotOptions.includes('seg'),
                            plot_zs: this.form.plotOptions.includes('zs'),
                            plot_bsp: this.form.plotOptions.includes('bsp'),
                            plot_macd: true  // Always show MACD
                        };
                        
                        console.log('üì§ Sending request with lv_list:', request.lv_list);
                        
                        const response = await fetch(`${this.apiBase}/api/analysis/calculate`, {
                            method: 'POST',
                            headers: {'Content-Type': 'application/json'},
                            body: JSON.stringify(request)
                        });
                        
                        if (!response.ok) {
                            const error = await response.json();
                            throw new Error(error.detail || 'Analysis failed');
                        }
                        
                        this.chartData = await response.json();
                        this.stats = this.chartData.meta;
                        
                        console.log('üì¶ Chart data received:', {
                            hasData: !!this.chartData,
                            klines: this.chartData.kline_data?.length || 0,
                            bis: this.chartData.bi_list?.length || 0,
                            segs: this.chartData.seg_list?.length || 0,
                            bsps: this.chartData.bsp_list?.length || 0,
                            macd: this.chartData.macd_data?.length || 0
                        });
                        
                        // Log sample raw data
                        if (this.chartData.kline_data?.length > 0) {
                            console.log('üîç Sample raw K-line data (first 2):', this.chartData.kline_data.slice(0, 2));
                        }
                        if (this.chartData.bi_list?.length > 0) {
                            console.log('üîç Sample raw Bi data (first 2):', this.chartData.bi_list.slice(0, 2));
                        }
                        if (this.chartData.macd_data?.length > 0) {
                            console.log('üîç Sample raw MACD data (first 2):', this.chartData.macd_data.slice(0, 2));
                        }
                        
                        // Wait for Vue to update DOM
                        await this.$nextTick();
                        
                        // Give additional time for v-show to take effect
                        await new Promise(resolve => setTimeout(resolve, 100));
                        
                        console.log('üéØ About to render chart...');
                        this.renderChart();
                        
                        ElementPlus.ElMessage.success('ÂàÜÊûêÂÆåÊàêÔºÅ');
                        
                    } catch (error) {
                        console.error(error);
                        ElementPlus.ElMessage.error('ÂàÜÊûêÂ§±Ë¥•: ' + error.message);
                    } finally {
                        this.loading = false;
                    }
                },
                
                renderChart() {
                    // Check if LightweightCharts is loaded
                    if (typeof LightweightCharts === 'undefined') {
                        console.error('‚ùå LightweightCharts is not loaded!');
                        ElementPlus.ElMessage.error('ÂõæË°®Â∫ìÂä†ËΩΩÂ§±Ë¥•ÔºåËØ∑Âà∑Êñ∞È°µÈù¢ÈáçËØï');
                        return;
                    }
                    
                    console.log('‚úÖ LightweightCharts loaded:', typeof LightweightCharts);
                    console.log('‚úÖ LightweightCharts.createChart:', typeof LightweightCharts.createChart);
                    
                    const container = document.getElementById('tradingview-chart');
                    if (!container || !this.chartData) {
                        console.log('‚ùå Cannot render chart:', { 
                            container: !!container, 
                            chartData: !!this.chartData 
                        });
                        return;
                    }
                    
                    console.log('üìä Rendering chart with data:', {
                        klines: this.chartData.kline_data?.length,
                        bis: this.chartData.bi_list?.length,
                        segs: this.chartData.seg_list?.length,
                        containerWidth: container.clientWidth,
                        containerHeight: container.clientHeight
                    });
                    
                    // Clear existing chart
                    if (this.chart) {
                        this.chart.remove();
                        this.chart = null;
                    }
                    container.innerHTML = '';
                    
                    // Get container dimensions
                    const width = container.clientWidth || container.parentElement.clientWidth || 1000;
                    const height = 600;
                    
                    console.log('üìè Chart dimensions:', { width, height });
                    
                    // Create chart with white theme
                    this.chart = LightweightCharts.createChart(container, {
                        width: width,
                        height: height,
                        layout: {
                            background: { color: '#ffffff' },
                            textColor: '#333333',
                        },
                        grid: {
                            vertLines: { color: '#e5e7eb' },
                            horzLines: { color: '#e5e7eb' },
                        },
                        crosshair: {
                            mode: LightweightCharts.CrosshairMode.Normal,
                        },
                        rightPriceScale: {
                            borderColor: '#d1d5db',
                        },
                        timeScale: {
                            borderColor: '#d1d5db',
                            timeVisible: true,
                            secondsVisible: true,
                        },
                        localization: {
                            timeFormatter: (timestamp) => {
                                // timestamp is Unix timestamp in seconds
                                const date = new Date(timestamp * 1000);
                                // Format as China time (should already be in local timezone)
                                const hours = String(date.getHours()).padStart(2, '0');
                                const minutes = String(date.getMinutes()).padStart(2, '0');
                                const month = date.getMonth() + 1;
                                const day = date.getDate();
                                return `${month}/${day} ${hours}:${minutes}`;
                            },
                        },
                    });
                    
                    console.log('‚úÖ Chart created successfully');
                    console.log('üìã Chart object type:', typeof this.chart);
                    console.log('üìã Chart methods:', Object.keys(this.chart));
                    console.log('üìã Has addCandlestickSeries?', typeof this.chart.addCandlestickSeries);
                    
                    // Add candlestick series
                    const candlestickSeries = this.chart.addCandlestickSeries({
                        upColor: '#ef5350',
                        downColor: '#26a69a',
                        borderVisible: false,
                        wickUpColor: '#ef5350',
                        wickDownColor: '#26a69a',
                    });
                    
                    // Prepare candlestick data - convert time format based on K-line type
                    const candleData = [];
                    
                    // Debug: log first raw K-line time
                    if (this.chartData.kline_data.length > 0) {
                        const firstKl = this.chartData.kline_data[0];
                        console.log('üïê Raw time from backend:', firstKl.time);
                        const convertedTime = this.convertTime(firstKl.time);
                        console.log('üïê Converted time:', convertedTime);
                        console.log('üïê Converted time type:', typeof convertedTime);
                        if (typeof convertedTime === 'number') {
                            const date = new Date(convertedTime * 1000);
                            console.log('üïê Date object (browser timezone):', date.toString());
                            console.log('üïê Date UTC:', date.toUTCString());
                            console.log('üïê Date China (UTC+8):', new Date(date.getTime() + 8*60*60*1000).toUTCString());
                        }
                    }
                    
                    this.chartData.kline_data.forEach(kl => {
                        // Check null/undefined BEFORE parseFloat
                        if (!kl.time || 
                            kl.open === null || kl.open === undefined ||
                            kl.high === null || kl.high === undefined ||
                            kl.low === null || kl.low === undefined ||
                            kl.close === null || kl.close === undefined) {
                            return;
                        }
                        
                        // Convert time based on K-line type
                        let time;
                        const timeStr = kl.time.replace(/\//g, '-'); // 2023/01/03 09:30 ‚Üí 2023-01-03 09:30
                        
                        // Check if it's a day-level K-line (no time part or time is 00:00)
                        if (!timeStr.includes(' ') || timeStr.includes(' 00:00')) {
                            // Day-level: use date string format YYYY-MM-DD
                            time = timeStr.split(' ')[0];
                        } else {
                            // Minute-level: convert to Unix timestamp (seconds)
                            time = Math.floor(new Date(timeStr).getTime() / 1000);
                        }
                        
                        const open = parseFloat(kl.open);
                        const high = parseFloat(kl.high);
                        const low = parseFloat(kl.low);
                        const close = parseFloat(kl.close);
                        
                        // Check if valid numbers
                        if (isNaN(open) || isNaN(high) || isNaN(low) || isNaN(close)) {
                            console.warn('‚ö†Ô∏è  Filtered invalid K-line:', { time, open, high, low, close });
                            return;
                        }
                        
                        // For minute-level, also check if timestamp is valid
                        if (typeof time === 'number' && (isNaN(time) || time <= 0)) {
                            console.warn('‚ö†Ô∏è  Invalid timestamp:', timeStr);
                            return;
                        }
                        
                        candleData.push({ time, open, high, low, close });
                    });
                    
                    // Sort by time (works for both string dates and timestamps)
                    candleData.sort((a, b) => {
                        if (typeof a.time === 'string') {
                            return a.time < b.time ? -1 : a.time > b.time ? 1 : 0;
                        } else {
                            return a.time - b.time;
                        }
                    });
                    
                    const timeFormat = typeof candleData[0]?.time === 'string' ? 'Date String (Day)' : 'Unix Timestamp (Minute)';
                    
                    console.log('üìà K-line data processing:');
                    console.log(`  - Total: ${candleData.length} K-lines`);
                    console.log(`  - Time format: ${timeFormat}`);
                    console.log('First candle:', candleData[0]);
                    console.log('Last candle:', candleData[candleData.length - 1]);
                    
                    // Debug: Check what time Lightweight Charts will display
                    if (candleData[0] && typeof candleData[0].time === 'number') {
                        const firstTimestamp = candleData[0].time;
                        const date = new Date(firstTimestamp * 1000);
                        console.log('üïê First K-line timestamp:', firstTimestamp);
                        console.log('üïê Browser will display:', date.toString());
                        console.log('üïê Expected display time:', `${date.getMonth()+1}/${date.getDate()} ${String(date.getHours()).padStart(2,'0')}:${String(date.getMinutes()).padStart(2,'0')}`);
                    }
                    
                    // Check for any null values in sample data
                    console.log('üîç Checking sample K-line data for null values...');
                    const sampleCandles = candleData.slice(0, 5);
                    sampleCandles.forEach((c, i) => {
                        console.log(`  Candle ${i}:`, {
                            time: c.time,
                            open: c.open,
                            high: c.high,
                            low: c.low,
                            close: c.close,
                            hasNull: Object.values(c).some(v => v === null || v === undefined || (typeof v === 'number' && isNaN(v)))
                        });
                    });
                    
                    candlestickSeries.setData(candleData);
                    console.log('‚úÖ K-line data set successfully');
                    
                    // Add Bi lines
                    if (this.form.plotOptions.includes('bi') && this.chartData.bi_list) {
                        this.addBiLines();
                    }
                    
                    // Add Seg lines
                    if (this.form.plotOptions.includes('seg') && this.chartData.seg_list) {
                        this.addSegLines();
                    }
                    
                    // Add markers for buy/sell points
                    if (this.form.plotOptions.includes('bsp') && this.chartData.bsp_list) {
                        this.addBspMarkers(candlestickSeries);
                    }
                    
                    // Fit content
                    this.chart.timeScale().fitContent();
                    
                    // Render MACD chart
                    this.renderMacdChart();
                    
                    // Handle resize
                    const resizeHandler = () => {
                        if (this.chart && container) {
                            this.chart.applyOptions({ width: container.clientWidth });
                        }
                        if (this.macdChart) {
                            const macdContainer = document.getElementById('macd-chart');
                            if (macdContainer) {
                                this.macdChart.applyOptions({ width: macdContainer.clientWidth || container.clientWidth });
                            }
                        }
                    };
                    
                    // Remove old listener if exists
                    window.removeEventListener('resize', this.resizeHandler);
                    this.resizeHandler = resizeHandler;
                    window.addEventListener('resize', this.resizeHandler);
                },
                
                convertTime(timeStr) {
                    // Helper function to convert time based on K-line type
                    const normalized = timeStr.replace(/\//g, '-');
                    
                    // Check if it's day-level K-line
                    if (!normalized.includes(' ') || normalized.includes(' 00:00')) {
                        return normalized.split(' ')[0]; // Date string
                    } else {
                        // Minute-level: convert to Unix timestamp (seconds) with China timezone (UTC+8)
                        // Parse as China time (local interpretation as UTC+8)
                        const [datePart, timePart] = normalized.split(' ');
                        const [year, month, day] = datePart.split('-').map(Number);
                        const [hour, minute, second = 0] = timePart.split(':').map(Number);
                        
                        // Create date in UTC, then subtract 8 hours to get correct timestamp
                        // (because we want to treat the input as UTC+8)
                        const utcDate = Date.UTC(year, month - 1, day, hour, minute, second);
                        const chinaOffset = 8 * 60 * 60 * 1000; // 8 hours in milliseconds
                        const timestamp = Math.floor((utcDate - chinaOffset) / 1000);
                        
                        return timestamp;
                    }
                },
                
                addBiLines() {
                    console.log('üìä Adding Bi lines:', this.chartData.bi_list.length);
                    for (let i = 0; i < this.chartData.bi_list.length; i++) {
                        const bi = this.chartData.bi_list[i];
                        
                        // Validate bi data - check null/undefined FIRST, then NaN
                        if (!bi.begin_time || !bi.end_time || 
                            bi.begin_price === null || bi.begin_price === undefined ||
                            bi.end_price === null || bi.end_price === undefined ||
                            isNaN(parseFloat(bi.begin_price)) || isNaN(parseFloat(bi.end_price))) {
                            console.warn('‚ö†Ô∏è  Skipping invalid Bi:', bi);
                            continue;
                        }
                        
                        const beginPrice = parseFloat(bi.begin_price);
                        const endPrice = parseFloat(bi.end_price);
                        const beginTime = this.convertTime(bi.begin_time);
                        const endTime = this.convertTime(bi.end_time);
                        
                        // Double check after conversion
                        if ((typeof beginTime === 'string' && !beginTime) || 
                            (typeof endTime === 'string' && !endTime) ||
                            (typeof beginTime === 'number' && (isNaN(beginTime) || beginTime <= 0)) ||
                            (typeof endTime === 'number' && (isNaN(endTime) || endTime <= 0)) ||
                            isNaN(beginPrice) || isNaN(endPrice)) {
                            console.warn('‚ö†Ô∏è  Skipping invalid Bi after conversion:', { beginTime, endTime, beginPrice, endPrice });
                            continue;
                        }
                        
                        const biData = [
                            { time: beginTime, value: beginPrice },
                            { time: endTime, value: endPrice }
                        ];
                        
                        console.log(`  üìç Bi ${i}:`, {
                            beginTime, beginPrice, 
                            endTime, endPrice,
                            hasNull: beginTime === null || beginPrice === null || endTime === null || endPrice === null
                        });
                        
                        const lineSeries = this.chart.addLineSeries({
                            color: '#2196f3',
                            lineWidth: 2,
                            priceLineVisible: false,
                            lastValueVisible: false,
                        });
                        
                        lineSeries.setData(biData);
                    }
                    console.log('‚úÖ Bi lines added');
                },
                
                addSegLines() {
                    console.log('üìä Adding Seg lines:', this.chartData.seg_list.length);
                    for (let i = 0; i < this.chartData.seg_list.length; i++) {
                        const seg = this.chartData.seg_list[i];
                        
                        // Validate seg data - check null/undefined FIRST, then NaN
                        if (!seg.begin_time || !seg.end_time || 
                            seg.begin_price === null || seg.begin_price === undefined ||
                            seg.end_price === null || seg.end_price === undefined ||
                            isNaN(parseFloat(seg.begin_price)) || isNaN(parseFloat(seg.end_price))) {
                            console.warn('‚ö†Ô∏è  Skipping invalid Seg:', seg);
                            continue;
                        }
                        
                        const beginPrice = parseFloat(seg.begin_price);
                        const endPrice = parseFloat(seg.end_price);
                        const beginTime = this.convertTime(seg.begin_time);
                        const endTime = this.convertTime(seg.end_time);
                        
                        // Double check after conversion
                        if ((typeof beginTime === 'string' && !beginTime) || 
                            (typeof endTime === 'string' && !endTime) ||
                            (typeof beginTime === 'number' && (isNaN(beginTime) || beginTime <= 0)) ||
                            (typeof endTime === 'number' && (isNaN(endTime) || endTime <= 0)) ||
                            isNaN(beginPrice) || isNaN(endPrice)) {
                            console.warn('‚ö†Ô∏è  Skipping invalid Seg after conversion:', { beginTime, endTime, beginPrice, endPrice });
                            continue;
                        }
                        
                        const segData = [
                            { time: beginTime, value: beginPrice },
                            { time: endTime, value: endPrice }
                        ];
                        
                        console.log(`  üìç Seg ${i}:`, {
                            beginTime, beginPrice, 
                            endTime, endPrice,
                            hasNull: beginTime === null || beginPrice === null || endTime === null || endPrice === null
                        });
                        
                        const lineSeries = this.chart.addLineSeries({
                            color: '#9c27b0',
                            lineWidth: 3,
                            priceLineVisible: false,
                            lastValueVisible: false,
                        });
                        
                        lineSeries.setData(segData);
                    }
                    console.log('‚úÖ Seg lines added');
                },
                
                addBspMarkers(series) {
                    console.log('üìä Adding BSP markers:', this.chartData.bsp_list.length);
                    const markers = this.chartData.bsp_list
                        .filter(bsp => {
                            // Validate BSP data - check null/undefined FIRST, then NaN
                            const isValid = bsp.time && 
                                           bsp.price !== null && bsp.price !== undefined && 
                                           !isNaN(parseFloat(bsp.price));
                            if (!isValid) {
                                console.warn('‚ö†Ô∏è  Skipping invalid BSP:', bsp);
                            }
                            return isValid;
                        })
                        .map(bsp => {
                            const price = parseFloat(bsp.price);
                            const time = this.convertTime(bsp.time);
                            
                            // Final validation
                            if ((typeof time === 'string' && !time) ||
                                (typeof time === 'number' && (isNaN(time) || time <= 0)) ||
                                isNaN(price)) {
                                console.warn('‚ö†Ô∏è  Invalid BSP after conversion:', { time, price });
                                return null;
                            }
                            
                            return {
                                time: time,
                                position: bsp.is_buy ? 'belowBar' : 'aboveBar',
                                color: bsp.is_buy ? '#f44336' : '#4caf50',
                                shape: bsp.is_buy ? 'arrowUp' : 'arrowDown',
                                text: bsp.type
                            };
                        })
                        .filter(marker => marker !== null);
                    
                    console.log('üîç Sample BSP markers (first 3):', markers.slice(0, 3));
                    series.setMarkers(markers);
                    console.log('‚úÖ BSP markers added:', markers.length);
                },
                
                renderMacdChart() {
                    if (!this.chartData || !this.chartData.macd_data || !this.chartData.macd_data.length) {
                        console.log('‚ö†Ô∏è  No MACD data available');
                        return;
                    }
                    
                    const macdContainer = document.getElementById('macd-chart');
                    if (!macdContainer) {
                        console.error('‚ùå MACD container not found');
                        return;
                    }
                    
                    console.log('üìä Rendering MACD chart...');
                    
                    // Clear existing MACD chart
                    if (this.macdChart) {
                        this.macdChart.remove();
                        this.macdChart = null;
                    }
                    macdContainer.innerHTML = '';
                    
                    // Get container dimensions
                    const width = macdContainer.clientWidth || macdContainer.parentElement.clientWidth || 1000;
                    const height = 200;
                    
                    // Create MACD chart
                    this.macdChart = LightweightCharts.createChart(macdContainer, {
                        width: width,
                        height: height,
                        layout: {
                            background: { color: '#ffffff' },
                            textColor: '#333333',
                        },
                        grid: {
                            vertLines: { color: '#e5e7eb' },
                            horzLines: { color: '#e5e7eb' },
                        },
                        crosshair: {
                            mode: LightweightCharts.CrosshairMode.Normal,
                        },
                        rightPriceScale: {
                            borderColor: '#d1d5db',
                        },
                        timeScale: {
                            borderColor: '#d1d5db',
                            timeVisible: true,
                            secondsVisible: true,
                            visible: true,
                        },
                        localization: {
                            timeFormatter: (timestamp) => {
                                const date = new Date(timestamp * 1000);
                                const hours = String(date.getHours()).padStart(2, '0');
                                const minutes = String(date.getMinutes()).padStart(2, '0');
                                const month = date.getMonth() + 1;
                                const day = date.getDate();
                                return `${month}/${day} ${hours}:${minutes}`;
                            },
                        },
                    });
                    
                    // Add MACD histogram (bar chart)
                    const histogramSeries = this.macdChart.addHistogramSeries({
                        color: '#26a69a',
                        priceFormat: {
                            type: 'price',
                            precision: 4,
                            minMove: 0.0001,
                        },
                    });
                    
                    // Filter and prepare valid MACD data - check null/undefined FIRST
                    const validMacdData = this.chartData.macd_data.filter(item => {
                        const isValid = item.time && 
                                       item.macd !== null && item.macd !== undefined &&
                                       item.dif !== null && item.dif !== undefined &&
                                       item.dea !== null && item.dea !== undefined &&
                                       !isNaN(parseFloat(item.macd)) && 
                                       !isNaN(parseFloat(item.dif)) && 
                                       !isNaN(parseFloat(item.dea));
                        if (!isValid) {
                            console.warn('‚ö†Ô∏è  Filtered invalid MACD:', item);
                        }
                        return isValid;
                    });
                    
                    // Prepare histogram data (MACD bar)
                    const histogramData = validMacdData.map(item => ({
                        time: this.convertTime(item.time),
                        value: parseFloat(item.macd),
                        color: parseFloat(item.macd) >= 0 ? '#ef5350' : '#26a69a'
                    }));
                    
                    console.log('üîç Sample MACD histogram (first 3):', histogramData.slice(0, 3));
                    console.log('üîç Sample MACD histogram (last 3):', histogramData.slice(-3));
                    
                    // Check for null values in histogram data
                    const invalidHistogram = histogramData.filter(d => d.time === null || d.value === null || isNaN(d.value));
                    if (invalidHistogram.length > 0) {
                        console.error('‚ùå Found invalid histogram data:', invalidHistogram);
                    }
                    
                    histogramSeries.setData(histogramData);
                    
                    // Add DIF line
                    const difSeries = this.macdChart.addLineSeries({
                        color: '#2962ff',
                        lineWidth: 2,
                        title: 'DIF',
                    });
                    
                    const difData = validMacdData.map(item => ({
                        time: this.convertTime(item.time),
                        value: parseFloat(item.dif)
                    }));
                    
                    console.log('üîç Sample DIF data (first 3):', difData.slice(0, 3));
                    difSeries.setData(difData);
                    
                    // Add DEA line
                    const deaSeries = this.macdChart.addLineSeries({
                        color: '#ff9800',
                        lineWidth: 2,
                        title: 'DEA',
                    });
                    
                    const deaData = validMacdData.map(item => ({
                        time: this.convertTime(item.time),
                        value: parseFloat(item.dea)
                    }));
                    
                    console.log('üîç Sample DEA data (first 3):', deaData.slice(0, 3));
                    deaSeries.setData(deaData);
                    
                    // Synchronize time scales
                    this.macdChart.timeScale().fitContent();
                    
                    // Sync time scale with main chart
                    if (this.chart) {
                        this.chart.timeScale().subscribeVisibleTimeRangeChange((timeRange) => {
                            if (timeRange && this.macdChart) {
                                this.macdChart.timeScale().setVisibleRange(timeRange);
                            }
                        });
                        
                        this.macdChart.timeScale().subscribeVisibleTimeRangeChange((timeRange) => {
                            if (timeRange && this.chart) {
                                this.chart.timeScale().setVisibleRange(timeRange);
                            }
                        });
                    }
                    
                    console.log('‚úÖ MACD chart rendered successfully');
                }
            },
            mounted() {
                ElementPlus.ElMessage({
                    message: 'Ê¨¢Ëøé‰ΩøÁî®Áº†ËÆ∫ÂàÜÊûêÂπ≥Âè∞ÔºÅ',
                    type: 'success',
                    duration: 2000
                });
            }
        }).use(ElementPlus).mount('#app');
    </script>
</body>
</html>

