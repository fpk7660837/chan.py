<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Áº†ËÆ∫Âú®Á∫øÂàÜÊûêÁ≥ªÁªü</title>
    
    <!-- Ant Design CSS -->
    <link rel="stylesheet" href="https://unpkg.com/antd@5.11.5/dist/reset.css">
    
    <!-- React and ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18.2.0/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18.2.0/umd/react-dom.production.min.js"></script>
    
    <!-- Ant Design -->
    <script src="https://unpkg.com/dayjs@1.11.10/dayjs.min.js"></script>
    <script src="https://unpkg.com/antd@5.11.5/dist/antd.min.js"></script>
    
    <!-- Lightweight Charts -->
    <script src="https://unpkg.com/lightweight-charts@4.1.1/dist/lightweight-charts.standalone.production.js"></script>
    
    <!-- Babel Standalone for JSX -->
    <script src="https://unpkg.com/@babel/standalone@7.23.5/babel.min.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Helvetica', 'Arial', sans-serif;
            overflow: hidden;
        }
        
        #root {
            width: 100vw;
            height: 100vh;
        }
        
        .app-layout {
            width: 100%;
            height: 100%;
        }
        
        .app-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 0 24px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            box-shadow: 0 2px 12px rgba(0,0,0,0.1);
            height: 64px;
        }
        
        .app-logo {
            color: white;
            font-size: 20px;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .app-header-actions {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        .left-sidebar {
            background: #fafafa;
            padding: 16px;
            overflow-y: auto;
            border-right: 1px solid #e8e8e8;
        }
        
        .right-sidebar {
            background: #fafafa;
            padding: 16px;
            overflow-y: auto;
            border-left: 1px solid #e8e8e8;
        }
        
        .main-content {
            background: #fff;
            padding: 16px;
            overflow: hidden;
        }
        
        .chart-grid {
            display: grid;
            gap: 16px;
            height: 100%;
            width: 100%;
        }
        
        .chart-grid-1x1 {
            grid-template-columns: 1fr;
            grid-template-rows: 1fr;
        }
        
        .chart-grid-2x1 {
            grid-template-columns: 1fr 1fr;
            grid-template-rows: 1fr;
        }
        
        .chart-grid-2x2 {
            grid-template-columns: 1fr 1fr;
            grid-template-rows: minmax(500px, 1fr) minmax(500px, 1fr);
        }
        
        .chart-grid-3x2 {
            grid-template-columns: 1fr 1fr 1fr;
            grid-template-rows: minmax(500px, 1fr) minmax(500px, 1fr);
        }
        
        .chart-panel {
            border: 1px solid #e8e8e8;
            border-radius: 8px;
            background: white;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
            transition: box-shadow 0.3s;
            min-height: 400px;
        }

        .chart-panel:hover {
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.1);
        }
        
        /* Dynamic height based on enabled indicators */
        .chart-panel[data-subindicators="1"] {
            min-height: 500px;
        }
        
        .chart-panel[data-subindicators="2"] {
            min-height: 550px;
        }
        
        .chart-panel[data-subindicators="3"] {
            min-height: 600px;
        }
        
        .chart-header {
            padding: 14px 18px;
            background: linear-gradient(to right, #f8f9fa, #f5f5f5);
            border-bottom: 2px solid #e8e8e8;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .chart-title {
            font-weight: 600;
            font-size: 14px;
        }
        
        .chart-title-group {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        
        .chart-meta {
            display: flex;
            gap: 12px;
            font-size: 12px;
            align-items: center;
        }
        
        .latest-price {
            font-weight: 600;
            font-size: 16px;
            color: #333;
        }
        
        .price-change {
            font-size: 12px;
            padding: 2px 6px;
            border-radius: 4px;
            font-weight: 500;
        }
        
        .price-change.positive {
            color: #ef5350;
            background: #ffebee;
        }
        
        .price-change.negative {
            color: #26a69a;
            background: #e0f2f1;
        }
        
        .price-change.neutral {
            color: #666;
            background: #f5f5f5;
        }
        
        .update-time {
            color: #999;
            font-size: 11px;
        }
        
        .chart-actions {
            display: flex;
            gap: 8px;
            align-items: center;
        }
        
        .chart-canvas {
            flex: 1;
            position: relative;
            min-height: 0;
        }
        
        .chart-loading {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(255, 255, 255, 0.9);
        }
        
        .chart-empty {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: #999;
        }
        
        .stock-item {
            padding: 12px;
            margin-bottom: 8px;
            background: white;
            border: 1px solid #e8e8e8;
            border-radius: 8px;
            transition: all 0.3s;
        }
        
        .stock-item:hover {
            border-color: #667eea;
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.15);
        }
        
        .stock-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }
        
        .stock-code {
            font-weight: 600;
            color: #333;
            font-size: 14px;
        }
        
        .stock-status {
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 16px;
        }
        
        .stock-levels {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            margin-bottom: 8px;
        }
        
        .stock-actions {
            display: flex;
            justify-content: flex-end;
            gap: 4px;
            padding-top: 8px;
            border-top: 1px solid #f0f0f0;
        }
        
        .batch-actions {
            padding: 12px;
            background: #fafafa;
            border-radius: 8px;
            margin-bottom: 12px;
        }
        
        .batch-actions-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-top: 8px;
        }
        
        .indicator-section {
            margin-bottom: 24px;
        }
        
        .indicator-section-title {
            font-weight: 600;
            margin-bottom: 12px;
            color: #333;
            border-bottom: 1px solid #e8e8e8;
            padding-bottom: 8px;
        }
        
        .indicator-item {
            margin-bottom: 12px;
        }
        
        /* Dark theme support */
        .dark-theme {
            background: #1f1f1f;
            color: #e8e8e8;
        }
        
        .dark-theme .left-sidebar,
        .dark-theme .right-sidebar {
            background: #252525;
            border-color: #3a3a3a;
        }
        
        .dark-theme .main-content {
            background: #1a1a1a;
        }
        
        .dark-theme .chart-panel {
            background: #2a2a2a;
            border-color: #3a3a3a;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        .dark-theme .chart-panel:hover {
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.4);
        }
        
        .dark-theme .chart-header {
            background: linear-gradient(to right, #2e2e2e, #333);
            border-color: #3a3a3a;
        }
        
        .dark-theme .stock-item {
            background: #2a2a2a;
            border-color: #3a3a3a;
            color: #e8e8e8;
        }

        .dark-theme .stock-item:hover {
            border-color: #667eea;
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.2);
        }

        .dark-theme .stock-item-active {
            background: linear-gradient(135deg, #2a3050 0%, #1f2842 100%);
        }

        .dark-theme .level-tag {
            background: linear-gradient(135deg, #3a3a3a, #333);
            color: #bbb;
            border-color: #444;
        }

        /* Scrollbar styling */
        .left-sidebar::-webkit-scrollbar,
        .right-sidebar::-webkit-scrollbar {
            width: 8px;
        }

        .left-sidebar::-webkit-scrollbar-thumb,
        .right-sidebar::-webkit-scrollbar-thumb {
            background: #ccc;
            border-radius: 4px;
        }

        .dark-theme .left-sidebar::-webkit-scrollbar-thumb,
        .dark-theme .right-sidebar::-webkit-scrollbar-thumb {
            background: #555;
        }

        /* Responsive design */
        @media (max-width: 1366px) {
            .chart-grid-3x2 {
                grid-template-columns: 1fr 1fr;
                grid-template-rows: 1fr 1fr 1fr;
            }
        }

        @media (max-width: 1024px) {
            .left-sidebar,
            .right-sidebar {
                width: 240px !important;
            }
        }
        
        /* ============= Additional Responsive Rules ============= */
        @media (max-width: 1400px) {
            .left-sidebar {
                width: 220px;
            }
            
            .right-sidebar {
                width: 280px;
            }
        }
        
        @media (max-width: 1200px) {
            .chart-grid-3x2 {
                grid-template-columns: 1fr 1fr;
                grid-template-rows: repeat(3, minmax(500px, 1fr));
            }
        }
        
        @media (max-width: 1024px) {
            .app-header {
                padding: 0 16px;
                height: 56px;
            }
            
            .chart-grid {
                gap: 12px;
            }
            
            .main-content {
                padding: 12px;
            }
        }
        
        @media (max-width: 768px) {
            .chart-grid-2x2,
            .chart-grid-3x2 {
                grid-template-columns: 1fr;
            }
            
            .chart-grid-2x1 {
                grid-template-columns: 1fr;
                grid-template-rows: 1fr 1fr;
            }
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, createContext, useContext, useMemo, useCallback, memo } = React;
        const { 
            Layout, Button, Input, Select, Checkbox, Space, Card, Badge, Tag, 
            Spin, message, Tooltip, Switch, Divider, DatePicker, InputNumber,
            Row, Col, Collapse, Radio
        } = antd;
        const { Header, Sider, Content } = Layout;
        const { Option } = Select;
        const { Panel } = Collapse;

        // ============= Constants =============
        const API_BASE = 'http://localhost:8000';
        
        const LEVEL_OPTIONS = [
            { label: 'Êó•Á∫ø', value: 'day' },
            { label: '60ÂàÜ', value: '60m' },
            { label: '30ÂàÜ', value: '30m' },
            { label: '15ÂàÜ', value: '15m' },
            { label: '5ÂàÜ', value: '5m' },
            { label: '1ÂàÜ', value: '1m' },
        ];
        
        const LAYOUT_OPTIONS = [
            { label: 'Ëá™Âä®', value: 'auto', cols: 2, rows: 2 },
            { label: '1√ó1', value: '1x1', cols: 1, rows: 1 },
            { label: '2√ó1', value: '2x1', cols: 2, rows: 1 },
            { label: '2√ó2', value: '2x2', cols: 2, rows: 2 },
            { label: '3√ó2', value: '3x2', cols: 3, rows: 2 },
        ];

        // ============= Context for Global State =============
        const AppContext = createContext();

        const useApp = () => useContext(AppContext);

        // ============= Version & Debug Info =============
        console.log('üöÄ Chan.py Web v3.2.0 - Ultimate Edition');
        console.log('üìÖ Loaded at:', new Date().toISOString());
        console.log('‚ú® Complete: Layout optimization, batch operations, time range selector, responsive design');

        // ============= Utility Functions =============
        // Debounce function
        const debounce = (func, wait) => {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        };

        /**
         * Convert time string from backend to Lightweight Charts format
         * Backend format: "2021/09/13" or "2021/09/13 14:30"
         * Lightweight Charts format: "2021-09-13" (strict requirement!)
         * @param {string} timeStr - Time string from backend
         * @returns {string|null} - Converted time string or null
         */
        const convertTime = (timeStr) => {
            if (!timeStr) {
                console.warn('‚ö†Ô∏è  convertTime: received null/undefined time');
                return null;
            }
            
            if (typeof timeStr !== 'string') {
                console.warn('‚ö†Ô∏è  convertTime: received non-string time:', typeof timeStr, timeStr);
                return null;
            }
            
            try {
                // Replace slashes with hyphens for Lightweight Charts compatibility
                // "2021/09/13" -> "2021-09-13"
                // "2021/09/13 14:30" -> "2021-09-13" (for day level, only keep date)
                const normalizedTime = timeStr.replace(/\//g, '-').split(' ')[0];
                
                // Validate format YYYY-MM-DD
                if (!/^\d{4}-\d{2}-\d{2}$/.test(normalizedTime)) {
                    console.error('‚ùå convertTime: invalid format after conversion:', timeStr, '->', normalizedTime);
                    return null;
                }
                
                return normalizedTime;
            } catch (e) {
                console.error('‚ùå convertTime: exception:', timeStr, e);
                return null;
            }
        };

        // Cache management for chart data
        const DataCache = {
            get(key) {
                try {
                    const cached = sessionStorage.getItem(`chart_data_${key}`);
                    if (cached) {
                        const { data, timestamp } = JSON.parse(cached);
                        // Cache valid for 5 minutes
                        if (Date.now() - timestamp < 5 * 60 * 1000) {
                            console.log(`Cache hit for ${key}`);
                            return data;
                        }
                    }
                } catch (e) {
                    console.error('Cache get error:', e);
                }
                return null;
            },
            set(key, data) {
                try {
                    sessionStorage.setItem(`chart_data_${key}`, JSON.stringify({
                        data,
                        timestamp: Date.now(),
                    }));
                    console.log(`Cache set for ${key}`);
                } catch (e) {
                    console.error('Cache set error:', e);
                }
            },
            clear() {
                try {
                    const keys = Object.keys(sessionStorage);
                    keys.forEach(key => {
                        if (key.startsWith('chart_data_')) {
                            sessionStorage.removeItem(key);
                        }
                    });
                    console.log('Cache cleared');
                } catch (e) {
                    console.error('Cache clear error:', e);
                }
            }
        };

        // ============= API Service =============
        const api = {
            async calculateChan(params) {
                console.log('üåê [API] Sending request with params:', params);
                const response = await fetch(`${API_BASE}/api/analysis/calculate`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(params),
                });
                if (!response.ok) {
                    throw new Error(`API Error: ${response.statusText}`);
                }
                const result = await response.json();
                console.log('üåê [API] Received response:', {
                    code: result.code,
                    kline_count: result.kline_data?.length,
                    bi_count: result.bi_list?.length,
                    seg_count: result.seg_list?.length,
                    has_ma: !!result.ma_data,
                    has_macd: !!result.macd_data,
                    has_boll: !!result.boll_data,
                    has_kdj: !!result.kdj_data,
                    has_rsi: !!result.rsi_data,
                });
                return result;
            }
        };

        // ============= Stock Manager Component =============
        const StockManager = memo(() => {
            const { stocks, addStock, removeStock, setStocks, loadingCharts, chartData, refreshAllCharts } = useApp();
            const [inputCode, setInputCode] = useState('');
            const [inputLevels, setInputLevels] = useState(['day']);
            const [selectedStocks, setSelectedStocks] = useState([]);

            const handleAdd = () => {
                if (!inputCode.trim()) {
                    message.warning('ËØ∑ËæìÂÖ•ËÇ°Á•®‰ª£Á†Å');
                    return;
                }
                if (inputLevels.length === 0) {
                    message.warning('ËØ∑ÈÄâÊã©Ëá≥Â∞ë‰∏Ä‰∏™Âë®Êúü');
                    return;
                }
                
                addStock({
                    code: inputCode.trim(),
                    levels: inputLevels,
                });
                
                setInputCode('');
                message.success('Ê∑ªÂä†ÊàêÂäü');
            };

            return (
                <div>
                    <div style={{ marginBottom: 16 }}>
                        <Input
                            placeholder="ËÇ°Á•®‰ª£Á†Å (Â¶Ç: sz.000001)"
                            value={inputCode}
                            onChange={(e) => setInputCode(e.target.value)}
                            onPressEnter={handleAdd}
                            style={{ marginBottom: 8 }}
                        />
                        <Select
                            mode="multiple"
                            placeholder="ÈÄâÊã©Âë®Êúü"
                            value={inputLevels}
                            onChange={setInputLevels}
                            style={{ width: '100%', marginBottom: 8 }}
                        >
                            {LEVEL_OPTIONS.map(opt => (
                                <Option key={opt.value} value={opt.value}>{opt.label}</Option>
                            ))}
                        </Select>
                        <Button type="primary" block onClick={handleAdd}>
                            Ê∑ªÂä†ËÇ°Á•®
                        </Button>
                    </div>
                    
                    <Divider style={{ margin: '16px 0' }}>Âø´ÈÄüÊ∑ªÂä†</Divider>
                    <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: 8, marginBottom: 16 }}>
                        <Button size="small" onClick={() => {
                            addStock({ code: 'sz.000001', levels: ['day'] });
                            message.success('Â∑≤Ê∑ªÂä†Âπ≥ÂÆâÈì∂Ë°å');
                        }}>Âπ≥ÂÆâÈì∂Ë°å</Button>
                        <Button size="small" onClick={() => {
                            addStock({ code: 'sh.600000', levels: ['day'] });
                            message.success('Â∑≤Ê∑ªÂä†Êµ¶ÂèëÈì∂Ë°å');
                        }}>Êµ¶ÂèëÈì∂Ë°å</Button>
                        <Button size="small" onClick={() => {
                            addStock({ code: 'sz.000001', levels: ['day', '60m'] });
                            message.success('Â∑≤Ê∑ªÂä†Â§öÂë®Êúü');
                        }}>Â§öÂë®Êúü</Button>
                        <Button size="small" onClick={() => {
                            addStock({ code: 'sh.000300', levels: ['day'] });
                            message.success('Â∑≤Ê∑ªÂä†Ê≤™Ê∑±300');
                        }}>Ê≤™Ê∑±300</Button>
                    </div>
                    
                    <Divider style={{ margin: '16px 0' }}>Â∑≤Ê∑ªÂä†ÂõæË°® ({stocks.reduce((sum, s) => sum + s.levels.length, 0)})</Divider>
                    
                    {stocks.length > 0 && (
                        <div className="batch-actions">
                            <Checkbox
                                checked={selectedStocks.length === stocks.length && stocks.length > 0}
                                indeterminate={selectedStocks.length > 0 && selectedStocks.length < stocks.length}
                                onChange={(e) => {
                                    if (e.target.checked) {
                                        setSelectedStocks(stocks.map(s => s.id));
                                    } else {
                                        setSelectedStocks([]);
                                    }
                                }}
                            >
                                ÂÖ®ÈÄâ ({selectedStocks.length}/{stocks.length})
                            </Checkbox>
                            {selectedStocks.length > 0 && (
                                <div className="batch-actions-buttons">
                                    <Button 
                                        size="small"
                                        onClick={() => {
                                            selectedStocks.forEach(id => {
                                                const stock = stocks.find(s => s.id === id);
                                                if (stock) {
                                                    stock.levels.forEach(level => {
                                                        const key = `${stock.code}-${level}`;
                                                        if (loadingCharts[key]) return;
                                                        refreshAllCharts();
                                                    });
                                                }
                                            });
                                            message.success(`Ê≠£Âú®Âà∑Êñ∞${selectedStocks.length}‰∏™ÂõæË°®`);
                                        }}
                                        icon={<span>üîÑ</span>}
                                    >
                                        ÊâπÈáèÂà∑Êñ∞
                                    </Button>
                                    <Button 
                                        size="small"
                                        danger
                                        onClick={() => {
                                            setStocks(prev => prev.filter(s => !selectedStocks.includes(s.id)));
                                            setSelectedStocks([]);
                                            message.success(`Â∑≤Âà†Èô§${selectedStocks.length}‰∏™ËÇ°Á•®`);
                                        }}
                                        icon={<span>üóëÔ∏è</span>}
                                    >
                                        ÊâπÈáèÂà†Èô§
                                    </Button>
                                </div>
                            )}
                        </div>
                    )}
                    
                    <div>
                        {stocks.map(stock => {
                            // Check loading status for this stock
                            const isLoading = stock.levels.some(lv => loadingCharts[`${stock.code}-${lv}`]);
                            const hasData = stock.levels.every(lv => chartData[`${stock.code}-${lv}`]);
                            
                            return (
                                <div key={stock.id} className="stock-item">
                                    <div className="stock-header">
                                        <div style={{ display: 'flex', alignItems: 'center', gap: 8 }}>
                                            <Checkbox
                                                checked={selectedStocks.includes(stock.id)}
                                                onChange={(e) => {
                                                    if (e.target.checked) {
                                                        setSelectedStocks(prev => [...prev, stock.id]);
                                                    } else {
                                                        setSelectedStocks(prev => prev.filter(id => id !== stock.id));
                                                    }
                                                }}
                                            />
                                            <span className="stock-code">{stock.code}</span>
                                        </div>
                                        <div className="stock-status">
                                            {isLoading && <Spin size="small" />}
                                            {!isLoading && hasData && <span style={{ color: '#52c41a' }}>‚úì</span>}
                                            {!isLoading && !hasData && <span style={{ color: '#ff4d4f' }}>!</span>}
                                        </div>
                                    </div>
                                    <div className="stock-levels">
                                        {stock.levels.map(lv => (
                                            <Tag key={lv} color="blue" style={{ margin: 0 }}>
                                                {LEVEL_OPTIONS.find(o => o.value === lv)?.label || lv}
                                            </Tag>
                                        ))}
                                    </div>
                                    <div className="stock-actions">
                                        <Button
                                            type="text"
                                            size="small"
                                            onClick={() => {
                                                stock.levels.forEach(lv => {
                                                    const key = `${stock.code}-${lv}`;
                                                    if (!loadingCharts[key]) {
                                                        refreshAllCharts();
                                                    }
                                                });
                                                message.info(`Ê≠£Âú®Âà∑Êñ∞ ${stock.code}`);
                                            }}
                                            icon={<span style={{ fontSize: 12 }}>üîÑ</span>}
                                        >
                                            Âà∑Êñ∞
                                        </Button>
                                        <Button
                                            type="text"
                                            danger
                                            size="small"
                                            onClick={() => {
                                                removeStock(stock.id);
                                                setSelectedStocks(prev => prev.filter(id => id !== stock.id));
                                            }}
                                            icon={<span style={{ fontSize: 12 }}>üóëÔ∏è</span>}
                                        >
                                            Âà†Èô§
                                        </Button>
                                    </div>
                                </div>
                            );
                        })}
                        {stocks.length === 0 && (
                            <div style={{ textAlign: 'center', color: '#999', padding: 20 }}>
                                ÊöÇÊó†ÂõæË°®ÔºåËØ∑Ê∑ªÂä†ËÇ°Á•®
                            </div>
                        )}
                    </div>
                </div>
            );
        });

        // ============= Indicator Config Component =============
        const IndicatorConfig = memo(() => {
            const { indicators, setIndicators, refreshAllCharts } = useApp();
            const [timeRange, setTimeRange] = useState('1y');

            const handleChange = (key, value) => {
                setIndicators(prev => ({ ...prev, [key]: value }));
            };

            const handleTimeRangeChange = (range) => {
                setTimeRange(range);
                
                // Calculate begin_time based on range
                const now = new Date();
                let beginTime;
                
                switch(range) {
                    case '1m':
                        beginTime = new Date(now.setMonth(now.getMonth() - 1));
                        break;
                    case '3m':
                        beginTime = new Date(now.setMonth(now.getMonth() - 3));
                        break;
                    case '6m':
                        beginTime = new Date(now.setMonth(now.getMonth() - 6));
                        break;
                    case '1y':
                        beginTime = new Date(now.setFullYear(now.getFullYear() - 1));
                        break;
                    case '3y':
                        beginTime = new Date(now.setFullYear(now.getFullYear() - 3));
                        break;
                    case 'all':
                        beginTime = new Date('2020-01-01');
                        break;
                    default:
                        beginTime = new Date(now.setFullYear(now.getFullYear() - 1));
                }
                
                const beginTimeStr = beginTime.toISOString().split('T')[0];
                handleChange('begin_time', beginTimeStr);
                
                // Auto refresh all charts
                setTimeout(() => refreshAllCharts(), 100);
                message.info(`Â∑≤ÂàáÊç¢Âà∞"${LEVEL_OPTIONS.find(o => o.value === range)?.label || range}"Êó∂Èó¥ËåÉÂõ¥`);
            };

            return (
                <div>
                    <div style={{ marginBottom: 16, padding: '12px', background: '#f5f5f5', borderRadius: 8 }}>
                        <div style={{ marginBottom: 8, fontWeight: 600, fontSize: 13 }}>Êó∂Èó¥ËåÉÂõ¥</div>
                        <Radio.Group 
                            value={timeRange} 
                            onChange={e => handleTimeRangeChange(e.target.value)}
                            size="small"
                            buttonStyle="solid"
                        >
                            <Radio.Button value="1m">Ëøë1Êúà</Radio.Button>
                            <Radio.Button value="3m">Ëøë3Êúà</Radio.Button>
                            <Radio.Button value="6m">Ëøë6Êúà</Radio.Button>
                            <Radio.Button value="1y">Ëøë1Âπ¥</Radio.Button>
                            <Radio.Button value="3y">Ëøë3Âπ¥</Radio.Button>
                            <Radio.Button value="all">ÂÖ®ÈÉ®</Radio.Button>
                        </Radio.Group>
                    </div>
                    
                    <Collapse defaultActiveKey={['chan', 'tech']} ghost>
                        <Panel header="Áº†ËÆ∫ÊåáÊ†á" key="chan">
                            <div className="indicator-item">
                                <Checkbox
                                    checked={indicators.plot_bi}
                                    onChange={e => handleChange('plot_bi', e.target.checked)}
                                >
                                    Á¨î (Bi)
                                </Checkbox>
                            </div>
                            <div className="indicator-item">
                                <Checkbox
                                    checked={indicators.plot_seg}
                                    onChange={e => handleChange('plot_seg', e.target.checked)}
                                >
                                    Á∫øÊÆµ (Seg)
                                </Checkbox>
                            </div>
                            <div className="indicator-item">
                                <Checkbox
                                    checked={indicators.plot_zs}
                                    onChange={e => handleChange('plot_zs', e.target.checked)}
                                >
                                    ‰∏≠Êû¢ (ZhongShu)
                                </Checkbox>
                            </div>
                            <div className="indicator-item">
                                <Checkbox
                                    checked={indicators.plot_bsp}
                                    onChange={e => handleChange('plot_bsp', e.target.checked)}
                                >
                                    ‰π∞ÂçñÁÇπ (BSP)
                                </Checkbox>
                            </div>
                        </Panel>

                        <Panel header="ÊäÄÊúØÊåáÊ†á" key="tech">
                            <div className="indicator-item">
                                <Checkbox
                                    checked={indicators.plot_ma}
                                    onChange={e => handleChange('plot_ma', e.target.checked)}
                                >
                                    ÂùáÁ∫ø (MA)
                                </Checkbox>
                                {indicators.plot_ma && (
                                    <Input
                                        placeholder="Âë®ÊúüÔºåÂ¶Ç: 5,10,20,60"
                                        size="small"
                                        style={{ marginTop: 4 }}
                                        defaultValue="5,10,20,60"
                                        onChange={e => {
                                            const params = e.target.value.split(',').map(v => parseInt(v.trim())).filter(v => !isNaN(v));
                                            handleChange('ma_params', params);
                                        }}
                                    />
                                )}
                            </div>
                            <div className="indicator-item">
                                <Checkbox
                                    checked={indicators.plot_macd}
                                    onChange={e => handleChange('plot_macd', e.target.checked)}
                                >
                                    MACD
                                </Checkbox>
                            </div>
                            <div className="indicator-item">
                                <Checkbox
                                    checked={indicators.plot_boll}
                                    onChange={e => handleChange('plot_boll', e.target.checked)}
                                >
                                    Â∏ÉÊûóÂ∏¶ (BOLL)
                                </Checkbox>
                            </div>
                            <div className="indicator-item">
                                <Checkbox
                                    checked={indicators.plot_kdj}
                                    onChange={e => handleChange('plot_kdj', e.target.checked)}
                                >
                                    KDJ
                                </Checkbox>
                                {indicators.plot_kdj && (
                                    <InputNumber
                                        size="small"
                                        min={3}
                                        max={30}
                                        defaultValue={9}
                                        style={{ marginTop: 4, width: '100%' }}
                                        addonBefore="Âë®Êúü"
                                        onChange={v => handleChange('kdj_period', v)}
                                    />
                                )}
                            </div>
                            <div className="indicator-item">
                                <Checkbox
                                    checked={indicators.plot_rsi}
                                    onChange={e => handleChange('plot_rsi', e.target.checked)}
                                >
                                    RSI
                                </Checkbox>
                                {indicators.plot_rsi && (
                                    <InputNumber
                                        size="small"
                                        min={3}
                                        max={30}
                                        defaultValue={14}
                                        style={{ marginTop: 4, width: '100%' }}
                                        addonBefore="Âë®Êúü"
                                        onChange={v => handleChange('rsi_period', v)}
                                    />
                                )}
                            </div>
                            <div className="indicator-item">
                                <Checkbox
                                    checked={indicators.plot_volume}
                                    onChange={e => handleChange('plot_volume', e.target.checked)}
                                >
                                    Êàê‰∫§Èáè (Volume)
                                </Checkbox>
                            </div>
                        </Panel>

                        <Panel header="ÂèÇÊï∞ÈÖçÁΩÆ" key="config">
                            <div className="indicator-item">
                                <div style={{ marginBottom: 8 }}>Á∫øÊÆµÁÆóÊ≥ï</div>
                                <Select
                                    value={indicators.seg_algo}
                                    onChange={v => handleChange('seg_algo', v)}
                                    style={{ width: '100%' }}
                                    size="small"
                                >
                                    <Option value="chan">Áº†ËÆ∫</Option>
                                    <Option value="break">Á¨îÁ†¥Á¨î</Option>
                                </Select>
                            </div>
                            <div className="indicator-item">
                                <div style={{ marginBottom: 8 }}>‰∏≠Êû¢ÁÆóÊ≥ï</div>
                                <Select
                                    value={indicators.zs_algo}
                                    onChange={v => handleChange('zs_algo', v)}
                                    style={{ width: '100%' }}
                                    size="small"
                                >
                                    <Option value="normal">Ê†áÂáÜ</Option>
                                    <Option value="strict">‰∏•Ê†º</Option>
                                </Select>
                            </div>
                            <div className="indicator-item">
                                <Checkbox
                                    checked={indicators.bi_strict}
                                    onChange={e => handleChange('bi_strict', e.target.checked)}
                                >
                                    ‰∏•Ê†ºÁ¨î
                                </Checkbox>
                            </div>
                            <div className="indicator-item">
                                <div style={{ marginBottom: 8 }}>ÂºÄÂßãÊó•Êúü</div>
                                <Input
                                    type="date"
                                    size="small"
                                    defaultValue="2023-01-01"
                                    onChange={e => handleChange('begin_time', e.target.value)}
                                />
                            </div>
                        </Panel>
                    </Collapse>
                </div>
            );
        });

        // ============= Chart Panel Component =============
        const ChartPanel = memo(({ stockCode, level, data, loading }) => {
            const chartContainerRef = useRef(null);
            const chartRef = useRef(null);
            const { indicators, theme, analyzeStock } = useApp();

            useEffect(() => {
                if (!chartContainerRef.current || !data) return;

                // Use theme from context
                const isDark = theme === 'dark';

                // Create chart with theme-aware colors
                const chart = LightweightCharts.createChart(chartContainerRef.current, {
                    width: chartContainerRef.current.clientWidth,
                    height: chartContainerRef.current.clientHeight,
                    layout: {
                        background: { color: isDark ? '#1f1f1f' : '#ffffff' },
                        textColor: isDark ? '#e8e8e8' : '#333',
                    },
                    grid: {
                        vertLines: { color: isDark ? '#333' : '#f0f0f0' },
                        horzLines: { color: isDark ? '#333' : '#f0f0f0' },
                    },
                    timeScale: {
                        borderColor: isDark ? '#3a3a3a' : '#e0e0e0',
                    },
                    rightPriceScale: {
                        borderColor: isDark ? '#3a3a3a' : '#e0e0e0',
                    },
                });

                chartRef.current = chart;

                // Add candlestick series
                let candlestickSeries = null;
                if (data.kline_data && data.kline_data.length > 0) {
                    try {
                        console.log('üìä [Candlestick] Processing K-line data, total:', data.kline_data.length);
                        console.log('üìä [Candlestick] First K-line:', data.kline_data[0]);
                        
                        candlestickSeries = chart.addCandlestickSeries({
                            upColor: '#ef5350',
                            downColor: '#26a69a',
                            borderVisible: false,
                            wickUpColor: '#ef5350',
                            wickDownColor: '#26a69a',
                        });
                        
                        const candleData = data.kline_data
                            .map((k, idx) => {
                                const converted = {
                                    time: convertTime(k.time),
                                    open: parseFloat(k.open),
                                    high: parseFloat(k.high),
                                    low: parseFloat(k.low),
                                    close: parseFloat(k.close),
                                };
                                
                                // Log first conversion
                                if (idx === 0) {
                                    console.log('‚úÖ [Candlestick] First K-line converted:', k.time, '->', converted.time);
                                    console.log('‚úÖ [Candlestick] First K-line values:', converted);
                                }
                                
                                return converted;
                            })
                            .filter((k, idx) => {
                                const valid = k.time !== null && !isNaN(k.open) && !isNaN(k.high) && !isNaN(k.low) && !isNaN(k.close);
                                if (!valid && idx < 5) {
                                    console.warn('‚ö†Ô∏è  [Candlestick] Filtered out invalid K-line at index', idx, k);
                                }
                                return valid;
                            });

                        console.log('üìä [Candlestick] Valid candle data count:', candleData.length);
                        if (candleData.length > 0) {
                            console.log('üìä [Candlestick] Setting candle data, sample:', candleData.slice(0, 3));
                            candlestickSeries.setData(candleData);
                            console.log('‚úÖ [Candlestick] Data set successfully');
                        } else {
                            console.warn('‚ö†Ô∏è  [Candlestick] No valid candle data after filtering');
                        }
                    } catch (e) {
                        console.error('‚ùå [Candlestick] Error:', e);
                        console.error('‚ùå [Candlestick] Stack:', e.stack);
                    }

                    // Calculate layout: Main(60%) + Volume(10%) + SubIndicators(30%)
                    const subIndicators = [];
                    if (indicators.plot_macd) subIndicators.push('macd');
                    if (indicators.plot_kdj) subIndicators.push('kdj');
                    if (indicators.plot_rsi) subIndicators.push('rsi');
                    
                    const mainChartHeight = 0.60;  // Main chart fixed 60%
                    const volumeHeight = 0.10;     // Volume pane 10%
                    const subIndicatorSpace = 0.30; // Sub-indicators share 30%
                    const subIndicatorCount = subIndicators.length;
                    const subIndicatorHeight = subIndicatorCount > 0 ? subIndicatorSpace / subIndicatorCount : 0;
                    
                    console.log(`üìä Layout: Main=60%, Volume=10%, ${subIndicatorCount} subs @ ${(subIndicatorHeight*100).toFixed(0)}% each`);

                    // Add volume if enabled - independent pane below main chart
                    if (indicators.plot_volume) {
                        try {
                            console.log('üìä [Volume] Processing volume data...');
                            const volumeSeries = chart.addHistogramSeries({
                                priceFormat: { type: 'volume' },
                                priceScaleId: 'volume',
                                scaleMargins: { 
                                    top: mainChartHeight,  // Start at 60%
                                    bottom: subIndicatorSpace  // Leave 30% for sub-indicators
                                },
                            });

                            const volumeData = data.kline_data.map(k => ({
                                time: convertTime(k.time),
                                value: parseFloat(k.volume || 0),
                                color: k.close >= k.open ? '#ef535080' : '#26a69a80',
                            })).filter(k => k.time !== null && !isNaN(k.value));

                            console.log(`üìä [Volume] Setting ${volumeData.length} data points, first:`, volumeData[0]);
                            volumeSeries.setData(volumeData);
                            console.log('‚úÖ [Volume] Data set successfully');
                        } catch (e) {
                            console.error('‚ùå [Volume] Error:', e);
                        }
                    }

                    // Add MA lines
                    if (indicators.plot_ma && data.ma_data) {
                        try {
                            console.log('üìä [MA] Processing MA data...');
                            const colors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7'];
                            let colorIdx = 0;

                            Object.keys(data.ma_data).forEach(period => {
                                const maData = data.ma_data[period];
                                if (maData && maData.length > 0) {
                                    const maSeries = chart.addLineSeries({
                                        color: colors[colorIdx % colors.length],
                                        lineWidth: 1.5,
                                        title: `MA${period}`,
                                        priceLineVisible: false,
                                        lastValueVisible: false,
                                    });

                                    const processedData = maData.map(m => ({
                                        time: convertTime(m.time),
                                        value: parseFloat(m.value),
                                    })).filter(m => m.time !== null && !isNaN(m.value));

                                    console.log(`üìä [MA-${period}] Setting ${processedData.length} data points, first:`, processedData[0]);
                                    maSeries.setData(processedData);
                                    console.log(`‚úÖ [MA-${period}] Data set successfully`);
                                    colorIdx++;
                                }
                            });
                        } catch (e) {
                            console.error('‚ùå [MA] Error:', e);
                        }
                    }

                    // Add Bi lines - Each Bi as a separate line series
                    if (indicators.plot_bi && data.bi_list && data.bi_list.length > 0) {
                        try {
                            console.log(`üìä [Bi] Processing ${data.bi_list.length} Bi segments...`);
                            
                            data.bi_list.forEach((bi, idx) => {
                                try {
                                    const beginTime = convertTime(bi.begin_time);
                                    const endTime = convertTime(bi.end_time);
                                    
                                    if (beginTime && endTime && !isNaN(bi.begin_price) && !isNaN(bi.end_price)) {
                                        const biSeries = chart.addLineSeries({
                                            color: '#2196F3',
                                            lineWidth: 2,
                                            priceLineVisible: false,
                                            lastValueVisible: false,
                                        });
                                        
                                        const biData = [
                                            { time: beginTime, value: parseFloat(bi.begin_price) },
                                            { time: endTime, value: parseFloat(bi.end_price) }
                                        ];
                                        
                                        biSeries.setData(biData);
                                        
                                        if (idx === 0) {
                                            console.log(`üìä [Bi] First segment: ${beginTime} -> ${endTime}`);
                                        }
                                    }
                                } catch (e) {
                                    console.error(`‚ùå [Bi] Error on segment ${idx}:`, e);
                                }
                            });
                            
                            console.log(`‚úÖ [Bi] All ${data.bi_list.length} segments added successfully`);
                        } catch (e) {
                            console.error('‚ùå [Bi] Error:', e);
                        }
                    }

                    // Add Seg lines - Each Seg as a separate line series
                    if (indicators.plot_seg && data.seg_list && data.seg_list.length > 0) {
                        try {
                            console.log(`üìä [Seg] Processing ${data.seg_list.length} Seg segments...`);
                            
                            data.seg_list.forEach((seg, idx) => {
                                try {
                                    const beginTime = convertTime(seg.begin_time);
                                    const endTime = convertTime(seg.end_time);
                                    
                                    if (beginTime && endTime && !isNaN(seg.begin_price) && !isNaN(seg.end_price)) {
                                        const segSeries = chart.addLineSeries({
                                            color: '#9C27B0',
                                            lineWidth: 3,
                                            priceLineVisible: false,
                                            lastValueVisible: false,
                                        });
                                        
                                        const segData = [
                                            { time: beginTime, value: parseFloat(seg.begin_price) },
                                            { time: endTime, value: parseFloat(seg.end_price) }
                                        ];
                                        
                                        segSeries.setData(segData);
                                        
                                        if (idx === 0) {
                                            console.log(`üìä [Seg] First segment: ${beginTime} -> ${endTime}`);
                                        }
                                    }
                                } catch (e) {
                                    console.error(`‚ùå [Seg] Error on segment ${idx}:`, e);
                                }
                            });
                            
                            console.log(`‚úÖ [Seg] All ${data.seg_list.length} segments added successfully`);
                        } catch (e) {
                            console.error('‚ùå [Seg] Error:', e);
                        }
                    }

                    // Add buy/sell markers
                    if (indicators.plot_bsp && data.bsp_list && candlestickSeries) {
                        try {
                            console.log('üìä [BSP] Processing buy/sell markers...');
                            const markers = data.bsp_list
                                .map(bsp => ({
                                    time: convertTime(bsp.time),
                                    position: bsp.is_buy ? 'belowBar' : 'aboveBar',
                                    color: bsp.is_buy ? '#4CAF50' : '#F44336',
                                    shape: bsp.is_buy ? 'arrowUp' : 'arrowDown',
                                    text: bsp.is_buy ? 'B' : 'S',
                                }))
                                .filter(m => m.time !== null);
                            console.log(`üìä [BSP] Setting ${markers.length} markers, first:`, markers[0]);
                            if (markers.length > 0) {
                                candlestickSeries.setMarkers(markers);
                                console.log('‚úÖ [BSP] Markers set successfully');
                            } else {
                                console.log('‚ö†Ô∏è  [BSP] No markers to set, skipping setMarkers call');
                            }
                        } catch (e) {
                            console.error('‚ùå [BSP] Error:', e);
                        }
                    }

                    // Add BOLL bands
                    if (indicators.plot_boll && data.boll_data && data.boll_data.length > 0) {
                        try {
                            console.log('üìä [BOLL] Processing BOLL bands...');
                            const upperSeries = chart.addLineSeries({
                                color: '#EE82EE',
                                lineWidth: 1,
                                lineStyle: 2, // dashed
                                title: 'BOLL Upper',
                                priceLineVisible: false,
                                lastValueVisible: false,
                            });
                            const middleSeries = chart.addLineSeries({
                                color: '#9370DB',
                                lineWidth: 1.5,
                                title: 'BOLL Mid',
                                priceLineVisible: false,
                                lastValueVisible: false,
                            });
                            const lowerSeries = chart.addLineSeries({
                                color: '#EE82EE',
                                lineWidth: 1,
                                lineStyle: 2, // dashed
                                title: 'BOLL Lower',
                                priceLineVisible: false,
                                lastValueVisible: false,
                            });

                            const upperData = data.boll_data.map(b => ({
                                time: convertTime(b.time),
                                value: parseFloat(b.upper),
                            })).filter(b => b.time !== null && !isNaN(b.value));
                            const middleData = data.boll_data.map(b => ({
                                time: convertTime(b.time),
                                value: parseFloat(b.middle),
                            })).filter(b => b.time !== null && !isNaN(b.value));
                            const lowerData = data.boll_data.map(b => ({
                                time: convertTime(b.time),
                                value: parseFloat(b.lower),
                            })).filter(b => b.time !== null && !isNaN(b.value));

                            console.log(`üìä [BOLL] Upper: ${upperData.length}, Middle: ${middleData.length}, Lower: ${lowerData.length}, first upper:`, upperData[0]);
                            upperSeries.setData(upperData);
                            middleSeries.setData(middleData);
                            lowerSeries.setData(lowerData);
                            console.log('‚úÖ [BOLL] Data set successfully');
                        } catch (e) {
                            console.error('‚ùå [BOLL] Error:', e);
                        }
                    }

                    // Add MACD indicator
                    if (indicators.plot_macd && data.macd_data && data.macd_data.length > 0) {
                        try {
                            console.log('üìä [MACD] Processing MACD indicator...');
                            const macdIndex = subIndicators.indexOf('macd');
                            const macdTop = mainChartHeight + volumeHeight + (macdIndex * subIndicatorHeight);
                            const macdBottom = 1 - (macdTop + subIndicatorHeight);
                            
                            const macdSeries = chart.addHistogramSeries({
                                priceFormat: { type: 'price', precision: 4, minMove: 0.0001 },
                                priceScaleId: 'macd',
                                scaleMargins: { 
                                    top: macdTop + 0.005,  // Small spacing
                                    bottom: macdBottom + 0.005
                                },
                            });

                            const difSeries = chart.addLineSeries({
                                color: '#2196F3',
                                lineWidth: 2,
                                priceScaleId: 'macd',
                                lastValueVisible: false,
                                priceLineVisible: false,
                            });

                            const deaSeries = chart.addLineSeries({
                                color: '#FF9800',
                                lineWidth: 2,
                                priceScaleId: 'macd',
                                lastValueVisible: false,
                                priceLineVisible: false,
                            });

                            const macdData = data.macd_data.map(m => ({
                                time: convertTime(m.time),
                                value: parseFloat(m.macd),
                                color: parseFloat(m.macd) >= 0 ? '#ef535080' : '#26a69a80',
                            })).filter(m => m.time !== null && !isNaN(m.value));

                            const difData = data.macd_data.map(m => ({
                                time: convertTime(m.time),
                                value: parseFloat(m.dif),
                            })).filter(m => m.time !== null && !isNaN(m.value));

                            const deaData = data.macd_data.map(m => ({
                                time: convertTime(m.time),
                                value: parseFloat(m.dea),
                            })).filter(m => m.time !== null && !isNaN(m.value));

                            console.log(`üìä [MACD] MACD: ${macdData.length}, DIF: ${difData.length}, DEA: ${deaData.length}, first MACD:`, macdData[0]);
                            macdSeries.setData(macdData);
                            difSeries.setData(difData);
                            deaSeries.setData(deaData);
                            console.log('‚úÖ [MACD] Data set successfully');
                        } catch (e) {
                            console.error('‚ùå [MACD] Error:', e);
                        }
                    }

                    // Add KDJ indicator
                    if (indicators.plot_kdj && data.kdj_data && data.kdj_data.length > 0) {
                        try {
                            console.log('üìä [KDJ] Processing KDJ indicator...');
                            const kdjIndex = subIndicators.indexOf('kdj');
                            const kdjTop = mainChartHeight + volumeHeight + (kdjIndex * subIndicatorHeight);
                            const kdjBottom = 1 - (kdjTop + subIndicatorHeight);
                            
                            const kSeries = chart.addLineSeries({
                                color: '#FF6B6B',
                                lineWidth: 2,
                                priceScaleId: 'kdj',
                                scaleMargins: { 
                                    top: kdjTop + 0.005,
                                    bottom: kdjBottom + 0.005
                                },
                                lastValueVisible: false,
                                priceLineVisible: false,
                            });

                            const dSeries = chart.addLineSeries({
                                color: '#4ECDC4',
                                lineWidth: 2,
                                priceScaleId: 'kdj',
                                lastValueVisible: false,
                                priceLineVisible: false,
                            });

                            const jSeries = chart.addLineSeries({
                                color: '#95A5A6',
                                lineWidth: 2,
                                priceScaleId: 'kdj',
                                lastValueVisible: false,
                                priceLineVisible: false,
                            });

                            const kData = data.kdj_data.map(k => ({
                                time: convertTime(k.time),
                                value: parseFloat(k.k),
                            })).filter(k => k.time !== null && !isNaN(k.value));

                            const dData = data.kdj_data.map(k => ({
                                time: convertTime(k.time),
                                value: parseFloat(k.d),
                            })).filter(k => k.time !== null && !isNaN(k.value));

                            const jData = data.kdj_data.map(k => ({
                                time: convertTime(k.time),
                                value: parseFloat(k.j),
                            })).filter(k => k.time !== null && !isNaN(k.value));

                            console.log(`üìä [KDJ] K: ${kData.length}, D: ${dData.length}, J: ${jData.length}, first K:`, kData[0]);
                            kSeries.setData(kData);
                            dSeries.setData(dData);
                            jSeries.setData(jData);
                            console.log('‚úÖ [KDJ] Data set successfully');
                        } catch (e) {
                            console.error('‚ùå [KDJ] Error:', e);
                        }
                    }

                    // Add RSI indicator
                    if (indicators.plot_rsi && data.rsi_data && data.rsi_data.length > 0) {
                        try {
                            console.log('üìä [RSI] Processing RSI indicator...');
                            const rsiIndex = subIndicators.indexOf('rsi');
                            const rsiTop = mainChartHeight + volumeHeight + (rsiIndex * subIndicatorHeight);
                            const rsiBottom = 1 - (rsiTop + subIndicatorHeight);
                            
                            const rsiSeries = chart.addLineSeries({
                                color: '#9B59B6',
                                lineWidth: 2,
                                priceScaleId: 'rsi',
                                scaleMargins: { 
                                    top: rsiTop + 0.005,
                                    bottom: rsiBottom + 0.005
                                },
                                lastValueVisible: false,
                                priceLineVisible: false,
                            });

                            const rsiData = data.rsi_data.map(r => ({
                                time: convertTime(r.time),
                                value: parseFloat(r.rsi),
                            })).filter(r => r.time !== null && !isNaN(r.value));

                            console.log(`üìä [RSI] Setting ${rsiData.length} data points, first:`, rsiData[0]);
                            rsiSeries.setData(rsiData);
                            console.log('‚úÖ [RSI] Data set successfully');

                            // Add RSI reference lines (30 and 70)
                            const rsi30Series = chart.addLineSeries({
                                color: '#e74c3c',
                                lineWidth: 1,
                                lineStyle: 2, // dashed
                                priceScaleId: 'rsi',
                                crosshairMarkerVisible: false,
                                lastValueVisible: false,
                                priceLineVisible: false,
                            });

                            const rsi70Series = chart.addLineSeries({
                                color: '#e74c3c',
                                lineWidth: 1,
                                lineStyle: 2, // dashed
                                priceScaleId: 'rsi',
                                crosshairMarkerVisible: false,
                                lastValueVisible: false,
                                priceLineVisible: false,
                            });

                            if (data.rsi_data.length > 0) {
                                const firstTime = convertTime(data.rsi_data[0].time);
                                const lastTime = convertTime(data.rsi_data[data.rsi_data.length - 1].time);
                                if (firstTime && lastTime) {
                                    rsi30Series.setData([
                                        { time: firstTime, value: 30 },
                                        { time: lastTime, value: 30 }
                                    ]);
                                    rsi70Series.setData([
                                        { time: firstTime, value: 70 },
                                        { time: lastTime, value: 70 }
                                    ]);
                                    console.log('‚úÖ [RSI] Reference lines set successfully');
                                }
                            }
                        } catch (e) {
                            console.error('‚ùå [RSI] Error:', e);
                        }
                    }
                }

                // Fit content
                chart.timeScale().fitContent();

                // Handle resize
                const handleResize = () => {
                    if (chartContainerRef.current && chartRef.current) {
                        chartRef.current.applyOptions({
                            width: chartContainerRef.current.clientWidth,
                            height: chartContainerRef.current.clientHeight,
                        });
                    }
                };

                window.addEventListener('resize', handleResize);

                return () => {
                    window.removeEventListener('resize', handleResize);
                    if (chartRef.current) {
                        chartRef.current.remove();
                        chartRef.current = null;
                    }
                };
            }, [data, indicators, theme]);

            const levelLabel = LEVEL_OPTIONS.find(o => o.value === level)?.label || level;
            
            // Calculate number of sub-indicators for dynamic height
            const subIndicatorCount = [
                indicators.plot_macd,
                indicators.plot_kdj,
                indicators.plot_rsi
            ].filter(Boolean).length;

            return (
                <div className="chart-panel" data-subindicators={subIndicatorCount}>
                    <div className="chart-header">
                        <div className="chart-title-group">
                            <div className="chart-title">
                                {stockCode} - {levelLabel}
                            </div>
                            {data && data.kline_data && data.kline_data.length > 0 && (
                                <div className="chart-meta">
                                    <span className="latest-price">
                                        {parseFloat(data.kline_data[data.kline_data.length - 1].close).toFixed(2)}
                                    </span>
                                    <span className={`price-change ${
                                        data.kline_data.length > 1 
                                            ? (parseFloat(data.kline_data[data.kline_data.length - 1].close) >= parseFloat(data.kline_data[data.kline_data.length - 1].open)
                                                ? 'positive'
                                                : 'negative')
                                            : 'neutral'
                                    }`}>
                                        {data.kline_data.length > 1 && (() => {
                                            const lastClose = parseFloat(data.kline_data[data.kline_data.length - 1].close);
                                            const lastOpen = parseFloat(data.kline_data[data.kline_data.length - 1].open);
                                            const change = ((lastClose - lastOpen) / lastOpen * 100).toFixed(2);
                                            return `${change >= 0 ? '+' : ''}${change}%`;
                                        })()}
                                    </span>
                                    <span className="update-time">
                                        {data.kline_data[data.kline_data.length - 1].time}
                                    </span>
                                </div>
                            )}
                        </div>
                        <div className="chart-actions">
                            {data && (
                                <Tag color="blue">{data.kline_data?.length || 0} KÁ∫ø</Tag>
                            )}
                            <Button 
                                size="small" 
                                type="text"
                                loading={loading}
                                onClick={() => analyzeStock(stockCode, level, true)}
                                icon={<span style={{ fontSize: 14 }}>üîÑ</span>}
                                title="Âà∑Êñ∞Ê≠§ÂõæË°®"
                            />
                        </div>
                    </div>
                    <div className="chart-canvas">
                        <div ref={chartContainerRef} style={{ width: '100%', height: '100%' }} />
                        {loading && (
                            <div className="chart-loading">
                                <Spin tip="Âä†ËΩΩ‰∏≠..." />
                            </div>
                        )}
                        {!loading && !data && (
                            <div className="chart-empty">
                                <div style={{ fontSize: 48, marginBottom: 8 }}>üìä</div>
                                <div>ÊöÇÊó†Êï∞ÊçÆ</div>
                            </div>
                        )}
                    </div>
                </div>
            );
        });

        // ============= Chart Grid Component =============
        const ChartGrid = () => {
            const { stocks, gridLayout, chartData, loadingCharts } = useApp();

            // Auto-determine layout based on number of charts
            let actualLayout = gridLayout;
            if (gridLayout === 'auto') {
                const totalCharts = stocks.reduce((sum, s) => sum + s.levels.length, 0);
                if (totalCharts === 1) actualLayout = '1x1';
                else if (totalCharts === 2) actualLayout = '2x1';
                else if (totalCharts <= 4) actualLayout = '2x2';
                else actualLayout = '3x2';
            }

            const layout = LAYOUT_OPTIONS.find(o => o.value === actualLayout) || LAYOUT_OPTIONS[0];
            const maxCharts = layout.cols * layout.rows;

            // Generate chart slots - show all added stocks
            const chartSlots = [];
            
            stocks.forEach(stock => {
                stock.levels.forEach(level => {
                    if (chartSlots.length < maxCharts) {
                        const key = `${stock.code}-${level}`;
                        chartSlots.push({ stockCode: stock.code, level, key });
                    }
                });
            });

            // Fill empty slots
            while (chartSlots.length < maxCharts) {
                chartSlots.push({ key: `empty-${chartSlots.length}`, empty: true });
            }

            return (
                <div className={`chart-grid chart-grid-${actualLayout}`}>
                    {chartSlots.map(slot => {
                        if (slot.empty) {
                            return (
                                <div key={slot.key} className="chart-panel">
                                    <div className="chart-canvas">
                                        <div className="chart-empty">
                                            <div style={{ fontSize: 48, marginBottom: 8 }}>‚ûï</div>
                                            <div>ÁÇπÂáªÂ∑¶‰æßÊ∑ªÂä†ËÇ°Á•®</div>
                                        </div>
                                    </div>
                                </div>
                            );
                        }

                        const data = chartData[slot.key];
                        const loading = loadingCharts[slot.key];

                        return (
                            <ChartPanel
                                key={slot.key}
                                stockCode={slot.stockCode}
                                level={slot.level}
                                data={data}
                                loading={loading}
                            />
                        );
                    })}
                </div>
            );
        };

        // ============= Main App Component =============
        const App = () => {
            // Load from localStorage on init
            const loadConfig = () => {
                try {
                    const saved = localStorage.getItem('chanlun_config');
                    if (saved) {
                        const config = JSON.parse(saved);
                        return {
                            stocks: config.stocks || [],
                            indicators: config.indicators || null,
                            gridLayout: config.gridLayout || '2x2',
                            theme: config.theme || 'light',
                        };
                    }
                } catch (e) {
                    console.error('Failed to load config:', e);
                }
                return null;
            };

            const savedConfig = loadConfig();

            const [stocks, setStocks] = useState(savedConfig?.stocks || []);
            const [indicators, setIndicators] = useState(savedConfig?.indicators || {
                plot_bi: true,
                plot_seg: true,
                plot_zs: false,
                plot_bsp: true,
                plot_ma: false,
                plot_macd: false,
                plot_boll: false,
                plot_kdj: false,
                plot_rsi: false,
                plot_volume: true,
                seg_algo: 'chan',
                zs_algo: 'normal',
                bi_strict: true,
                begin_time: '2023-01-01',
                ma_params: [5, 10, 20, 60],
                kdj_period: 9,
                rsi_period: 14,
            });
            const [gridLayout, setGridLayout] = useState(savedConfig?.gridLayout || 'auto');
            const [chartData, setChartData] = useState({});
            const [loadingCharts, setLoadingCharts] = useState({});
            const [theme, setTheme] = useState(savedConfig?.theme || 'light');
            
            // Auto-adjust grid layout based on number of charts
            useEffect(() => {
                if (gridLayout === 'auto') {
                    const totalCharts = stocks.reduce((sum, s) => sum + s.levels.length, 0);
                    let newLayout = '2x2'; // default
                    
                    if (totalCharts === 1) newLayout = '1x1';
                    else if (totalCharts === 2) newLayout = '2x1';
                    else if (totalCharts <= 4) newLayout = '2x2';
                    else newLayout = '3x2';
                    
                    // Only update if changed to avoid infinite loops
                    if (gridLayout !== newLayout && savedConfig?.gridLayout === 'auto') {
                        // We don't actually change gridLayout here to keep it as 'auto'
                        // Just note: the ChartGrid component will handle the auto logic
                    }
                }
            }, [stocks, gridLayout]);

            // Save config to localStorage whenever it changes
            useEffect(() => {
                try {
                    const config = {
                        stocks,
                        indicators,
                        gridLayout,
                        theme,
                    };
                    localStorage.setItem('chanlun_config', JSON.stringify(config));
                    console.log('Config saved to localStorage');
                } catch (e) {
                    console.error('Failed to save config:', e);
                }
            }, [stocks, indicators, gridLayout, theme]);

            const addStock = (stockInfo) => {
                // Check if stock with same code already exists
                const existingStock = stocks.find(s => s.code === stockInfo.code);
                
                if (existingStock) {
                    // Merge levels and remove duplicates
                    const mergedLevels = [...new Set([...existingStock.levels, ...stockInfo.levels])];
                    
                    setStocks(prev => prev.map(s => 
                        s.code === stockInfo.code 
                            ? { ...s, levels: mergedLevels }
                            : s
                    ));
                    
                    // Only analyze new levels
                    const newLevels = stockInfo.levels.filter(lv => !existingStock.levels.includes(lv));
                    newLevels.forEach(level => {
                        analyzeStock(stockInfo.code, level);
                    });
                    
                    if (newLevels.length > 0) {
                        message.success(`Â∑≤Ê∑ªÂä† ${stockInfo.code} ÁöÑÊñ∞Âë®Êúü`);
                    } else {
                        message.info(`${stockInfo.code} Â∑≤Â≠òÂú®,Êó†ÈúÄÈáçÂ§çÊ∑ªÂä†`);
                    }
                } else {
                    // Add new stock
                    const newStock = {
                        id: Date.now(),
                        code: stockInfo.code,
                        levels: stockInfo.levels,
                    };
                    setStocks(prev => [...prev, newStock]);
                    
                    // Trigger analysis for all levels
                    stockInfo.levels.forEach(level => {
                        analyzeStock(stockInfo.code, level);
                    });
                }
            };

            const removeStock = (stockId) => {
                setStocks(prev => prev.filter(s => s.id !== stockId));
            };

            const analyzeStock = async (code, level, forceRefresh = false) => {
                const key = `${code}-${level}`;
                
                // Check cache first if not forcing refresh
                if (!forceRefresh) {
                    const cachedData = DataCache.get(key);
                    if (cachedData) {
                        setChartData(prev => ({ ...prev, [key]: cachedData }));
                        message.success(`${code} ${level} Êï∞ÊçÆÂ∑≤‰ªéÁºìÂ≠òÂä†ËΩΩ`, 1);
                        return;
                    }
                }

                setLoadingCharts(prev => ({ ...prev, [key]: true }));

                try {
                    const params = {
                        code,
                        lv_list: [level],
                        data_src: 'BAO_STOCK',
                        ...indicators,
                    };

                    const result = await api.calculateChan(params);
                    setChartData(prev => ({ ...prev, [key]: result }));
                    
                    // Cache the result
                    DataCache.set(key, result);
                    
                    message.success(`${code} ${level} ÂàÜÊûêÂÆåÊàê`);
                } catch (error) {
                    console.error('Analysis failed:', error);
                    message.error(`${code} ${level} ÂàÜÊûêÂ§±Ë¥•: ${error.message}`);
                } finally {
                    setLoadingCharts(prev => ({ ...prev, [key]: false }));
                }
            };

            // Debounced version for performance
            const debouncedAnalyze = useCallback(
                debounce((code, level, forceRefresh) => analyzeStock(code, level, forceRefresh), 300),
                [indicators]
            );

            const refreshAllCharts = () => {
                // Clear cache and force refresh
                DataCache.clear();
                stocks.forEach(stock => {
                    stock.levels.forEach(level => {
                        analyzeStock(stock.code, level, true);
                    });
                });
                message.info('Ê≠£Âú®Âà∑Êñ∞ÊâÄÊúâÂõæË°®...');
            };

            const contextValue = {
                stocks,
                setStocks,
                addStock,
                removeStock,
                indicators,
                setIndicators,
                gridLayout,
                chartData,
                loadingCharts,
                analyzeStock,
                refreshAllCharts,
                theme,
            };

            return (
                <AppContext.Provider value={contextValue}>
                    <Layout className={`app-layout ${theme === 'dark' ? 'dark-theme' : ''}`}>
                        <Header className="app-header">
                            <div className="app-logo">
                                <span>üìà</span>
                                <span>Áº†ËÆ∫Âú®Á∫øÂàÜÊûêÁ≥ªÁªü</span>
                            </div>
                            <div className="app-header-actions">
                                <Select
                                    value={gridLayout}
                                    onChange={setGridLayout}
                                    style={{ width: 100 }}
                                >
                                    {LAYOUT_OPTIONS.map(opt => (
                                        <Option key={opt.value} value={opt.value}>{opt.label}</Option>
                                    ))}
                                </Select>
                                <Tooltip title="Âà∑Êñ∞ÊâÄÊúâÂõæË°®">
                                    <Button type="primary" onClick={refreshAllCharts}>
                                        üîÑ Âà∑Êñ∞
                                    </Button>
                                </Tooltip>
                                <Tooltip title={theme === 'light' ? 'ÂàáÊç¢Âà∞Ê∑±Ëâ≤‰∏ªÈ¢ò' : 'ÂàáÊç¢Âà∞ÊµÖËâ≤‰∏ªÈ¢ò'}>
                                    <Button
                                        type="default"
                                        onClick={() => setTheme(theme === 'light' ? 'dark' : 'light')}
                                    >
                                        {theme === 'light' ? 'üåô' : '‚òÄÔ∏è'}
                                    </Button>
                                </Tooltip>
                            </div>
                        </Header>
                        <Layout>
                            <Sider width={280} className="left-sidebar" theme="light">
                                <StockManager />
                            </Sider>
                            <Content className="main-content">
                                <ChartGrid />
                            </Content>
                            <Sider width={280} className="right-sidebar" theme="light">
                                <IndicatorConfig />
                            </Sider>
                        </Layout>
                    </Layout>
                </AppContext.Provider>
            );
        };

        // Render app
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>

