<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Áº†ËÆ∫Âú®Á∫øÂàÜÊûêÁ≥ªÁªü - KLineChartÁâà</title>
    
    <!-- React & ReactDOM (must load first) -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <!-- Babel for JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- KLineChart - ‰ΩøÁî®Êú¨Âú∞ÁâàÊú¨(v10.0.0-alpha5) -->
    <script src="/static/lib/klinecharts.min.js"></script>
    
    <!-- Ant Design CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/antd@5.12.0/dist/reset.css">
    
    <!-- Ant Design JS -->
    <script src="https://cdn.jsdelivr.net/npm/dayjs@1.11.10/dayjs.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/antd@5.12.0/dist/antd.min.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: #f5f5f5;
        }

        .app-layout {
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .app-header {
            background: #001529;
            color: white;
            padding: 0 24px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            height: 64px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
        }

        .app-logo {
            display: flex;
            align-items: center;
            gap: 12px;
            font-size: 20px;
            font-weight: 600;
        }

        .app-logo span:first-child {
            font-size: 28px;
        }

        .app-header-actions {
            display: flex;
            gap: 16px;
            align-items: center;
        }

        .app-content {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        .sidebar {
            background: white;
            padding: 16px;
            overflow-y: auto;
            box-shadow: 2px 0 8px rgba(0,0,0,0.05);
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .sidebar-resizer {
            width: 6px;
            cursor: col-resize;
            background: transparent;
            position: relative;
        }

        .sidebar-resizer::after {
            content: "";
            position: absolute;
            top: 0;
            bottom: 0;
            left: 2px;
            width: 2px;
            background: rgba(0,0,0,0.1);
            border-radius: 1px;
        }

        .sidebar-resizer:hover::after,
        .sidebar-resizer.dragging::after {
            background: rgba(24, 144, 255, 0.5);
        }

        .sidebar .ant-tabs,
        .sidebar .ant-tabs-content-holder {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .sidebar .ant-tabs-content-holder .ant-tabs-content,
        .sidebar .ant-tabs-tabpane {
            flex: 1;
        }

        .sidebar .ant-tabs-tabpane {
            overflow-y: auto;
        }

        .left-sidebar {
            width: 280px;
        }

        .right-sidebar {
            width: 320px;
        }

        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-height: 0;
            padding: 16px;
            overflow: hidden;
            background: #f0f2f5;
        }

        .config-section {
            border: 1px solid #e8e8e8;
            border-radius: 8px;
            padding: 12px;
            background: #fafafa;
        }

        .config-section + .config-section {
            margin-top: 12px;
        }

        .config-section-title {
            font-weight: 600;
            margin-bottom: 8px;
            color: #262626;
        }

        .dark-theme .config-section {
            background: #141414;
            border-color: #333;
        }


        /* Stock Manager Styles */
        .stock-manager {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .stock-manager-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            gap: 12px;
        }

        .stock-manager-title {
            font-size: 16px;
            font-weight: 600;
            color: #262626;
        }

        .stock-manager-subtitle {
            font-size: 12px;
            color: #8c8c8c;
            margin-top: 4px;
        }

        .stock-add-card {
            background: #fafafa;
            border: 1px solid #e8e8e8;
            border-radius: 10px;
            padding: 12px;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .stock-add-inputs {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .stock-add-inputs .ant-input {
            font-size: 13px;
        }

        .stock-add-hint {
            font-size: 12px;
            color: #999;
            line-height: 1.5;
        }

        .stock-quick-area {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .stock-quick-title {
            font-weight: 600;
            font-size: 13px;
            color: #262626;
        }

        .watchlist-empty {
            padding: 14px;
            border-radius: 10px;
            background: #fafafa;
            border: 1px dashed #d9d9d9;
            text-align: center;
            font-size: 12px;
            color: #999;
        }

        .watchlist-item {
            border: 1px solid #e8e8e8;
            border-radius: 10px;
            padding: 12px;
            margin-bottom: 12px;
            background: #fff;
            display: flex;
            flex-direction: column;
            gap: 12px;
            transition: box-shadow 0.2s ease, border-color 0.2s ease, transform 0.2s ease;
        }

        .watchlist-item:hover {
            border-color: #1890ff;
            box-shadow: 0 4px 12px rgba(24, 144, 255, 0.12);
            transform: translateY(-1px);
        }

        .watchlist-item--active {
            border-color: #1890ff;
            box-shadow: 0 4px 14px rgba(24, 144, 255, 0.12);
            background: rgba(24, 144, 255, 0.06);
        }

        .watchlist-item__header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 12px;
            flex-wrap: wrap;
        }

        .watchlist-item__info {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .watchlist-item__code {
            font-weight: 600;
            font-size: 14px;
            color: #262626;
        }

        .watchlist-item__meta {
            font-size: 12px;
            color: #9c9c9c;
        }

        .watchlist-item__body {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .watchlist-item__row {
            display: flex;
            align-items: center;
            gap: 8px;
            flex-wrap: wrap;
        }

        .watchlist-label {
            font-size: 12px;
            color: #888;
            min-width: 48px;
        }

        .watchlist-item__levels {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }

        .level-selector {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .level-selector-actions {
            display: flex;
            justify-content: flex-end;
            gap: 8px;
        }

        .dark-theme .stock-add-card,
        .dark-theme .watchlist-empty,
        .dark-theme .watchlist-item {
            background: #141414;
            border-color: #333;
        }

        .dark-theme .watchlist-item--active {
            border-color: #177ddc;
            background: rgba(64, 169, 255, 0.18);
            box-shadow: 0 6px 16px rgba(24, 144, 255, 0.2);
        }

        .dark-theme .stock-manager-title {
            color: #f0f0f0;
        }

        .dark-theme .stock-manager-subtitle,
        .dark-theme .stock-add-hint,
        .dark-theme .watchlist-item__meta,
        .dark-theme .watchlist-label {
            color: #bfbfbf;
        }

        .dark-theme .watchlist-item__code {
            color: #fafafa;
        }

        /* Chart Grid */
        .chart-grid {
            display: grid;
            gap: 16px;
            flex: 1;
            min-height: 0;
            grid-auto-rows: minmax(0, 1fr);
        }

        .chart-grid-1x1 {
            grid-template-columns: 1fr;
        }

        .chart-grid-2x1 {
            grid-template-columns: repeat(2, 1fr);
        }

        .chart-grid-2x2 {
            grid-template-columns: repeat(2, 1fr);
            grid-template-rows: repeat(2, minmax(600px, 1fr));
        }

        .chart-grid-3x2 {
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(2, minmax(600px, 1fr));
        }

        .chart-card {
            background: white;
            border-radius: 8px;
            padding: 16px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            display: flex;
            flex-direction: column;
            height: 100%;
            min-height: 520px;
        }

        .stock-chart-group {
            background: white;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.08);
            padding: 16px;
            display: flex;
            flex-direction: column;
            gap: 16px;
            flex: 1;
            min-height: 0;
        }

        .stock-chart-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .stock-chart-title {
            font-size: 18px;
            font-weight: 600;
            color: #262626;
        }

        .stock-chart-toolbar {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            align-items: center;
            margin-bottom: 8px;
        }

        .period-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .period-buttons .ant-btn {
            min-width: 48px;
        }

        .multi-mode-indicator {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 12px;
            color: #666;
        }

.stock-chart-panels {
    display: grid;
    flex: 1;
    min-height: 0;
    gap: 16px;
    overflow: auto;
    grid-auto-rows: minmax(520px, 1fr);
}

.stock-chart-panels.columns-1 {
    grid-template-columns: 1fr;
    grid-auto-rows: minmax(640px, auto);
}

        .stock-chart-panels.columns-2 {
            grid-template-columns: repeat(2, minmax(0, 1fr));
        }

        .stock-chart-panels.columns-3 {
            grid-template-columns: repeat(3, minmax(0, 1fr));
        }

.stock-chart-panels.columns-4 {
    grid-template-columns: repeat(2, minmax(0, 1fr));
    grid-auto-rows: minmax(320px, 1fr);
}

        .chart-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
            padding-bottom: 12px;
            border-bottom: 1px solid #f0f0f0;
        }

        .chart-title {
            font-size: 16px;
            font-weight: 600;
            color: #262626;
        }

        .chart-wrapper {
            flex: 1;
            min-height: 320px;
        }

        .chart-container {
            width: 100%;
            height: 100%;
        }

        .chart-summary-wrapper {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 8px;
            margin-bottom: 6px;
            align-items: stretch;
        }

        .chart-summary-card,
        .chart-hover-card {
            background: #fafafa;
            border: 1px solid #e8e8e8;
            border-radius: 6px;
            padding: 8px;
        }

        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 4px;
            margin-bottom: 4px;
        }

        .card-header .card-title {
            font-size: 11px;
            font-weight: 600;
            color: #666;
        }

        .hover-info-grid {
            display: grid;
            grid-template-columns: repeat(4, minmax(0, 1fr));
            column-gap: 6px;
            row-gap: 4px;
            font-size: 11px;
            color: #555;
        }

        .hover-info-cell {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 4px;
            line-height: 1.2;
        }

        .hover-info-label {
            color: #8c8c8c;
            white-space: nowrap;
        }

        .hover-info-value {
            font-weight: 600;
            color: #262626;
            white-space: nowrap;
        }

        .hover-info-cell--full {
            grid-column: 1 / -1;
        }

        @media (max-width: 900px) {
            .chart-summary-wrapper {
                grid-template-columns: 1fr;
            }
        }

        @media (max-width: 680px) {
            .hover-info-grid {
                grid-template-columns: repeat(2, minmax(0, 1fr));
            }
        }

        .chart-signal-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 3px;
            margin-top: 4px;
        }

        .chart-info-placeholder {
            color: #a6a6a6;
            font-size: 12px;
        }

        .chart-stats-grid {
            display: grid;
            grid-template-columns: repeat(3, minmax(60px, auto));
            gap: 8px 12px;
            font-size: 12px;
            color: #555;
        }

        .chart-stats-item {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .chart-stats-label {
            color: #8c8c8c;
        }

        .chart-stats-value {
            font-weight: 600;
            color: #262626;
        }

        .chart-bsp-types {
            margin-top: 8px;
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }

        .chart-type-chip {
            font-size: 11px;
            background: rgba(24, 144, 255, 0.12);
            color: #1890ff;
            padding: 2px 6px;
            border-radius: 999px;
        }

        .dark-theme .chart-summary-card,
        .dark-theme .chart-hover-card {
            background: #1f1f1f;
            border-color: #333;
        }

        .dark-theme .card-header .card-title {
            color: #bfbfbf;
        }

        .dark-theme .hover-info-label,
        .dark-theme .chart-stats-label {
            color: #a6a6a6;
        }

        .dark-theme .hover-info-value,
        .dark-theme .chart-stats-value {
            color: #f0f0f0;
        }

        .dark-theme .chart-type-chip {
            background: rgba(24, 144, 255, 0.2);
            color: #69c0ff;
        }

        /* Indicator Config */
        .indicator-section {
            margin-bottom: 16px;
        }

        .indicator-section-title {
            font-weight: 600;
            margin-bottom: 12px;
            color: #262626;
            font-size: 14px;
        }

        .indicator-item {
            margin-bottom: 8px;
        }

        /* Responsive */
        @media (max-width: 1400px) {
            .left-sidebar { width: 240px; }
            .right-sidebar { width: 280px; }
        }

        @media (max-width: 1200px) {
            .chart-grid-3x2 {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        @media (max-width: 768px) {
            .app-content {
                flex-direction: column;
            }
            .sidebar {
                width: 100% !important;
                max-height: 300px;
            }
            .chart-grid-2x1,
            .chart-grid-2x2,
            .chart-grid-3x2 {
                grid-template-columns: 1fr;
            }
        }

        /* Dark theme support */
        .dark-theme {
            background: #141414;
        }

.dark-theme .sidebar,
.dark-theme .chart-card,
.dark-theme .stock-chart-group {
    background: #1f1f1f;
    color: #e8e8e8;
}

.dark-theme .stock-chart-toolbar {
    color: #9a9a9a;
}

.dark-theme .stock-chart-title {
    color: #f0f0f0;
}

.dark-theme .main-content {
    background: #000;
}

.alert-panel {
    display: flex;
    flex-direction: column;
    gap: 12px;
}

.alert-status {
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 12px;
}

.alert-status-indicator {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    font-weight: 500;
}

.status-dot {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    background: #bfbfbf;
    box-shadow: 0 0 0 2px rgba(0,0,0,0.06);
}

.status-dot--online {
    background: #52c41a;
}

.status-dot--offline {
    background: #faad14;
}

.alert-error-text {
    color: #ff4d4f;
    font-size: 12px;
}

.alert-strategy-tags {
    display: flex;
    flex-wrap: wrap;
    gap: 6px;
}

.alert-history {
    max-height: 320px;
    overflow-y: auto;
    display: flex;
    flex-direction: column;
    gap: 8px;
}

.alert-card {
    border: 1px solid #e8e8e8;
    border-radius: 6px;
    padding: 8px;
    background: #fafafa;
}

.alert-card-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.alert-card-title {
    font-size: 12px;
    font-weight: 600;
    color: #262626;
}

.alert-card-message {
    margin-top: 6px;
    font-size: 12px;
    color: #444;
    line-height: 1.4;
}

.alert-card-meta {
    margin-top: 6px;
    display: flex;
    justify-content: space-between;
    font-size: 11px;
    color: #8c8c8c;
}

.dark-theme .alert-card {
    background: #1f1f1f;
    border-color: #333;
}

.dark-theme .alert-card-title {
    color: #f0f0f0;
}

.dark-theme .alert-card-message {
    color: #d9d9d9;
}

.dark-theme .alert-card-meta {
    color: #a6a6a6;
}
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { Layout, Button, Input, Select, Checkbox, message, Spin, Tag, Space, Tooltip, Radio, InputNumber, Slider, Switch, Tabs, Collapse, Divider, Popover, DatePicker, Segmented, List, Empty, AutoComplete } = antd;
        const { Header, Sider, Content } = Layout;
        const { useState, useEffect, useCallback, useContext, createContext, useRef, memo, useMemo } = React;
        const dayjs = window.dayjs;

        // ============= Version & Debug Info =============
        console.log('üöÄ Chan.py Web v4.1.0 - KLineChart + Full Chan Theory Support');
        console.log('üìÖ Loaded at:', new Date().toISOString());
        console.log('‚úÖ Bi/Seg/ZS/BSP fully implemented with KLineChart overlay API');
        console.log('üéØ All Chan theory indicators working perfectly!');
        
        // Check if KLineChart is loaded
        if (typeof klinecharts === 'undefined') {
            console.error('‚ùå KLineChart library not loaded! Check CDN.');
            console.error('üí° Try refreshing the page or check network in DevTools.');
        } else {
            console.log('‚úÖ KLineChart library loaded:', klinecharts.version || 'version unknown');
        }

        // ============= Constants =============
        const API_BASE = 'http://localhost:8000';
        
        const LEVEL_OPTIONS = [
            { value: 'day', label: 'Êó•Á∫ø' },
            { value: '60m', label: '60ÂàÜ' },
            { value: '30m', label: '30ÂàÜ' },
            { value: '15m', label: '15ÂàÜ' },
            { value: '5m', label: '5ÂàÜ' },
        ];
        const DEFAULT_LEVEL = 'day';
        const LINE_STYLE_OPTIONS = [
            { value: 'solid', label: 'ÂÆûÁ∫ø' },
            { value: 'dashed', label: 'ËôöÁ∫ø' },
            { value: 'dotted', label: 'ÁÇπÁ∫ø' },
        ];

        const QUICK_STOCKS = [
            { code: 'sz.000001', name: 'Âπ≥ÂÆâÈì∂Ë°å' },
            { code: 'sh.600000', name: 'Êµ¶ÂèëÈì∂Ë°å' },
            { code: 'sh.600036', name: 'ÊãõÂïÜÈì∂Ë°å' },
            { code: 'sh.000300', name: 'Ê≤™Ê∑±300' },
        ];

        const DEFAULT_INDICATORS = {
            plot_bi: true,
            plot_seg: true,
            plot_zs: false,
            plot_bsp: true,
            plot_ma: true,
            plot_macd: true,
            plot_boll: false,
            plot_kdj: false,
            plot_rsi: false,
            plot_volume: true,
            begin_time: '2023-01-01',
            limit_kl_count: null,
            ma_params: [5, 10, 20, 60],
            kdj_period: 9,
            rsi_period: 14,
            zs_source: 'bi',
            bi_color: '#2196F3',
            bi_line_style: 'solid',
            bi_line_width: 2,
            seg_color: '#9C27B0',
            seg_line_style: 'solid',
            seg_line_width: 3,
            zs_border_color: '#FFC107',
            zs_border_style: 'dashed',
            zs_border_size: 1,
            zs_fill_color: '#FFC107',
            zs_fill_opacity: 0.2,
            zs_show_label: true,
            zs_label_color: '#FFC107',
            indicator_layout: 'stack',
            indicator_tab: 'macd',
            highlight_chan_kline: true,
            chan_kline_color: '#FF9800',
            chan_kline_show_label: false,
        };

        const MA_OPTIONS = [5, 10, 20, 30, 45, 60, 120, 250];
        const ALERT_HISTORY_LIMIT = 120;

        const DEFAULT_CHAN_CONFIG = {
            bi_algo: 'normal',
            bi_strict: true,
            bi_fx_check: 'strict',
            gap_as_kl: false,
            bi_end_is_peak: true,
            bi_allow_sub_peak: true,
            seg_algo: 'chan',
            left_seg_method: 'peak',
            zs_combine: true,
            zs_combine_mode: 'zs',
            one_bi_zs: false,
            zs_algo: 'normal',
            trigger_step: false,
            skip_step: 0,
            kl_data_check: true,
            max_kl_misalgin_cnt: 2,
            max_kl_inconsistent_cnt: 5,
            auto_skip_illegal_sub_lv: false,
            print_warning: false,
            print_err_time: true,
            mean_metrics: [],
            trend_metrics: [],
            macd: { fast: 12, slow: 26, signal: 9 },
            boll_n: 20,
            cal_rsi: false,
            rsi_cycle: 14,
            cal_kdj: false,
            kdj_cycle: 9,
            cal_demark: false,
            demark: {
                demark_len: 9,
                setup_bias: 4,
                countdown_bias: 2,
                max_countdown: 13,
                tiaokong_st: true,
                setup_cmp2close: true,
                countdown_cmp2close: true,
            },
        };

        const BI_ALGO_OPTIONS = [
            { value: 'normal', label: 'normal' },
            { value: 'fx', label: 'fx' },
        ];

        const SEG_ALGO_OPTIONS = [
            { value: 'chan', label: 'chan' },
            { value: '1+1', label: '1+1 (deprecated)' },
            { value: 'break', label: 'break (deprecated)' },
        ];

        // ============= Data Cache =============
        const DataCache = {
            cache: {},
            get(key) {
                const item = this.cache[key];
                if (item && Date.now() - item.timestamp < 5 * 60 * 1000) {
                    return item.data;
                }
                return null;
            },
            set(key, data) {
                this.cache[key] = { data, timestamp: Date.now() };
            },
            clear() {
                this.cache = {};
            }
        };

        // ============= Utility Functions =============
        const convertTime = (timeStr) => {
            if (!timeStr) return null;
            let normalized = String(timeStr).trim().replace(/\//g, '-');
            if (!normalized.includes('T') && normalized.includes(' ')) {
                normalized = normalized.replace(' ', 'T');
            }
            normalized = normalized.replace(/(\.\d+)(?=[+-]|Z|$)/, '');
            if (/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}$/.test(normalized)) {
                normalized = `${normalized}:00`;
            }
            const parsed = dayjs(normalized);
            if (parsed.isValid()) {
                return parsed.valueOf();
            }
            const fallback = new Date(normalized.replace('T', ' '));
            const ts = fallback.getTime();
            return Number.isNaN(ts) ? null : ts;
        };

        let chanOverlayRegistered = false;
        const registerChanOverlay = () => {
            if (chanOverlayRegistered) return;
            if (typeof klinecharts === 'undefined' || typeof klinecharts.registerOverlay !== 'function') {
                return;
            }
            klinecharts.registerOverlay({
                name: 'chanZone',
                totalStep: 0,
                needDefaultPointFigure: false,
                createPointFigures: ({ coordinates, overlay }) => {
                    if (!Array.isArray(coordinates) || coordinates.length < 4) {
                        return [];
                    }
                    const [topLeft, topRight, bottomRight, bottomLeft] = coordinates;
                    const fillColor = overlay.extendData?.fillColor || 'rgba(255, 152, 0, 0.22)';
                    const borderColor = overlay.extendData?.borderColor || '#FF9800';
                    const borderDashed = overlay.extendData?.borderDashed ?? [4, 3];
                    const borderSize = typeof overlay.extendData?.borderSize === 'number' ? overlay.extendData.borderSize : 1;
                    const borderStyle = overlay.extendData?.borderStyle
                        || (Array.isArray(borderDashed) && borderDashed.length ? 'dashed' : 'solid');
                    const label = overlay.extendData?.label;
                    const textColor = overlay.extendData?.labelColor || borderColor;

                    const rect = {
                        type: 'rect',
                        attrs: {
                            x: Math.min(topLeft.x, bottomLeft.x),
                            y: Math.min(topLeft.y, topRight.y),
                            width: Math.max(2, Math.abs(topRight.x - topLeft.x)),
                            height: Math.max(2, Math.abs(bottomLeft.y - topLeft.y)),
                        },
                        styles: {
                            color: fillColor,
                            borderColor,
                            borderSize,
                            borderStyle,
                            ...(Array.isArray(borderDashed) && borderDashed.length
                                ? { borderDashedValue: borderDashed }
                                : {}),
                        },
                    };

                    const figures = [rect];
                    if (label) {
                        figures.push({
                            type: 'text',
                            attrs: {
                                x: Math.min(topLeft.x, topRight.x) + 6,
                                y: Math.min(topLeft.y, topRight.y) - 6,
                                text: label,
                                align: 'left',
                                baseline: 'bottom',
                            },
                            styles: {
                                color: textColor,
                                size: 10,
                                family: 'sans-serif',
                                weight: '600',
                            },
                        });
                    }
                    return figures;
                },
            });
            chanOverlayRegistered = true;
        };

        const formatDateTime = (timestamp) => {
            if (!timestamp) return '--';
            return dayjs(timestamp).format('YYYY-MM-DD HH:mm');
        };

        const formatNumber = (value, digits = 2) => {
            if (!Number.isFinite(value)) return '--';
            return Number(value).toFixed(digits);
        };

        const formatVolume = (value) => {
            if (!Number.isFinite(value) || value === 0) return '--';
            if (Math.abs(value) >= 1e8) {
                return `${(value / 1e8).toFixed(2)}‰∫ø`;
            }
            if (Math.abs(value) >= 1e4) {
                return `${(value / 1e4).toFixed(2)}‰∏á`;
            }
            return value.toFixed(0);
        };

        const getLineStyleConfig = (styleKey) => {
            switch (styleKey) {
                case 'dashed':
                    return { style: 'dashed', dashedValue: [6, 4] };
                case 'dotted':
                    return { style: 'dashed', dashedValue: [2, 2] };
                default:
                    return { style: 'solid', dashedValue: undefined };
            }
        };

        const hexToRgba = (hex, opacity = 0.3) => {
            if (!hex) return `rgba(255, 193, 7, ${opacity})`;
            let normalized = hex.replace('#', '');
            if (normalized.length === 3) {
                normalized = normalized.split('').map((char) => char + char).join('');
            }
            const bigint = parseInt(normalized, 16);
            const r = (bigint >> 16) & 255;
            const g = (bigint >> 8) & 255;
            const b = bigint & 255;
            return `rgba(${r}, ${g}, ${b}, ${opacity})`;
        };

        const debounce = (func, wait) => {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        };

        const clamp = (value, min, max) => Math.min(Math.max(value, min), max);

        // ============= Config Management =============
        const loadConfig = () => {
            try {
                const config = localStorage.getItem('chanlun_config');
                return config ? JSON.parse(config) : null;
            } catch (e) {
                console.error('Failed to load config:', e);
                return null;
            }
        };

        const sanitizeIndicators = (raw) => {
            if (!raw || typeof raw !== 'object') {
                return {};
            }
            const { bi_strict, seg_algo, zs_algo, ...rest } = raw;
            return rest;
        };

        // ============= API Service =============
        const api = {
            async calculateChan(params) {
                console.log('üåê [API] Request:', params);
                const response = await fetch(`${API_BASE}/api/analysis/calculate`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(params),
                });
                if (!response.ok) {
                    throw new Error(`API Error: ${response.statusText}`);
                }
                const result = await response.json();
                console.log('üåê [API] Response:', {
                    chan_kline_count: result.kline_data?.length,
                    raw_kline_count: result.raw_kline_data?.length,
                    bi_count: result.bi_list?.length,
                    seg_count: result.seg_list?.length,
                });
                return result;
            },
            async getAlertHistory(limit = 50) {
                const response = await fetch(`${API_BASE}/api/alerts/history?limit=${limit}`);
                if (!response.ok) {
                    throw new Error(`API Error: ${response.statusText}`);
                }
                return response.json();
            },
            async listAlertStrategies() {
                const response = await fetch(`${API_BASE}/api/alerts/strategies`);
                if (!response.ok) {
                    throw new Error(`API Error: ${response.statusText}`);
                }
                return response.json();
            },
            async searchStocks(keyword) {
                if (!keyword || !keyword.trim()) {
                    return [];
                }
                const response = await fetch(`${API_BASE}/api/analysis/stock/search?keyword=${encodeURIComponent(keyword.trim())}`);
                if (!response.ok) {
                    throw new Error(`API Error: ${response.statusText}`);
                }
                const result = await response.json();
                return Array.isArray(result.results) ? result.results : [];
            },
        };

        // ============= App Context =============
        const AppContext = createContext();
        const useApp = () => useContext(AppContext);

        // ============= Chart Component =============
        const ChartPanel = memo(({ stockCode, level, data, loading, stats }) => {
            const chartRef = useRef(null);
            const chartInstanceRef = useRef(null);
            const { indicators, theme, registerChartInstance, unregisterChartInstance, syncVisibleRange } = useApp();
            const chartKey = `${stockCode}-${level}`;
            const candleDataRef = useRef([]);
            const candleMapRef = useRef(new Map());
            const bspMapRef = useRef(new Map());
            const timestampsRef = useRef([]);
            const lastHoverRef = useRef(null);
            const suppressBroadcastRef = useRef(false);
            const [hoverInfo, setHoverInfo] = useState(null);
            const updateHoverInfo = useCallback((timestamp) => {
                if (!timestamp) {
                    lastHoverRef.current = null;
                    setHoverInfo(null);
                    return;
                }
                const candle = candleMapRef.current.get(timestamp);
                if (!candle) {
                    return;
                }
                const signals = bspMapRef.current.get(timestamp) || [];
                const prev = lastHoverRef.current;
                if (prev && prev.timestamp === timestamp && prev.signalsLength === signals.length) {
                    return;
                }
                lastHoverRef.current = { timestamp, signalsLength: signals.length };
                setHoverInfo({
                    timestamp,
                    open: candle.open,
                    high: candle.high,
                    low: candle.low,
                    close: candle.close,
                    volume: candle.volume,
                    signals: signals.map(item => ({
                        type: item.type,
                        isBuy: !!item.is_buy,
                    })),
                });
            }, []);
            const findNearestIndex = useCallback((timestamp) => {
                const list = timestampsRef.current;
                if (!Array.isArray(list) || list.length === 0 || !Number.isFinite(timestamp)) {
                    return null;
                }
                let left = 0;
                let right = list.length - 1;
                if (timestamp <= list[left]) return left;
                if (timestamp >= list[right]) return right;
                while (left <= right) {
                    const mid = Math.floor((left + right) / 2);
                    const midTs = list[mid];
                    if (midTs === timestamp) {
                        return mid;
                    }
                    if (midTs < timestamp) {
                        left = mid + 1;
                    } else {
                        right = mid - 1;
                    }
                }
                if (left >= list.length) return list.length - 1;
                if (right < 0) return 0;
                const leftDiff = Math.abs(list[left] - timestamp);
                const rightDiff = Math.abs(list[right] - timestamp);
                return leftDiff <= rightDiff ? left : right;
            }, []);
            const getIndexRangeForTimestamps = useCallback((fromTs, toTs) => {
                const list = timestampsRef.current;
                if (!Array.isArray(list) || list.length === 0) {
                    console.log('‚ö†Ô∏è [IndexRange] empty timestamps', chartKey);
                    return null;
                }
                const fromIdx = findNearestIndex(fromTs);
                const toIdx = findNearestIndex(toTs);
                if (fromIdx == null || toIdx == null) {
                    console.log('‚ö†Ô∏è [IndexRange] nearest index missing', chartKey, { fromTs, toTs, fromIdx, toIdx });
                    return null;
                }
                const start = Math.min(fromIdx, toIdx);
                const end = Math.max(fromIdx, toIdx);
                const padding = Math.max(2, Math.floor((end - start) * 0.05));
                const minIdx = clamp(start - padding, 0, list.length - 1);
                const maxIdx = clamp(end + padding, 0, list.length - 1);
                console.log('üßÆ [IndexRange]', chartKey, { fromTs, toTs, fromIdx: minIdx, toIdx: maxIdx, total: list.length });
                if (minIdx === maxIdx && list.length > 1) {
                    const extra = Math.min(5, list.length - 1);
                    return [clamp(minIdx - 2, 0, list.length - 1), clamp(maxIdx + extra, 0, list.length - 1)];
                }
                return [minIdx, maxIdx];
            }, [findNearestIndex]);

            useEffect(() => {
                if (!chartRef.current || !data) {
                    setHoverInfo(null);
                    timestampsRef.current = [];
                    return;
                }

                // Reset cached data
                candleDataRef.current = [];
                candleMapRef.current = new Map();
                bspMapRef.current = new Map();
                timestampsRef.current = [];
                lastHoverRef.current = null;
                setHoverInfo(null);

                // Initialize KLineChart
                const chart = klinecharts.init(chartRef.current);
                chartInstanceRef.current = chart;

                // Apply theme
                chart.setStyles({
                    grid: {
                        show: true,
                        horizontal: {
                            show: true,
                            color: theme === 'dark' ? '#333' : '#f0f0f0',
                        },
                        vertical: {
                            show: true,
                            color: theme === 'dark' ? '#333' : '#f0f0f0',
                        }
                    },
                    candle: {
                        type: 'candle_solid',
                        bar: {
                            upColor: '#ef5350',
                            downColor: '#26a69a',
                            noChangeColor: '#888888',
                            upBorderColor: 'rgba(0,0,0,0)',
                            downBorderColor: 'rgba(0,0,0,0)',
                            noChangeBorderColor: 'rgba(0,0,0,0)',
                            upWickColor: '#ef5350',
                            downWickColor: '#26a69a',
                            noChangeWickColor: '#888888',
                        },
                        tooltip: {
                            showRule: 'none',
                            showType: 'standard',
                        }
                    },
                    indicator: {
                        tooltip: {
                            showRule: 'none',
                        }
                    }
                });

                // Prepare candle data
                const chanKlineMeta = Array.isArray(data.kline_data) ? data.kline_data : [];
                const rawChildMap = new Map();
                chanKlineMeta.forEach(item => {
                    if (!Array.isArray(item.chan_children)) {
                        return;
                    }
                    item.chan_children.forEach(child => {
                        const ts = convertTime(child.time);
                        if (!ts || rawChildMap.has(ts)) {
                            return;
                        }
                        rawChildMap.set(ts, {
                            timestamp: ts,
                            open: parseFloat(child.open),
                            high: parseFloat(child.high),
                            low: parseFloat(child.low),
                            close: parseFloat(child.close),
                            volume: parseFloat(child.volume || 0),
                        });
                    });
                });

                const fallbackCandles = (data.kline_data || []).map(k => ({
                    timestamp: convertTime(k.time),
                    open: parseFloat(k.open),
                    high: parseFloat(k.high),
                    low: parseFloat(k.low),
                    close: parseFloat(k.close),
                    volume: parseFloat(k.volume || 0),
                })).filter(k => k.timestamp !== null);
                const rawCandles = Array.from(rawChildMap.values()).sort((a, b) => a.timestamp - b.timestamp);
                const candleData = rawCandles.length > 0 ? rawCandles : fallbackCandles;
                candleDataRef.current = candleData;
                timestampsRef.current = candleData.map(item => item.timestamp);

                const candleMap = new Map();
                candleData.forEach(item => {
                    candleMap.set(item.timestamp, item);
                });
                candleMapRef.current = candleMap;

                const bspMap = new Map();
                if (Array.isArray(data.bsp_list)) {
                    data.bsp_list.forEach(bsp => {
                        const ts = convertTime(bsp.time);
                        if (!ts) return;
                        if (!bspMap.has(ts)) {
                            bspMap.set(ts, []);
                        }
                        bspMap.get(ts).push(bsp);
                    });
                }
                bspMapRef.current = bspMap;

                console.log('üìä [KLineChart] Loading', candleData.length, 'candles');
                chart.applyNewData(candleData);

                if (indicators.highlight_chan_kline && chanKlineMeta.length > 0) {
                    console.log('üß© Chan K-line stats', chanKlineMeta.slice(0, 3));
                    const chanBorderColor = indicators.chan_kline_color || '#FF9800';
                    const borderDashed = [4, 3];
                    registerChanOverlay();
                    try {
                        const removed = chart.removeOverlay({ groupId: 'chan_kline_group' });
                        if (removed) {
                            console.log('üßπ Cleared Chan K-line overlays:', removed.length);
                        }
                    } catch (error) {
                        console.warn('‚ö†Ô∏è Unable to clear previous Chan K-line overlays', error);
                    }

                    const composedCount = chanKlineMeta.filter(item => (item.chan_sub_count ?? item.sub_count ?? 1) > 1).length;
                    chanKlineMeta.forEach((item, idx) => {
                        const subCount = Number(item.chan_sub_count ?? item.sub_count ?? item.components ?? 1);
                        const isComposed = item.chan_is_composed === true || subCount > 1;
                        if (!isComposed) {
                            return;
                        }

                        let startTs = convertTime(item.time);
                        if (!startTs) {
                            return;
                        }

                        let endTs = convertTime(item.end_time);
                        const children = Array.isArray(item.chan_children) ? item.chan_children : [];
                        let highVal = Number(item.high);
                        let lowVal = Number(item.low);
                        if (children.length > 0) {
                            const childStart = convertTime(children[0]?.time);
                            const childEnd = convertTime(children[children.length - 1]?.end_time || children[children.length - 1]?.time);
                            if (childStart) {
                                startTs = childStart;
                            }
                            if (childEnd && childEnd > startTs) {
                                endTs = childEnd;
                            }
                            const childHighs = children.map(child => Number(child.high)).filter(Number.isFinite);
                            const childLows = children.map(child => Number(child.low)).filter(Number.isFinite);
                            if (!Number.isFinite(highVal) && childHighs.length > 0) {
                                highVal = Math.max(...childHighs);
                            }
                            if (!Number.isFinite(lowVal) && childLows.length > 0) {
                                lowVal = Math.min(...childLows);
                            }
                        }

                        const nextChanStart = convertTime(chanKlineMeta[idx + 1]?.time);
                        if (!endTs || endTs <= startTs) {
                            if (nextChanStart && nextChanStart > startTs) {
                                endTs = nextChanStart;
                            } else {
                                const prevChanStart = convertTime(chanKlineMeta[idx - 1]?.time);
                                const averageSpan = prevChanStart && startTs > prevChanStart ? startTs - prevChanStart : 60000;
                                endTs = startTs + Math.max(averageSpan, 60000);
                            }
                        }

                        if (nextChanStart && nextChanStart > endTs) {
                            endTs = Math.min(endTs, nextChanStart);
                        }

                        if (!Number.isFinite(highVal) || !Number.isFinite(lowVal)) {
                            return;
                        }

                        const showLabel = !!indicators.chan_kline_show_label;

                        const fillColor = theme === 'dark'
                            ? 'rgba(255, 152, 0, 0.16)'
                            : 'rgba(255, 152, 0, 0.26)';
                        const labelColor = theme === 'dark' ? '#FFE0B2' : '#B36B00';

                        const overlayId = chart.createOverlay({
                            name: 'chanZone',
                            id: `chan_kline_${idx}`,
                            groupId: 'chan_kline_group',
                            paneId: 'candle_pane',
                            points: [
                                { timestamp: startTs, value: highVal },
                                { timestamp: endTs, value: highVal },
                                { timestamp: endTs, value: lowVal },
                                { timestamp: startTs, value: lowVal },
                            ],
                            extendData: {
                                fillColor,
                                borderColor: chanBorderColor,
                                borderDashed,
                                label: showLabel ? `${subCount}K` : undefined,
                                labelColor,
                            },
                        });

                        if (idx < 5) {
                            console.log('üî∂ Chan K-line highlight', {
                                index: idx,
                                overlayId,
                                timestamp: startTs,
                                end: endTs,
                                high: highVal,
                                low: lowVal,
                                subCount,
                            });
                        }
                    });
                    console.log('‚ú® Highlighted Chan K-lines:', composedCount);
                } else {
                    try {
                        chart.removeOverlay({ groupId: 'chan_kline_group' });
                    } catch (error) {
                        // ignore when overlay absent
                    }
                }

                const indicatorLayout = indicators.indicator_layout || 'stack';
                const availableLower = LOWER_INDICATOR_KEYS.filter(key => indicators[`plot_${key}`]);
                let activeLower = availableLower;
                let activeTab = indicators.indicator_tab;
                if (indicatorLayout === 'tab') {
                    if (!availableLower.includes(activeTab)) {
                        activeTab = availableLower[0];
                    }
                    activeLower = activeTab ? [activeTab] : [];
                }

                const panes = [];
                if (indicators.plot_volume) {
                    panes.push({ name: 'VOL', paneId: 'vol_pane', type: 'volume' });
                }
                activeLower.forEach(key => {
                    panes.push({
                        name: key.toUpperCase(),
                        paneId: `${key}_pane`,
                        type: 'indicator',
                    });
                });

                const totalPanes = panes.length;
                let heightMap = {};
                if (indicatorLayout === 'tab') {
                    panes.forEach(pane => {
                        heightMap[pane.paneId] = pane.type === 'volume' ? 160 : 240;
                    });
                } else {
                    panes.forEach((pane, idx) => {
                        if (pane.type === 'volume') {
                            heightMap[pane.paneId] = Math.max(120, 180 - 20 * (totalPanes - 1 - idx));
                        } else {
                            heightMap[pane.paneId] = Math.max(150, 220 - 10 * (totalPanes - 1));
                        }
                    });
                }

                panes.forEach(pane => {
                    chart.createIndicator(pane.name, false, {
                        id: pane.paneId,
                        height: heightMap[pane.paneId],
                    });
                });

                // Adjust main pane height when lower panes exist
                if (typeof chart.setPaneOptions === 'function') {
                    try {
                        const lowerSpace = panes.length > 0 ? Math.min(0.45, panes.length * 0.14) : 0.0;
                        chart.setPaneOptions({ id: 'candle_pane', height: 1 - lowerSpace });
                    } catch (error) {
                        console.warn('‚ö†Ô∏è Unable to adjust candle pane height', error);
                    }
                }

                // Add MA overlays
                if (indicators.plot_ma && indicators.ma_params && indicators.ma_params.length > 0) {
                    const maParams = indicators.ma_params
                        .map(Number)
                        .filter(value => Number.isFinite(value) && value > 0)
                        .slice(0, 6);
                    if (maParams.length > 0) {
                        chart.createIndicator('MA', true, { id: 'candle_pane' }, {
                            calcParams: maParams,
                        });
                    }
                }

                // Add BOLL overlay
                if (indicators.plot_boll) {
                    chart.createIndicator('BOLL', true, { id: 'candle_pane' });
                }

                // ========== Áº†ËÆ∫ÊåáÊ†áÁªòÂà∂ ==========
                
                // 1. ÁªòÂà∂Á¨î (Bi) - ËìùËâ≤ÊäòÁ∫ø
                if (indicators.plot_bi && data.bi_list && data.bi_list.length > 0) {
                    console.log('üìä [Bi] Adding', data.bi_list.length, 'segments');
                    data.bi_list.forEach((bi, idx) => {
                        const beginTime = convertTime(bi.begin_time);
                        const endTime = convertTime(bi.end_time);
                        const biColor = indicators.bi_color || '#2196F3';
                        const biWidth = Number(indicators.bi_line_width) || 2;
                        const biStyleConfig = getLineStyleConfig(indicators.bi_line_style);
                        
                        if (beginTime && endTime) {
                            chart.createOverlay({
                                name: 'segment',
                                id: `bi_${idx}`,
                                groupId: 'bi_group',
                                paneId: 'candle_pane',
                                points: [
                                    { timestamp: beginTime, value: parseFloat(bi.begin_price) },
                                    { timestamp: endTime, value: parseFloat(bi.end_price) }
                                ],
                                styles: {
                                    line: {
                                        style: biStyleConfig.style,
                                        size: biWidth,
                                        color: biColor,
                                        ...(biStyleConfig.dashedValue ? { dashedValue: biStyleConfig.dashedValue } : {})
                                    }
                                }
                            });
                        }
                    });
                    console.log('‚úÖ [Bi] Added successfully');
                }

                // 2. ÁªòÂà∂Á∫øÊÆµ (Seg) - Á¥´Ëâ≤Á≤óÁ∫ø
                if (indicators.plot_seg && data.seg_list && data.seg_list.length > 0) {
                    console.log('üìä [Seg] Adding', data.seg_list.length, 'segments');
                    data.seg_list.forEach((seg, idx) => {
                        const beginTime = convertTime(seg.begin_time);
                        const endTime = convertTime(seg.end_time);
                        const segColor = indicators.seg_color || '#9C27B0';
                        const segWidth = Number(indicators.seg_line_width) || 3;
                        const segStyleConfig = getLineStyleConfig(indicators.seg_line_style);
                        
                        if (beginTime && endTime) {
                            chart.createOverlay({
                                name: 'segment',
                                id: `seg_${idx}`,
                                groupId: 'seg_group',
                                paneId: 'candle_pane',
                                points: [
                                    { timestamp: beginTime, value: parseFloat(seg.begin_price) },
                                    { timestamp: endTime, value: parseFloat(seg.end_price) }
                                ],
                                styles: {
                                    line: {
                                        style: segStyleConfig.style,
                                        size: segWidth,
                                        color: segColor,
                                        ...(segStyleConfig.dashedValue ? { dashedValue: segStyleConfig.dashedValue } : {})
                                    }
                                }
                            });
                        }
                    });
                    console.log('‚úÖ [Seg] Added successfully');
                }

                // 3. ÁªòÂà∂‰∏≠Êû¢ (ZhongShu) - ÈªÑËâ≤Áü©ÂΩ¢Âå∫Âüü
                const baseZsList = Array.isArray(data?.zs_list) ? data.zs_list : [];
                const segZsList = Array.isArray(data?.seg_zs_list) ? data.seg_zs_list : [];
                const zsSource = indicators.zs_source || 'bi';
                let zsData = [];
                if (zsSource === 'seg') {
                    zsData = segZsList.length > 0 ? segZsList : baseZsList;
                } else if (zsSource === 'both') {
                    zsData = [...baseZsList, ...segZsList];
                } else {
                    zsData = baseZsList;
                }

                const zsEmptyMessageKey = 'zs-empty-hint';
                if (chart.removeOverlay) {
                    try {
                        const removed = chart.removeOverlay({ groupId: 'zs_group' });
                        if (removed && removed.length) {
                            console.log('üßπ [ZS] Cleared previous overlays:', removed.length);
                        }
                    } catch (error) {
                        console.warn('‚ö†Ô∏è [ZS] Unable to clear previous overlays', error);
                    }
                }

                if (indicators.plot_zs && zsSource === 'bi') {
                    if (zsData.length === 0) {
                        const segCount = segZsList.length;
                        message.open({
                            key: zsEmptyMessageKey,
                            type: 'info',
                            duration: 3,
                            content: segCount > 0
                                ? 'ÂΩìÂâçÁ¨î‰∏≠Êû¢‰∏∫Á©∫ÔºåÂèØÂºÄÂêØÂè≥‰æß„ÄåÂçïÁ¨î‰∏≠Êû¢„ÄçÊàñÂ∞ÜÊù•Ê∫êÂàáÊç¢‰∏∫Á∫øÊÆµ‰∏≠Êû¢Êü•Áúã„ÄÇ'
                                : 'ÂΩìÂâçÁ¨î‰∏≠Êû¢Êï∞Èáè‰∏∫ 0ÔºåËØ∑Â∞ùËØïÊîæÂÆΩÊó∂Èó¥ËåÉÂõ¥ÊàñË∞ÉÊï¥‰∏≠Êû¢ÂèÇÊï∞„ÄÇ',
                        });
                    } else {
                        message.destroy(zsEmptyMessageKey);
                    }
                }

                if (indicators.plot_zs && zsData.length > 0) {
                    console.log('üìä [ZS] Using source', zsSource, 'total', zsData.length);
                    zsData.forEach((zs, idx) => {
                        if (idx === 0) {
                            console.log('üüß [ZS] Sample payload', zs);
                        }
                        const beginTime = convertTime(zs.begin_time);
                        const endTime = convertTime(zs.end_time);
                        const high = parseFloat(zs.high ?? zs.zg);
                        const low = parseFloat(zs.low ?? zs.zd);

                        if (beginTime && endTime && Number.isFinite(high) && Number.isFinite(low)) {
                            registerChanOverlay();
                            const sourceTag = zs.source || zsSource || 'bi';
                            const borderStyleConfig = getLineStyleConfig(indicators.zs_border_style);
                            const fillColor = hexToRgba(indicators.zs_fill_color, indicators.zs_fill_opacity ?? 0.2);
                            const borderColor = indicators.zs_border_color || '#FFC107';
                            const dashedValue = Array.isArray(borderStyleConfig.dashedValue)
                                ? borderStyleConfig.dashedValue
                                : [];
                            const borderSize = Number(indicators.zs_border_size) || 1;
                            const baseLabel = sourceTag === 'seg' ? 'Á∫øÊÆµ‰∏≠Êû¢' : 'Á¨î‰∏≠Êû¢';
                            const levelValue = zs.level;
                            const levelLabel = (typeof levelValue === 'number' && Number.isFinite(levelValue))
                                ? `Lv ${levelValue}`
                                : (typeof levelValue === 'string' && levelValue.trim() ? levelValue : '');
                            const unit = zs.component_unit || (sourceTag === 'seg' ? 'ÊÆµ' : 'Á¨î');
                            let countLabel = '';
                            const componentCount = Number.isFinite(zs.component_count) ? zs.component_count
                                : Number.isFinite(zs.bi_count) ? zs.bi_count
                                : null;
                            if (componentCount !== null) {
                                const unitLabel = componentCount === zs.bi_count && sourceTag !== 'seg' ? 'Á¨î' : unit;
                                countLabel = `${componentCount}${unitLabel}`;
                            } else if (zs.is_one_bi) {
                                countLabel = 'ÂçïÁ¨î';
                            }
                            const labelText = [baseLabel, levelLabel, countLabel].filter(Boolean).join(' ¬∑ ') || baseLabel;

                            chart.createOverlay({
                                name: 'chanZone',
                                id: `zs_${sourceTag}_${idx}`,
                                groupId: 'zs_group',
                                paneId: 'candle_pane',
                                points: [
                                    { timestamp: beginTime, value: high },
                                    { timestamp: endTime, value: high },
                                    { timestamp: endTime, value: low },
                                    { timestamp: beginTime, value: low },
                                ],
                                extendData: {
                                    fillColor,
                                    borderColor,
                                    borderDashed: dashedValue,
                                    borderSize,
                                    borderStyle: borderStyleConfig.style,
                                    labelColor: indicators.zs_label_color || '#FFC107',
                                },
                            });

                            if (indicators.zs_show_label) {
                                const midpoint = beginTime && endTime ? Math.floor(beginTime + (endTime - beginTime) / 2) : beginTime;
                                chart.createOverlay({
                                    name: 'simpleAnnotation',
                                    id: `zs_label_${sourceTag}_${idx}`,
                                    groupId: 'zs_group',
                                    paneId: 'candle_pane',
                                    points: [{ timestamp: midpoint, value: high }],
                                    styles: {
                                        position: 'top',
                                        offset: [0, -16],
                                        symbol: {
                                            type: 'none',
                                            size: 0,
                                        },
                                        text: {
                                            color: indicators.zs_label_color || '#FFC107',
                                            size: 12,
                                            weight: '600',
                                            value: labelText,
                                        },
                                        background: {
                                            color: theme === 'dark' ? 'rgba(0, 0, 0, 0.6)' : 'rgba(255, 255, 255, 0.8)',
                                            borderRadius: 4,
                                            padding: { left: 6, right: 6, top: 2, bottom: 2 },
                                        },
                                    },
                                    extendData: labelText,
                                });
                            }
                        }
                    });
                    console.log('‚úÖ [ZS] Added successfully');
                }

                // 4. ÁªòÂà∂‰π∞ÂçñÁÇπ (BuySellPoint) - ÁÆ≠Â§¥Ê†áËÆ∞
                if (indicators.plot_bsp && data.bsp_list && data.bsp_list.length > 0) {
                    console.log('üìä [BSP] Adding', data.bsp_list.length, 'buy/sell points');
                    data.bsp_list.forEach((bsp, idx) => {
                        const timestamp = convertTime(bsp.time);
                        const price = parseFloat(bsp.price);
                        const isBuy = bsp.is_buy;
                        
                        if (timestamp && price) {
                            chart.createOverlay({
                                name: 'simpleAnnotation',
                                id: `bsp_${idx}`,
                                groupId: 'bsp_group',
                                paneId: 'candle_pane',
                                points: [{ timestamp, value: price }],
                                styles: {
                                    position: isBuy ? 'bottom' : 'top',
                                    offset: [0, isBuy ? 10 : -10],
                                    symbol: {
                                        type: isBuy ? 'arrow_up' : 'arrow_down',
                                        size: 12,
                                        color: isBuy ? '#4CAF50' : '#F44336',
                                        activeColor: isBuy ? '#66BB6A' : '#EF5350',
                                    },
                                },
                                extendData: `${isBuy ? '‰π∞ÁÇπ' : 'ÂçñÁÇπ'}${bsp.type || ''}`
                            });
                        }
                    });
                    console.log('‚úÖ [BSP] Added successfully');
                }

                const applySyncedIndexRange = (fromIdx, toIdx) => {
                    const chartInst = chartInstanceRef.current;
                    const total = timestampsRef.current.length;
                    if (!chartInst || total === 0) {
                        return false;
                    }
                    let startIdx = Math.min(fromIdx, toIdx);
                    let endIdx = Math.max(fromIdx, toIdx);
                    if (!Number.isFinite(startIdx) || !Number.isFinite(endIdx)) {
                        return false;
                    }
                    startIdx = clamp(Math.floor(startIdx), 0, total - 1);
                    endIdx = clamp(Math.ceil(endIdx), 0, total - 1);
                    const desiredCount = Math.max(1, endIdx - startIdx);
                    let applied = false;
                    let mutated = false;

                    if (typeof chartInst.getVisibleRange === 'function' &&
                        typeof chartInst.getBarSpace === 'function' &&
                        typeof chartInst.setBarSpace === 'function') {
                        try {
                            const currentRange = chartInst.getVisibleRange();
                            const barInfo = chartInst.getBarSpace();
                            const currentSpan = (() => {
                                if (!currentRange) return null;
                                const raw = Number.isFinite(currentRange.realTo) && Number.isFinite(currentRange.realFrom)
                                    ? Math.abs(currentRange.realTo - currentRange.realFrom)
                                    : Math.abs((currentRange.to ?? 0) - (currentRange.from ?? 0));
                                return Number.isFinite(raw) && raw > 0 ? raw : null;
                            })();
                            const currentBar = barInfo && Number.isFinite(barInfo.bar) && barInfo.bar > 0 ? barInfo.bar : null;
                            if (currentSpan && currentBar) {
                                const ratio = currentSpan / desiredCount;
                                if (Number.isFinite(ratio) && ratio > 0) {
                                    if (Math.abs(ratio - 1) > 0.05) {
                                        const MIN_BAR = 2;
                                        const MAX_BAR = 60;
                                        let nextBar = currentBar * ratio;
                                        nextBar = clamp(nextBar, MIN_BAR, MAX_BAR);
                                        if (Math.abs(nextBar - currentBar) > 0.1) {
                                            suppressBroadcastRef.current = true;
                                            chartInst.setBarSpace(nextBar);
                                            applied = true;
                                            mutated = true;
                                        }
                                    }
                                }
                            }
                        } catch (err) {
                            console.warn('‚ö†Ô∏è [Sync] failed to adjust bar space', chartKey, err);
                        }
                    }

                    const scrollToIndex = () => {
                        if (typeof chartInst.scrollToDataIndex === 'function') {
                            suppressBroadcastRef.current = true;
                            chartInst.scrollToDataIndex(endIdx, 0);
                            mutated = true;
                            return true;
                        }
                        if (typeof chartInst.scrollToTimestamp === 'function') {
                            const ts = timestampsRef.current[endIdx];
                            if (Number.isFinite(ts)) {
                                suppressBroadcastRef.current = true;
                                chartInst.scrollToTimestamp(ts, 0);
                                mutated = true;
                                return true;
                            }
                        }
                        return false;
                    };

                    if (scrollToIndex()) {
                        applied = true;
                    }
                    if (!mutated && suppressBroadcastRef.current) {
                        suppressBroadcastRef.current = false;
                    }
                    return applied;
                };

                if (timestampsRef.current.length > 0) {
                    registerChartInstance(chartKey, {
                        chart,
                        getIndexRange: getIndexRangeForTimestamps,
                        applyIndexRange: applySyncedIndexRange,
                        suppressNextBroadcast: () => {
                            suppressBroadcastRef.current = true;
                        },
                    });
                    console.log('üìù [ChartRegistry] Registered', chartKey, 'candles:', timestampsRef.current.length);
                }

                const visibleRangeAction = (klinecharts.ActionType && klinecharts.ActionType.OnVisibleRangeChange) || 'onVisibleRangeChange';
                const scrollAction = (klinecharts.ActionType && klinecharts.ActionType.OnScroll) || 'onScroll';
                const zoomAction = (klinecharts.ActionType && klinecharts.ActionType.OnZoom) || 'onZoom';
                const subscribedRangeActions = [];
                let initialRangeTimerId = null;
                const handleVisibleRange = () => {
                    if (!syncVisibleRange || !chart || typeof chart.getVisibleRange !== 'function') {
                        return;
                    }
                    if (suppressBroadcastRef.current) {
                        suppressBroadcastRef.current = false;
                        return;
                    }
                    const list = timestampsRef.current;
                    if (!Array.isArray(list) || list.length === 0) {
                        return;
                    }
                    const range = chart.getVisibleRange();
                    if (!range) {
                        return;
                    }
                    const fromRaw = Number.isFinite(range.from) ? range.from : 0;
                    const toRaw = Number.isFinite(range.to) ? range.to : list.length - 1;
                    const fromIdx = clamp(Math.floor(fromRaw), 0, list.length - 1);
                    const toIdx = clamp(Math.ceil(toRaw), 0, list.length - 1);
                    const fromTs = list[fromIdx];
                    const toTs = list[toIdx];
                    if (!Number.isFinite(fromTs) || !Number.isFinite(toTs)) {
                        return;
                    }
                    console.log('üîÑ [VisibleRange]', chartKey, { fromIdx, toIdx, fromTs, toTs });
                    syncVisibleRange(chartKey, fromTs, toTs);
                };
                const subscribeRangeAction = (actionType) => {
                    if (!chart.subscribeAction || !actionType || subscribedRangeActions.includes(actionType)) {
                        return;
                    }
                    try {
                        chart.subscribeAction(actionType, handleVisibleRange);
                        subscribedRangeActions.push(actionType);
                        console.log('‚úÖ [Subscribe]', chartKey, actionType);
                    } catch (err) {
                        console.warn(`‚ö†Ô∏è Failed to subscribe ${actionType} action`, err);
                    }
                };
                subscribeRangeAction(visibleRangeAction);
                subscribeRangeAction(scrollAction);
                subscribeRangeAction(zoomAction);
                initialRangeTimerId = setTimeout(handleVisibleRange, 0);

                const crosshairAction = (klinecharts.ActionType && klinecharts.ActionType.OnCrosshairChange) || 'onCrosshairChange';
                let subscribed = false;
                const handleCrosshair = (params) => {
                    try {
                        const payload = (() => {
                            if (!params) return null;
                            if (params.data) return params.data;
                            if (params.current) return params.current;
                            if (params.kLineData || Number.isFinite(params.dataIndex)) {
                                return params;
                            }
                            return null;
                        })();

                        if (!payload) {
                            updateHoverInfo(null);
                            return;
                        }

                        const dataIndex = Number.isFinite(payload.dataIndex)
                            ? payload.dataIndex
                            : Number.isFinite(payload.currentDataIndex)
                                ? payload.currentDataIndex
                                : undefined;

                        const kLineData = payload.kLineData || payload.klineData || null;
                        let timestamp = payload.timestamp;

                        if (!timestamp && kLineData && Number.isFinite(kLineData.timestamp)) {
                            timestamp = kLineData.timestamp;
                        }

                        if (!timestamp && Number.isFinite(dataIndex)) {
                            const list = candleDataRef.current;
                            if (Array.isArray(list) && list.length > 0) {
                                const idx = clamp(Math.floor(dataIndex), 0, list.length - 1);
                                timestamp = idx >= 0 ? list[idx]?.timestamp : undefined;
                            }
                        }

                        if (!timestamp) {
                            updateHoverInfo(null);
                            return;
                        }

                        updateHoverInfo(timestamp);
                    } catch (err) {
                        console.warn('‚ö†Ô∏è Crosshair update failed', err);
                    }
                };

                if (chart.subscribeAction) {
                    try {
                        chart.subscribeAction(crosshairAction, handleCrosshair);
                        subscribed = true;
                    } catch (err) {
                        console.warn('‚ö†Ô∏è Failed to subscribe crosshair action', err);
                    }
                }

                if (candleData.length > 0) {
                    updateHoverInfo(candleData[candleData.length - 1].timestamp);
                }

                // Cleanup
                return () => {
                    unregisterChartInstance(chartKey);
                    if (initialRangeTimerId) {
                        clearTimeout(initialRangeTimerId);
                    }
                    if (chart.unsubscribeAction && subscribedRangeActions.length > 0) {
                        subscribedRangeActions.forEach(actionType => {
                            try {
                                chart.unsubscribeAction(actionType, handleVisibleRange);
                                console.log('üö™ [Unsubscribe]', chartKey, actionType);
                            } catch (err) {
                                console.warn(`‚ö†Ô∏è Failed to unsubscribe ${actionType} action`, err);
                            }
                        });
                    }
                    if (chart.unsubscribeAction && subscribed) {
                        try {
                            chart.unsubscribeAction(crosshairAction, handleCrosshair);
                        } catch (err) {
                            console.warn('‚ö†Ô∏è Failed to unsubscribe crosshair action', err);
                        }
                    }
                    if (chartRef.current) {
                        klinecharts.dispose(chartRef.current);
                    }
                    timestampsRef.current = [];
                    chartInstanceRef.current = null;
                };
            }, [data, indicators, theme, updateHoverInfo, registerChartInstance, unregisterChartInstance, syncVisibleRange, chartKey, getIndexRangeForTimestamps]);

            if (loading) {
                return (
                    <div style={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '100%' }}>
                        <Spin size="large" tip="Âä†ËΩΩ‰∏≠..." />
                    </div>
                );
            }

            return (
                <div className="chart-card">
                    <div className="chart-header">
                        <div className="chart-title">
                            {stockCode} | {LEVEL_OPTIONS.find(o => o.value === level)?.label || level}
                        </div>
                        <Space>
                            <Button 
                                size="small" 
                                onClick={() => {
                                    if (chartInstanceRef.current) {
                                        const total = candleDataRef.current.length;
                                        if (total > 0 && chartInstanceRef.current.zoomAtDataIndex) {
                                            chartInstanceRef.current.zoomAtDataIndex(0.5, total - 1, 0);
                                        }
                                    }
                                }}
                            >
                                ÈáçÁΩÆÁº©Êîæ
                            </Button>
                        </Space>
                    </div>
                    <ChartSummary hoverInfo={hoverInfo} stats={stats} level={level} />
                    <div className="chart-wrapper">
                        <div ref={chartRef} className="chart-container" />
                    </div>
                </div>
            );
        });

        const LOWER_INDICATOR_KEYS = ['macd', 'kdj', 'rsi'];

        const LabelWithTip = ({ label, tip }) => (
            <Tooltip title={tip}>
                <span style={{ display: 'inline-flex', alignItems: 'center', gap: 4 }}>
                    {label}
                    <span style={{ fontSize: 10, color: '#bbb' }}>i</span>
                </span>
            </Tooltip>
        );

        function ChartSummaryComponent({ hoverInfo, stats, level }) {
            const { indicators, setIndicators } = useApp();
            const handleChange = useCallback((key, value) => {
                setIndicators(prev => ({ ...prev, [key]: value }));
            }, [setIndicators]);
            const [statsCollapsed, setStatsCollapsed] = useState(true);

            if (!indicators) {
                return null;
            }

            const levelLabel = LEVEL_OPTIONS.find(option => option.value === level)?.label || level;
            const signalList = hoverInfo?.signals || [];
            const statPairs = stats ? [
                { label: 'KÁ∫ø', value: stats.kline },
                { label: 'Á¨î', value: stats.bi },
                { label: 'Á∫øÊÆµ', value: stats.seg },
                { label: '‰∏≠Êû¢', value: stats.zs },
                { label: '‰π∞ÂçñÁÇπ', value: stats.bsp },
                { label: '‰π∞ÁÇπ', value: stats.buy },
                { label: 'ÂçñÁÇπ', value: stats.sell },
            ] : [];
            const bspTypeEntries = stats && stats.bspTypes ? Object.entries(stats.bspTypes) : [];

            return (
                <div className="chart-summary-wrapper">
                    <div className="chart-summary-card">
                        <div className="card-header">
                            <span className="card-title">Áº†ËÆ∫ÁªüËÆ° ¬∑ {levelLabel}</span>
                            <Button size="small" type="link" onClick={() => setStatsCollapsed(prev => !prev)}>
                                {statsCollapsed ? 'Â±ïÂºÄ' : 'Êî∂Ëµ∑'}
                            </Button>
                        </div>
                        {!statsCollapsed && (
                            stats ? (
                                <>
                                    <div className="chart-stats-grid">
                                        {statPairs.map(item => (
                                            <div className="chart-stats-item" key={item.label}>
                                                <span className="chart-stats-label">{item.label}</span>
                                                <span className="chart-stats-value">{item.value ?? '--'}</span>
                                            </div>
                                        ))}
                                    </div>
                                    {bspTypeEntries.length > 0 && (
                                        <div className="chart-bsp-types">
                                            {bspTypeEntries.map(([type, count]) => (
                                                <span className="chart-type-chip" key={type}>
                                                    {type} √ó {count}
                                                </span>
                                            ))}
                                        </div>
                                    )}
                                </>
                            ) : (
                                <span className="chart-info-placeholder">ÊöÇÊó†ËØ•Âë®ÊúüÁªüËÆ°</span>
                            )
                        )}
                        {indicators.highlight_chan_kline && (
                            <div className="indicator-item" style={{ display: 'flex', alignItems: 'center', gap: 8 }}>
                                <Checkbox
                                    checked={indicators.chan_kline_show_label}
                                    onChange={e => handleChange('chan_kline_show_label', e.target.checked)}
                                >
                                    ÊòæÁ§∫ÂêàÊàêÊ†áÊ≥®
                                </Checkbox>
                            </div>
                        )}
                    </div>
                    <div className="chart-hover-card">
                        <div className="card-header">
                            <span className="card-title">KÁ∫øÊï∞ÊçÆ</span>
                        </div>
                        {hoverInfo ? (
                            <>
                                <div className="hover-info-grid">
                                    <div className="hover-info-cell hover-info-cell--full">
                                        <span className="hover-info-label">Êó∂Èó¥</span>
                                        <span className="hover-info-value">{formatDateTime(hoverInfo.timestamp)}</span>
                                    </div>
                                    <div className="hover-info-cell">
                                        <span className="hover-info-label">ÂºÄÁõò</span>
                                        <span className="hover-info-value">{formatNumber(hoverInfo.open)}</span>
                                    </div>
                                    <div className="hover-info-cell">
                                        <span className="hover-info-label">Êî∂Áõò</span>
                                        <span className="hover-info-value">{formatNumber(hoverInfo.close)}</span>
                                    </div>
                                    <div className="hover-info-cell">
                                        <span className="hover-info-label">ÊúÄÈ´ò</span>
                                        <span className="hover-info-value">{formatNumber(hoverInfo.high)}</span>
                                    </div>
                                    <div className="hover-info-cell">
                                        <span className="hover-info-label">ÊúÄ‰Ωé</span>
                                        <span className="hover-info-value">{formatNumber(hoverInfo.low)}</span>
                                    </div>
                                    <div className="hover-info-cell hover-info-cell--full">
                                        <span className="hover-info-label">Êàê‰∫§Èáè</span>
                                        <span className="hover-info-value">{formatVolume(hoverInfo.volume)}</span>
                                    </div>
                                </div>
                                <div className="chart-signal-tags">
                                    {signalList.length > 0 ? (
                                        signalList.map((signal, idx) => (
                                            <Tag
                                                key={`${signal.isBuy ? 'buy' : 'sell'}-${idx}`}
                                                color={signal.isBuy ? 'green' : 'volcano'}
                                            >
                                                {signal.isBuy ? '‰π∞' : 'Âçñ'}{signal.type || ''}
                                            </Tag>
                                        ))
                                    ) : (
                                        <span className="chart-info-placeholder">ÂΩìÂâçKÁ∫øÊó†‰π∞ÂçñÁÇπ</span>
                                    )}
                                </div>
                            </>
                        ) : (
                            <span className="chart-info-placeholder">Â∞ÜÈº†Ê†áÁßªÂä®Âà∞KÁ∫øÊü•ÁúãËØ¶ÁªÜÊï∞ÊçÆ</span>
                        )}
                    </div>
                </div>
            );
        }

        const ChartSummary = memo(ChartSummaryComponent);

        const ActiveStockPanel = memo(() => {
            const {
                activeStock,
                activeLevels,
                setActiveLevels,
                levelLayout,
                setLevelLayout,
                chartData,
                loadingCharts,
                analyzeStock,
                refreshAllCharts,
                indicators,
                setIndicators,
            } = useApp();

            useEffect(() => {
                if (!activeStock) {
                    return;
                }
                activeLevels.forEach(level => analyzeStock(activeStock.code, level));
            }, [activeStock?.code, activeLevels.join(','), analyzeStock]);

            if (!activeStock) {
                return (
                    <div className="watchlist-empty" style={{ marginTop: 40 }}>
                        ËØ∑ÈÄâÊã©Â∑¶‰æßËá™ÈÄâËÇ°Á•®ÂºÄÂßãÂàÜÊûê
                    </div>
                );
            }

            const displayTitle = activeStock.name ? `${activeStock.name} ¬∑ ${activeStock.code}` : activeStock.code;

            const handleLevelToggle = (level) => {
                const isActive = activeLevels.includes(level);
                if (isActive) {
                    if (activeLevels.length === 1) {
                        message.warning('Ëá≥Â∞ë‰øùÁïô‰∏Ä‰∏™Âë®Êúü');
                        return;
                    }
                    setActiveLevels(prev => prev.filter(item => item !== level));
                } else {
                    setActiveLevels(prev => {
                        const next = [...prev, level];
                        analyzeStock(activeStock.code, level);
                        return next;
                    });
                }
            };

            const statsByLevel = activeLevels.reduce((acc, level) => {
                const key = `${activeStock.code}-${level}`;
                const data = chartData[key];
                if (!data) {
                    acc[level] = null;
                    return acc;
                }
                const meta = data.meta || {};
                const bspList = data.bsp_list || [];
                acc[level] = {
                    kline: meta.total_klines ?? data.kline_data?.length ?? 0,
                    bi: meta.bi_count ?? data.bi_list?.length ?? 0,
                    seg: meta.seg_count ?? data.seg_list?.length ?? 0,
                    zs: meta.zs_count ?? data.zs_list?.length ?? 0,
                    bsp: meta.bsp_count ?? bspList.length,
                    buy: bspList.filter(item => item.is_buy).length,
                    sell: bspList.filter(item => !item.is_buy).length,
                    bspTypes: bspList.reduce((map, item) => {
                        const type = item.type || 'Êú™Áü•';
                        map[type] = (map[type] || 0) + 1;
                        return map;
                    }, {}),
                };
                return acc;
            }, {});

            let columnsClass = 'columns-1';
            if (levelLayout === 'grid' && activeLevels.length > 1) {
                columnsClass = activeLevels.length >= 3 ? 'columns-3' : 'columns-2';
            }

            return (
                <div className="stock-chart-group">
                    <div className="stock-chart-header">
                        <div className="stock-chart-title">{displayTitle}</div>
                        <Space>
                            <Tooltip title="Âà∑Êñ∞ÂΩìÂâçËÇ°Á•®ÊâÄÊúâÂë®Êúü">
                                <Button size="small" onClick={refreshAllCharts}>
                                    üîÑ Âà∑Êñ∞
                                </Button>
                            </Tooltip>
                        </Space>
                    </div>
                    <div className="stock-chart-toolbar">
                        <div className="period-buttons">
                            {LEVEL_OPTIONS.map(option => {
                                const active = activeLevels.includes(option.value);
                                return (
                                    <Button
                                        key={option.value}
                                        type={active ? 'primary' : 'default'}
                                        onClick={() => handleLevelToggle(option.value)}
                                    >
                                        {option.label}
                                    </Button>
                                );
                            })}
                        </div>
                        <Space size="small" align="center">
                            <Radio.Group
                                size="small"
                                value={levelLayout}
                                onChange={e => setLevelLayout(e.target.value)}
                                buttonStyle="solid"
                            >
                                <Radio.Button value="stack">Á∫µÂêë</Radio.Button>
                                <Radio.Button value="grid" disabled={activeLevels.length < 2}>Âπ∂Êéí</Radio.Button>
                            </Radio.Group>
                            {(indicators.indicator_layout === 'tab' && LOWER_INDICATOR_KEYS.some(key => indicators[`plot_${key}`])) && (
                                <Select
                                    size="small"
                                    style={{ width: 120 }}
                                    value={indicators.indicator_tab}
                                    onChange={value => setIndicators(prev => ({ ...prev, indicator_tab: value }))}
                                    options={LOWER_INDICATOR_KEYS.filter(key => indicators[`plot_${key}`]).map(key => ({
                                        value: key,
                                        label: key === 'macd' ? 'MACD' : key.toUpperCase(),
                                    }))}
                                />
                            )}
                        </Space>
                    </div>
                    <div className={`stock-chart-panels ${columnsClass}`}>
                        {activeLevels.map(level => {
                            const key = `${activeStock.code}-${level}`;
                            return (
                                <ChartPanel
                                    key={key}
                                    stockCode={activeStock.code}
                                    level={level}
                                    data={chartData[key]}
                                    loading={loadingCharts[key]}
                                    stats={statsByLevel[level]}
                                />
                            );
                        })}
                    </div>
                </div>
            );
        });

        // ============= Stock Manager Component =============
        const StockManager = memo(() => {
            const {
                stocks,
                addStock,
                removeStock,
                activeStockCode,
                setActiveStockCode,
            } = useApp();

            const [searchValue, setSearchValue] = useState('');
            const [searchOptions, setSearchOptions] = useState([]);
            const [searchLoading, setSearchLoading] = useState(false);
            const [manualCode, setManualCode] = useState('');

            const runSearch = useMemo(() => debounce(async (value) => {
                if (!value || value.trim().length < 2) {
                    setSearchOptions([]);
                    setSearchLoading(false);
                    return;
                }
                try {
                    const results = await api.searchStocks(value);
                    setSearchOptions(results.map(item => ({
                        value: item.code,
                        label: `${item.code} ¬∑ ${item.name}`,
                        code: item.code,
                        name: item.name,
                    })));
                } catch (error) {
                    console.error('‚ö†Ô∏è ÊêúÁ¥¢ËÇ°Á•®Â§±Ë¥•:', error);
                    setSearchOptions([]);
                } finally {
                    setSearchLoading(false);
                }
            }, 350), []);

            const handleSearchChange = (value) => {
                setSearchValue(value);
                if (!value) {
                    setSearchOptions([]);
                    setSearchLoading(false);
                    return;
                }
                setSearchLoading(true);
                runSearch(value);
            };

            const handleSearchSelect = (value, option) => {
                const result = addStock({ code: option.code, name: option.name });
                if (result === 'new') {
                    message.success(`Â∑≤Ê∑ªÂä† ${option.label}`);
                } else if (result === 'updated') {
                    message.success(`Â∑≤Êõ¥Êñ∞ ${option.label}`);
                }
                setActiveStockCode(option.code);
                setSearchValue('');
                setSearchOptions([]);
            };

            const handleManualAdd = () => {
                const code = manualCode.trim();
                if (!code) {
                    message.warning('ËØ∑ËæìÂÖ•ËÇ°Á•®‰ª£Á†Å');
                    return;
                }
                const result = addStock({ code });
                if (result === 'new') {
                    message.success(`Â∑≤Ê∑ªÂä† ${code}`);
                } else if (result === 'updated') {
                    message.success(`Â∑≤Êõ¥Êñ∞ ${code}`);
                } else if (result === 'unchanged') {
                    message.info(`${code} Â∑≤Âú®Ëá™ÈÄâÂàóË°®`);
                }
                setActiveStockCode(code);
                setManualCode('');
            };

            const handleQuickAdd = (stock) => {
                const result = addStock({ code: stock.code, name: stock.name });
                if (result === 'new') {
                    message.success(`Â∑≤Ê∑ªÂä† ${stock.name}`);
                } else if (result === 'updated') {
                    message.success(`Â∑≤Êõ¥Êñ∞ ${stock.name}`);
                } else if (result === 'unchanged') {
                    message.info(`${stock.name} Â∑≤Âú®Ëá™ÈÄâÂàóË°®`);
                }
                setActiveStockCode(stock.code);
            };

            const WatchlistItem = ({ stock }) => {
                const isActive = stock.code === activeStockCode;
                return (
                    <List.Item className={`watchlist-item ${isActive ? 'watchlist-item--active' : ''}`} key={stock.id}>
                        <div className="watchlist-item__header">
                            <div className="watchlist-item__info">
                                <div className="watchlist-item__code">{stock.name || stock.code}</div>
                                {stock.name && <div className="watchlist-item__meta">{stock.code}</div>}
                            </div>
                            <Space size="small">
                                {!isActive && (
                                    <Button size="small" onClick={() => setActiveStockCode(stock.code)}>
                                        Êü•Áúã
                                    </Button>
                                )}
                                <Button size="small" danger onClick={() => removeStock(stock.id)}>
                                    Âà†Èô§
                                </Button>
                            </Space>
                        </div>
                    </List.Item>
                );
            };

            return (
                <div className="stock-manager">
                    <div>
                        <div className="stock-manager-title">Ëá™ÈÄâËÇ°Á•®</div>
                        <div className="stock-manager-subtitle">ÊêúÁ¥¢ÊàñÊâãÂä®ËæìÂÖ•‰ª£Á†ÅÊ∑ªÂä†ÔºåÁÇπÂáªÂç≥ÂèØÂàáÊç¢</div>
                    </div>

                    <div className="stock-add-card">
                        <AutoComplete
                            value={searchValue}
                            options={searchOptions}
                            onSearch={handleSearchChange}
                            onSelect={handleSearchSelect}
                            onChange={value => setSearchValue(value)}
                            placeholder="ÊêúÁ¥¢ËÇ°Á•®‰ª£Á†Å / ÂêçÁß∞ÔºàËá≥Â∞ëËæìÂÖ•2‰∏™Â≠óÁ¨¶Ôºâ"
                            style={{ width: '100%' }}
                        >
                            <Input
                                suffix={searchLoading ? <Spin size="small" /> : null}
                                allowClear
                            />
                        </AutoComplete>
                        <Space.Compact style={{ width: '100%' }}>
                            <Input
                                placeholder="ÊàñÁõ¥Êé•ËæìÂÖ•ËÇ°Á•®‰ª£Á†ÅÊ∑ªÂä†"
                                value={manualCode}
                                onChange={e => setManualCode(e.target.value)}
                                onPressEnter={handleManualAdd}
                            />
                            <Button type="primary" onClick={handleManualAdd}>
                                Ê∑ªÂä†
                            </Button>
                        </Space.Compact>
                        <div className="stock-add-hint">
                            ÈÄâ‰∏≠Ëá™ÈÄâÈ°πÂêéÔºåÂèØÂú®‰∏ªÈù¢Êùø‰∏≠ÂêåÊó∂Êü•ÁúãÂ§öÂë®Êúü K Á∫ø„ÄÇ
                        </div>
                    </div>

                    <div className="stock-quick-area">
                        <div className="stock-quick-title">Âø´ÈÄüÊ∑ªÂä†</div>
                        <Space size={[8, 8]} wrap>
                            {QUICK_STOCKS.map(stock => (
                                <Button key={stock.code} size="small" onClick={() => handleQuickAdd(stock)}>
                                    {stock.name}
                                </Button>
                            ))}
                        </Space>
                    </div>

                    <Divider style={{ margin: '8px 0' }} />

                    {stocks.length === 0 ? (
                        <div className="watchlist-empty">
                            ÊöÇÊó†Ëá™ÈÄâËÇ°Á•®ÔºåÂÖàÊ∑ªÂä†‰∏ÄÂè™ÁúãÁúã~
                        </div>
                    ) : (
                        <List
                            split={false}
                            dataSource={stocks}
                            locale={{ emptyText: <Empty description="ÊöÇÊó†Ëá™ÈÄâËÇ°Á•®" /> }}
                            renderItem={(stock) => <WatchlistItem stock={stock} />}
                        />
                    )}
                </div>
            );
        });

        // ============= Indicator Config Component =============
        const IndicatorConfig = memo(() => {
            const { indicators, setIndicators, refreshAllCharts } = useApp();
            const [timeRange, setTimeRange] = useState('1y');
            const [customRange, setCustomRange] = useState(() => {
                if (indicators.begin_time || indicators.end_time) {
                    return [indicators.begin_time || null, indicators.end_time || null];
                }
                return [null, null];
            });
            const { RangePicker } = DatePicker;
            const [limitCount, setLimitCount] = useState(indicators.limit_kl_count || null);

            useEffect(() => {
                setLimitCount(indicators.limit_kl_count || null);
            }, [indicators.limit_kl_count]);

            const PRESET_INDICATORS = [
                {
                    key: 'standard',
                    name: 'Ê†áÂáÜ',
                    description: 'Â±ïÁ§∫Á¨î/Á∫øÊÆµ/‰π∞ÂçñÁÇπ + MACD + 5/10/20/60 ÂùáÁ∫ø',
                    apply: () => {
                        setIndicators(prev => ({
                            ...prev,
                            plot_bi: true,
                            plot_seg: true,
                            plot_zs: true,
                            plot_bsp: true,
                            plot_macd: true,
                            plot_volume: true,
                            plot_kdj: false,
                            plot_rsi: false,
                            plot_boll: false,
                            plot_ma: true,
                            ma_params: [5, 10, 20, 60],
                        }));
                    }
                },
                {
                    key: 'trend',
                    name: 'Ë∂ãÂäø',
                    description: 'Âè™ÁúãKÁ∫ø + ÂùáÁ∫øÔºå‰∏éMACD, KDJ ËæÖÂä©',
                    apply: () => {
                        setIndicators(prev => ({
                            ...prev,
                            plot_bi: false,
                            plot_seg: false,
                            plot_zs: false,
                            plot_bsp: false,
                            plot_macd: true,
                            plot_kdj: true,
                            plot_rsi: false,
                            plot_boll: false,
                            plot_volume: true,
                            plot_ma: true,
                            ma_params: [20, 60, 120],
                        }));
                    }
                },
                {
                    key: 'minimal',
                    name: 'ÁÆÄÊ¥Å',
                    description: 'Âè™ÊòæÁ§∫KÁ∫ø„ÄÅÁ¨îÂíå‰π∞ÂçñÁÇπ',
                    apply: () => {
                        setIndicators(prev => ({
                            ...prev,
                            plot_bi: true,
                            plot_seg: false,
                            plot_zs: false,
                            plot_bsp: true,
                            plot_macd: false,
                            plot_kdj: false,
                            plot_rsi: false,
                            plot_boll: false,
                            plot_volume: false,
                            plot_ma: false,
                        }));
                    }
                }
            ];

            const handleChange = (key, value) => {
                if (key === 'ma_params') {
                    const sanitized = (value || [])
                        .map(Number)
                        .filter(val => Number.isFinite(val) && val > 0)
                        .slice(0, 6)
                        .sort((a, b) => a - b);
                    setIndicators(prev => ({ ...prev, ma_params: sanitized }));
                    return;
                }
                setIndicators(prev => ({ ...prev, [key]: value }));
            };

            const handleTimeRangeChange = (range) => {
                setTimeRange(range);
                const now = new Date();
                let beginTime;
                
                switch(range) {
                    case '1m': beginTime = new Date(now.setMonth(now.getMonth() - 1)); break;
                    case '3m': beginTime = new Date(now.setMonth(now.getMonth() - 3)); break;
                    case '6m': beginTime = new Date(now.setMonth(now.getMonth() - 6)); break;
                    case '1y': beginTime = new Date(now.setFullYear(now.getFullYear() - 1)); break;
                    case '3y': beginTime = new Date(now.setFullYear(now.getFullYear() - 3)); break;
                    case 'all': beginTime = new Date('2020-01-01'); break;
                    case 'custom':
                        setTimeRange('custom');
                        return;
                    default: beginTime = new Date(now.setFullYear(now.getFullYear() - 1));
                }
                
                handleChange('begin_time', beginTime.toISOString().split('T')[0]);
                handleChange('end_time', null);
                setCustomRange([beginTime.toISOString().split('T')[0], null]);
                setTimeout(() => refreshAllCharts(), 100);
            };
            const applyCustomRange = () => {
                const [start, end] = customRange || [];
                if (start) {
                    handleChange('begin_time', start);
                }
                if (end) {
                    handleChange('end_time', end);
                } else {
                    handleChange('end_time', null);
                }
                setTimeRange('custom');
                setTimeout(() => refreshAllCharts(), 100);
            };

            const clearLimitCount = () => {
                setLimitCount(null);
                handleChange('limit_kl_count', null);
                message.success('Â∑≤ÂèñÊ∂àKÁ∫øÊï∞ÈáèÈôêÂà∂');
                setTimeout(() => refreshAllCharts(), 100);
            };

            const applyLimitCount = () => {
                if (limitCount === null || limitCount === undefined || limitCount === '') {
                    clearLimitCount();
                    return;
                }
                const numeric = Number(limitCount);
                if (!Number.isFinite(numeric)) {
                    message.warning('ËØ∑ËæìÂÖ•ÊúâÊïàÁöÑKÁ∫øÊï∞Èáè');
                    return;
                }
                const sanitized = Math.min(5000, Math.max(10, Math.round(numeric)));
                handleChange('limit_kl_count', sanitized);
                setLimitCount(sanitized);
                message.success(`Â∑≤ÈôêÂà∂Â±ïÁ§∫ÊúÄËøë ${sanitized} Ê†πKÁ∫ø`);
                setTimeout(() => refreshAllCharts(), 100);
            };

            const ColorPicker = ({ value, onChange }) => (
                <input
                    type="color"
                    value={value}
                    onChange={e => onChange(e.target.value)}
                    style={{ width: 32, height: 20, border: 'none', background: 'transparent', padding: 0 }}
                />
            );

            return (
                <div>
                    <div style={{ marginBottom: 16, padding: 12, background: '#f5f5f5', borderRadius: 8 }}>
                        <div style={{ marginBottom: 8, fontWeight: 600, fontSize: 13 }}>Êó∂Èó¥ËåÉÂõ¥</div>
                        <Space direction="vertical" size={8} style={{ width: '100%' }}>
                            <Radio.Group 
                                value={timeRange} 
                                onChange={e => handleTimeRangeChange(e.target.value)}
                                size="small"
                                buttonStyle="solid"
                            >
                                <Radio.Button value="1m">Ëøë1Êúà</Radio.Button>
                                <Radio.Button value="3m">Ëøë3Êúà</Radio.Button>
                                <Radio.Button value="6m">Ëøë6Êúà</Radio.Button>
                                <Radio.Button value="1y">Ëøë1Âπ¥</Radio.Button>
                                <Radio.Button value="3y">Ëøë3Âπ¥</Radio.Button>
                                <Radio.Button value="all">ÂÖ®ÈÉ®</Radio.Button>
                                <Radio.Button value="custom">Ëá™ÂÆö‰πâ</Radio.Button>
                            </Radio.Group>
                            <Space size="small" wrap>
                                <RangePicker
                                    size="small"
                                    value={(customRange || []).map(v => v ? dayjs(v) : null)}
                                    onChange={(dates, dateStrings) => {
                                        setCustomRange(dateStrings);
                                    }}
                                    allowEmpty={[true, true]}
                                    placeholder={['ÂºÄÂßãÊó•Êúü', 'ÁªìÊùüÊó•Êúü']}
                                />
                                <Button size="small" onClick={applyCustomRange}>Â∫îÁî®</Button>
                            </Space>
                            <Space size="small" align="center" wrap>
                                <span style={{ fontSize: 12, color: '#888' }}>KÁ∫øÊï∞Èáè‰∏äÈôê</span>
                                <InputNumber
                                    size="small"
                                    min={10}
                                    max={5000}
                                    step={50}
                                    style={{ width: 110 }}
                                    value={limitCount}
                                    placeholder="‰∏çÈôê"
                                    onChange={value => {
                                        if (value === null || value === undefined || value === '') {
                                            setLimitCount(null);
                                        } else {
                                            setLimitCount(Number(value));
                                        }
                                    }}
                                />
                                <Button size="small" type="primary" onClick={applyLimitCount}>Â∫îÁî®</Button>
                                <Button size="small" onClick={clearLimitCount} disabled={limitCount === null}>
                                    Ê∏ÖÈô§
                                </Button>
                            </Space>
                            <div style={{ fontSize: 11, color: '#999' }}>
                                Â∞ÜÊï∞ÈáèÈôêÂà∂ËÆæ‰∏∫ N Êó∂Ôºå‰ªÖÂä†ËΩΩÊúÄËøë N Ê†πKÁ∫øÂèäÂØπÂ∫îÁöÑÁ¨î/Á∫øÊÆµ/‰∏≠Êû¢‰∏éÊåáÊ†áÊï∞ÊçÆÔºå‰æø‰∫éËÅöÁÑ¶ÂΩìÂâçËµ∞Âäø„ÄÇ
                            </div>
                        </Space>
                    </div>

                    <div className="indicator-section">
                        <div className="indicator-section-title">Áº†ËÆ∫ÊåáÊ†á</div>
                        <div className="indicator-item">
                            <Checkbox checked={indicators.plot_bi} onChange={e => handleChange('plot_bi', e.target.checked)}>
                                Á¨î (Bi)
                            </Checkbox>
                        </div>
                        <div className="indicator-item">
                            <Checkbox checked={indicators.plot_seg} onChange={e => handleChange('plot_seg', e.target.checked)}>
                                Á∫øÊÆµ (Seg)
                            </Checkbox>
                        </div>
                        <div className="indicator-item">
                            <Checkbox checked={indicators.plot_zs} onChange={e => handleChange('plot_zs', e.target.checked)}>
                                ‰∏≠Êû¢ (ZS)
                            </Checkbox>
                        </div>
                        <div className="indicator-item">
                            <Checkbox checked={indicators.plot_bsp} onChange={e => handleChange('plot_bsp', e.target.checked)}>
                                ‰π∞ÂçñÁÇπ (BSP)
                            </Checkbox>
                        </div>
                        <div className="indicator-item">
                            <Checkbox checked={indicators.highlight_chan_kline} onChange={e => handleChange('highlight_chan_kline', e.target.checked)}>
                                Áº†ËÆ∫KÁ∫øËôöÁ∫øÂúà
                            </Checkbox>
                        </div>
                        {indicators.highlight_chan_kline && (
                            <div className="indicator-item" style={{ display: 'flex', alignItems: 'center', gap: 8 }}>
                                <span>ÂúàÂÆöÈ¢úËâ≤</span>
                                <input
                                    type="color"
                                    value={indicators.chan_kline_color || '#FF9800'}
                                    onChange={e => handleChange('chan_kline_color', e.target.value)}
                                    style={{ width: 36, height: 20, border: 'none', background: 'transparent', padding: 0, cursor: 'pointer' }}
                                />
                            </div>
                        )}
                    </div>

                    <div className="indicator-section">
                        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'baseline', marginBottom: 8 }}>
                            <div className="indicator-section-title" style={{ marginBottom: 0 }}>Áº†ËÆ∫Ê†∑Âºè</div>
                            <Popover
                                placement="bottomRight"
                                trigger="click"
                                content={
                                    <Space direction="vertical" style={{ maxWidth: 260 }}>
                                        {PRESET_INDICATORS.map(preset => (
                                            <Button
                                                key={preset.key}
                                                block
                                                size="small"
                                                onClick={() => preset.apply()}
                                            >
                                                {preset.name}
                                                <div style={{ fontSize: 11, color: '#888' }}>{preset.description}</div>
                                            </Button>
                                        ))}
                                    </Space>
                                }
                            >
                                <Button size="small" type="link">È¢ÑËÆæ</Button>
                            </Popover>
                        </div>
                        <div className="indicator-item" style={{ display: 'flex', flexDirection: 'column', gap: 8 }}>
                            <div style={{ fontWeight: 500 }}>Á¨îÊ†∑Âºè</div>
                            <Space size="small" wrap>
                                <span>È¢úËâ≤</span>
                                <ColorPicker value={indicators.bi_color} onChange={value => handleChange('bi_color', value)} />
                                <span>Á∫øÂûã</span>
                                <Select
                                    size="small"
                                    value={indicators.bi_line_style}
                                    style={{ width: 90 }}
                                    onChange={value => handleChange('bi_line_style', value)}
                                    options={LINE_STYLE_OPTIONS}
                                />
                                <span>Á∫øÂÆΩ</span>
                                <InputNumber
                                    min={1}
                                    max={6}
                                    size="small"
                                    value={indicators.bi_line_width}
                                    onChange={value => handleChange('bi_line_width', value || 1)}
                                />
                            </Space>
                        </div>
                        <div className="indicator-item" style={{ display: 'flex', flexDirection: 'column', gap: 8, marginTop: 12 }}>
                            <div style={{ fontWeight: 500 }}>Á∫øÊÆµÊ†∑Âºè</div>
                            <Space size="small" wrap>
                                <span>È¢úËâ≤</span>
                                <ColorPicker value={indicators.seg_color} onChange={value => handleChange('seg_color', value)} />
                                <span>Á∫øÂûã</span>
                                <Select
                                    size="small"
                                    value={indicators.seg_line_style}
                                    style={{ width: 90 }}
                                    onChange={value => handleChange('seg_line_style', value)}
                                    options={LINE_STYLE_OPTIONS}
                                />
                                <span>Á∫øÂÆΩ</span>
                                <InputNumber
                                    min={1}
                                    max={8}
                                    size="small"
                                    value={indicators.seg_line_width}
                                    onChange={value => handleChange('seg_line_width', value || 1)}
                                />
                            </Space>
                        </div>
                        <div className="indicator-item" style={{ display: 'flex', flexDirection: 'column', gap: 8, marginTop: 12 }}>
                            <div style={{ fontWeight: 500 }}>‰∏≠Êû¢Ê†∑Âºè</div>
                            <Space size="small" wrap>
                                <span>Êù•Ê∫ê</span>
                                <Select
                                    size="small"
                                    value={indicators.zs_source || 'bi'}
                                    style={{ width: 120 }}
                                    onChange={value => handleChange('zs_source', value)}
                                    options={[
                                        { value: 'bi', label: 'Á¨î‰∏≠Êû¢' },
                                        { value: 'seg', label: 'Á∫øÊÆµ‰∏≠Êû¢' },
                                        { value: 'both', label: 'ÂÖ®ÈÉ®' },
                                    ]}
                                />
                            </Space>
                            <Space size="small" wrap>
                                <span>Â°´ÂÖÖËâ≤</span>
                                <ColorPicker value={indicators.zs_fill_color} onChange={value => handleChange('zs_fill_color', value)} />
                                <span>ÈÄèÊòéÂ∫¶</span>
                                <Slider
                                    min={0}
                                    max={100}
                                    step={5}
                                    value={Math.round((indicators.zs_fill_opacity || 0) * 100)}
                                    onChange={value => handleChange('zs_fill_opacity', value / 100)}
                                    style={{ width: 120 }}
                                />
                            </Space>
                            <Space size="small" wrap>
                                <span>ËæπÊ°ÜËâ≤</span>
                                <ColorPicker value={indicators.zs_border_color} onChange={value => handleChange('zs_border_color', value)} />
                                <span>ËæπÊ°ÜÁ∫øÂûã</span>
                                <Select
                                    size="small"
                                    value={indicators.zs_border_style}
                                    style={{ width: 90 }}
                                    onChange={value => handleChange('zs_border_style', value)}
                                    options={LINE_STYLE_OPTIONS}
                                />
                                <span>ËæπÊ°ÜÂÆΩÂ∫¶</span>
                                <InputNumber
                                    min={1}
                                    max={4}
                                    size="small"
                                    value={indicators.zs_border_size}
                                    onChange={value => handleChange('zs_border_size', value || 1)}
                                />
                            </Space>
                            <Space size="small" wrap>
                                <Checkbox
                                    checked={indicators.zs_show_label}
                                    onChange={e => handleChange('zs_show_label', e.target.checked)}
                                >
                                    ÊòæÁ§∫‰∏≠Êû¢Á∫ßÂà´
                                </Checkbox>
                                {indicators.zs_show_label && (
                                    <>
                                        <span>ÊñáÂ≠óÈ¢úËâ≤</span>
                                        <ColorPicker value={indicators.zs_label_color} onChange={value => handleChange('zs_label_color', value)} />
                                    </>
                                )}
                            </Space>
                        </div>
                    </div>

                    <div className="indicator-section">
                        <div className="indicator-section-title">ÊäÄÊúØÊåáÊ†á</div>
                        <div className="indicator-item">
                            <Checkbox checked={indicators.plot_volume} onChange={e => handleChange('plot_volume', e.target.checked)}>
                                Êàê‰∫§Èáè (Volume)
                            </Checkbox>
                        </div>
                        <div className="indicator-item">
                            <Checkbox checked={indicators.plot_ma} onChange={e => handleChange('plot_ma', e.target.checked)}>
                                ÁßªÂä®Âπ≥ÂùáÁ∫ø (MA)
                            </Checkbox>
                            {indicators.plot_ma && (
                                <div style={{ marginTop: 8, paddingLeft: 16 }}>
                                    <Select
                                        mode="multiple"
                                        allowClear
                                        size="small"
                                        style={{ width: '100%' }}
                                        placeholder="ÈÄâÊã©Ë¶ÅÊòæÁ§∫ÁöÑMAÂë®Êúü"
                                        value={(indicators.ma_params || []).map(String)}
                                        onChange={values => handleChange('ma_params', values)}
                                        options={MA_OPTIONS.map(option => ({ value: String(option), label: `${option}` }))}
                                    />
                                </div>
                            )}
                        </div>
                        <div className="indicator-item">
                            <Checkbox checked={indicators.plot_macd} onChange={e => handleChange('plot_macd', e.target.checked)}>
                                MACD
                            </Checkbox>
                        </div>
                        <div className="indicator-item">
                            <Checkbox checked={indicators.plot_boll} onChange={e => handleChange('plot_boll', e.target.checked)}>
                                Â∏ÉÊûóÂ∏¶ (BOLL)
                            </Checkbox>
                        </div>
                        <div className="indicator-item">
                            <Checkbox checked={indicators.plot_kdj} onChange={e => handleChange('plot_kdj', e.target.checked)}>
                                KDJ
                            </Checkbox>
                        </div>
                        <div className="indicator-item">
                            <Checkbox checked={indicators.plot_rsi} onChange={e => handleChange('plot_rsi', e.target.checked)}>
                                RSI
                            </Checkbox>
                        </div>
                    </div>

                    <div className="indicator-section">
                        <div className="indicator-section-title">ÊåáÊ†áÂ∏ÉÂ±Ä</div>
                        <div className="indicator-item" style={{ marginBottom: 12 }}>
                            <Radio.Group
                                size="small"
                                value={indicators.indicator_layout || 'stack'}
                                onChange={e => handleChange('indicator_layout', e.target.value)}
                                buttonStyle="solid"
                            >
                                <Radio.Button value="stack">Â†ÜÂè†</Radio.Button>
                                <Radio.Button value="tab">ÂçïÁ™óÂè£ÂàáÊç¢</Radio.Button>
                            </Radio.Group>
                        </div>
                        {indicators.indicator_layout === 'tab' && LOWER_INDICATOR_KEYS.some(key => indicators[`plot_${key}`]) && (
                            <div className="indicator-item" style={{ display: 'flex', flexDirection: 'column', gap: 8 }}>
                                <span style={{ fontSize: 12, color: '#888' }}>ÈªòËÆ§Â±ïÁ§∫ÁöÑÊåáÊ†á</span>
                                <Select
                                    size="small"
                                    value={indicators.indicator_tab}
                                    onChange={value => handleChange('indicator_tab', value)}
                                    options={LOWER_INDICATOR_KEYS.filter(key => indicators[`plot_${key}`]).map(key => ({
                                        value: key,
                                        label: key === 'macd' ? 'MACD' : key.toUpperCase(),
                                    }))}
                                />
                            </div>
                        )}
                    </div>
                </div>
            );
        });

        const ChanConfigPanel = memo(() => {
            const { chanConfig, setChanConfig } = useApp();

            const mergeConfig = useCallback((patch) => {
                setChanConfig(prev => ({ ...prev, ...patch }));
            }, [setChanConfig]);

            const handleBoolean = useCallback((key) => (e) => {
                mergeConfig({ [key]: e.target.checked });
            }, [mergeConfig]);

            const handleNumber = useCallback((key) => (value) => {
                if (value === null || value === undefined) {
                    return;
                }
                const numeric = Number(value);
                if (Number.isFinite(numeric)) {
                    mergeConfig({ [key]: numeric });
                }
            }, [mergeConfig]);

            const handleSelect = useCallback((key) => (value) => {
                mergeConfig({ [key]: value });
            }, [mergeConfig]);

            const handleMacdChange = useCallback((field) => (value) => {
                if (value === null || value === undefined) return;
                const numeric = Number(value);
                if (!Number.isFinite(numeric)) return;
                setChanConfig(prev => ({
                    ...prev,
                    macd: {
                        ...prev.macd,
                        [field]: numeric,
                    },
                }));
            }, [setChanConfig]);

            const handleDemarkChange = useCallback((field) => (value) => {
                if (value === null || value === undefined) return;
                const numeric = Number(value);
                if (!Number.isFinite(numeric)) return;
                setChanConfig(prev => ({
                    ...prev,
                    demark: {
                        ...prev.demark,
                        [field]: numeric,
                    },
                }));
            }, [setChanConfig]);

            const handleDemarkToggle = useCallback((field) => (e) => {
                setChanConfig(prev => ({
                    ...prev,
                    demark: {
                        ...prev.demark,
                        [field]: e.target.checked,
                    },
                }));
            }, [setChanConfig]);

            const handleMeanMetricsChange = useCallback((values) => {
                const sanitized = Array.from(new Set((values || []).map(v => Number(v)).filter(Number.isFinite))).sort((a, b) => a - b);
                mergeConfig({ mean_metrics: sanitized });
            }, [mergeConfig]);

            const handleTrendMetricsChange = useCallback((values) => {
                const sanitized = Array.from(new Set((values || []).map(v => Number(v)).filter(Number.isFinite))).sort((a, b) => a - b);
                mergeConfig({ trend_metrics: sanitized });
            }, [mergeConfig]);

            const basicContent = (
                <Space direction="vertical" size={16} style={{ width: '100%' }}>
                    <div className="config-section">
                        <div className="config-section-title">Ê†∏ÂøÉÂèÇÊï∞</div>
                        <Space size="small" wrap>
                            <LabelWithTip label="Á¨îÁÆóÊ≥ï" tip="Á¨îÁöÑËØÜÂà´ÈÄªËæëÔºånormal ‰∏∫Ê†áÂáÜÁ¨î" />
                            <Select
                                size="small"
                                value={chanConfig.bi_algo}
                                onChange={handleSelect('bi_algo')}
                                options={BI_ALGO_OPTIONS}
                            />
                            <LabelWithTip label="Á∫øÊÆµÁÆóÊ≥ï" tip="Á∫øÊÆµÁîüÊàêÊñπÂºèÔºåchan ‰∏∫ÈªòËÆ§ÁÆóÊ≥ï" />
                            <Select
                                size="small"
                                value={chanConfig.seg_algo}
                                onChange={handleSelect('seg_algo')}
                                options={SEG_ALGO_OPTIONS}
                            />
                        </Space>
                        <Space size="small" wrap style={{ marginTop: 8 }}>
                            <Checkbox checked={chanConfig.bi_strict} onChange={handleBoolean('bi_strict')}>
                                <LabelWithTip label="‰∏•Ê†ºÁ¨î" tip="ÂºÄÂêØÂêéÂè™Êúâ‰∏•Ê†ºÈ°∂/Â∫ïÁöÑÁ¨î‰ºöË¢´ËØÜÂà´" />
                            </Checkbox>
                            <Checkbox checked={chanConfig.zs_combine} onChange={handleBoolean('zs_combine')}>
                                <LabelWithTip label="ÂêàÂπ∂‰∏≠Êû¢" tip="ÂÖÅËÆ∏Áõ∏ÈÇª‰∏≠Êû¢Ëá™Âä®ÂêàÂπ∂" />
                            </Checkbox>
                            <Checkbox checked={chanConfig.one_bi_zs} onChange={handleBoolean('one_bi_zs')}>
                                <LabelWithTip label="ÂçïÁ¨î‰∏≠Êû¢" tip="ÂÖÅËÆ∏ÂçïÁ¨îÊûÑÊàê‰∏≠Êû¢ÔºåÈÄÇÂêà‰ΩéÁ∫ßÂà´Ëµ∞Âäø" />
                            </Checkbox>
                            <LabelWithTip label="‰∏≠Êû¢ÁÆóÊ≥ï" tip="ÈÄâÊã©‰∏≠Êû¢ËÆ°ÁÆóÊñπÂºè" />
                            <Select
                                size="small"
                                value={chanConfig.zs_algo}
                                onChange={handleSelect('zs_algo')}
                                options={[
                                    { value: 'normal', label: 'Ê†áÂáÜ' },
                                    { value: 'over_seg', label: 'Ë∑®ÊÆµ' },
                                    { value: 'auto', label: 'Ëá™Âä®' },
                                ]}
                            />
                        </Space>
                    </div>

                    <div className="config-section">
                        <div className="config-section-title">ËøêË°åÊéßÂà∂</div>
                        <Space size="small" wrap>
                            <Checkbox checked={chanConfig.trigger_step} onChange={handleBoolean('trigger_step')}>
                                <LabelWithTip label="Â¢ûÈáèËß¶Âèë" tip="Â¢ûÈáèÊñπÂºèËÆ°ÁÆóÔºåÈÄÇÂêàÂÆûÊó∂Êõ¥Êñ∞" />
                            </Checkbox>
                            <Checkbox checked={chanConfig.kl_data_check} onChange={handleBoolean('kl_data_check')}>
                                <LabelWithTip label="Ê£ÄÊü•KÁ∫ø‰∏ÄËá¥ÊÄß" tip="Ëá™Âä®ÊØîÂØπÂ≠êÁ∫ßÂà´Êï∞ÊçÆ" />
                            </Checkbox>
                            <Checkbox checked={chanConfig.print_warning} onChange={handleBoolean('print_warning')}>
                                <LabelWithTip label="ÊâìÂç∞Ë≠¶Âëä" tip="ËæìÂá∫ËøêË°åË≠¶Âëä‰ø°ÊÅØ" />
                            </Checkbox>
                        </Space>
                        <Space size="small" wrap style={{ marginTop: 8 }}>
                            <LabelWithTip label="Ë∑≥ËøáÊ≠•Èïø" tip="Â¢ûÈáèÊ®°Âºè‰∏ãÊØèÊ¨°Ë∑≥ËøáÁöÑÁ¨îÊï∞Ôºå0 Ë°®Á§∫ÈÄêÁ¨î" />
                            <InputNumber size="small" min={0} value={chanConfig.skip_step} onChange={handleNumber('skip_step')} />
                            <LabelWithTip label="Â∏ÉÊûóN" tip="Â∏ÉÊûóÂ∏¶Á™óÂè£ÈïøÂ∫¶" />
                            <InputNumber size="small" min={1} value={chanConfig.boll_n} onChange={handleNumber('boll_n')} />
                        </Space>
                    </div>

                    <div className="config-section">
                        <div className="config-section-title">ÊåáÊ†á</div>
                        <Space size="small" wrap>
                            <LabelWithTip label="MACD" tip="Ë∞ÉÊï¥Âø´ÊÖ¢Á∫ø‰∏é‰ø°Âè∑Á∫øÂë®Êúü" />
                            <InputNumber size="small" min={1} value={chanConfig.macd.fast} onChange={handleMacdChange('fast')} />
                            <InputNumber size="small" min={1} value={chanConfig.macd.slow} onChange={handleMacdChange('slow')} />
                            <InputNumber size="small" min={1} value={chanConfig.macd.signal} onChange={handleMacdChange('signal')} />
                        </Space>
                        <Space size="small" wrap style={{ marginTop: 8 }}>
                            <Checkbox checked={chanConfig.cal_rsi} onChange={handleBoolean('cal_rsi')}>
                                <LabelWithTip label="RSI" tip="ÂºÄÂêØÂêéËÆ°ÁÆó RSI ÊåáÊ†á" />
                            </Checkbox>
                            <Checkbox checked={chanConfig.cal_kdj} onChange={handleBoolean('cal_kdj')}>
                                <LabelWithTip label="KDJ" tip="ÂºÄÂêØÂêéËÆ°ÁÆó KDJ ÊåáÊ†á" />
                            </Checkbox>
                            <Checkbox checked={chanConfig.cal_demark} onChange={handleBoolean('cal_demark')}>
                                <LabelWithTip label="DeMark" tip="ÂºÄÂêØÂêéËÆ°ÁÆó DeMark ÊåáÊ†á" />
                            </Checkbox>
                        </Space>
                    </div>
                </Space>
            );

            const advancedItems = [
                {
                    key: 'bi',
                    label: 'Á¨îÂèÇÊï∞',
                    children: (
                        <Space direction="vertical" size={12} style={{ width: '100%' }}>
                            <Space size="small" wrap>
                                <LabelWithTip label="ÂàÜÂûãÂà§ÂÆö" tip="ÂÜ≥ÂÆöÂàÜÂûãÁ°ÆËÆ§ÊñπÂºèÔºåÂΩ±ÂìçÁ¨îËØÜÂà´ÁöÑ‰∏•Ê†ºÁ®ãÂ∫¶" />
                                <Select
                                    size="small"
                                    value={chanConfig.bi_fx_check}
                                    onChange={handleSelect('bi_fx_check')}
                                    options={[
                                        { value: 'strict', label: '‰∏•Ê†º' },
                                        { value: 'half', label: 'Âçä‰∏•Ê†º' },
                                        { value: 'loss', label: 'ÊùæÂºõ' },
                                        { value: 'totally', label: 'ÂÖ®Èáè' },
                                    ]}
                                />
                            </Space>
                            <Space size="small" wrap>
                                <Checkbox checked={chanConfig.gap_as_kl} onChange={handleBoolean('gap_as_kl')}>
                                    <LabelWithTip label="Áº∫Âè£ËßÜ‰ΩúKÁ∫ø" tip="Â∞Ü‰ª∑Ê†ºË∑≥Á©∫ËßÜ‰ΩúÁã¨Á´ãKÁ∫øÂ§ÑÁêÜ" />
                                </Checkbox>
                                <Checkbox checked={chanConfig.bi_end_is_peak} onChange={handleBoolean('bi_end_is_peak')}>
                                    <LabelWithTip label="Á¨îÂ∞æÂøÖÈ°ªÈ°∂/Â∫ï" tip="Á¨îÁªìÊùüÊó∂ÂøÖÈ°ªÊª°Ë∂≥È°∂/Â∫ïÊù°‰ª∂" />
                                </Checkbox>
                                <Checkbox checked={chanConfig.bi_allow_sub_peak} onChange={handleBoolean('bi_allow_sub_peak')}>
                                    <LabelWithTip label="ÂÖÅËÆ∏Ê¨°Á∫ßÂà´È°∂Â∫ï" tip="ÂÖÅËÆ∏‰ΩøÁî®Ê¨°Á∫ßÂà´ÁöÑÈ°∂Â∫ïÂÆåÊàêÁ¨î" />
                                </Checkbox>
                            </Space>
                        </Space>
                    ),
                },
                {
                    key: 'seg',
                    label: 'Á∫øÊÆµ & ‰∏≠Êû¢',
                    children: (
                        <Space direction="vertical" size={12} style={{ width: '100%' }}>
                            <Space size="small" wrap>
                                <LabelWithTip label="Á∫øÊÆµÂ∑¶Á´Ø" tip="ÂÜ≥ÂÆöÁ∫øÊÆµËµ∑ÁÇπÁöÑËÆ°ÁÆóÊñπÂºè" />
                                <Select
                                    size="small"
                                    value={chanConfig.left_seg_method}
                                    onChange={handleSelect('left_seg_method')}
                                    options={[
                                        { value: 'peak', label: 'Â≥∞ÂÄº' },
                                        { value: 'all', label: 'ÂÖ®Èáè' },
                                    ]}
                                />
                                <LabelWithTip label="ÂêàÂπ∂Ê®°Âºè" tip="‰∏≠Êû¢ÂêàÂπ∂ÂêéÁöÑÁªìÊûú‰ª•‰∏≠Êû¢Ëá™Ë∫´ÊàñÁ∫øÊÆµÊõø‰ª£" />
                                <Select
                                    size="small"
                                    value={chanConfig.zs_combine_mode}
                                    onChange={handleSelect('zs_combine_mode')}
                                    options={[
                                        { value: 'zs', label: '‰∏≠Êû¢' },
                                        { value: 'seg', label: 'Á∫øÊÆµ' },
                                    ]}
                                    disabled={!chanConfig.zs_combine}
                                />
                            </Space>
                        </Space>
                    ),
                },
                {
                    key: 'runtime',
                    label: 'ËøêË°å‰∏éÊ†°È™å',
                    children: (
                        <Space direction="vertical" size={12} style={{ width: '100%' }}>
                            <Space size="small" wrap>
                                <Checkbox checked={chanConfig.auto_skip_illegal_sub_lv} onChange={handleBoolean('auto_skip_illegal_sub_lv')}>
                                    <LabelWithTip label="Ëá™Âä®Ë∑≥ËøáÈùûÊ≥ïÂ≠êÁ∫ßÂà´" tip="ÈÅáÂà∞‰∏çÂêàÊ≥ïÁöÑÂ≠êÁ∫ßÂà´Êï∞ÊçÆÊó∂Ëá™Âä®Ë∑≥Ëøá" />
                                </Checkbox>
                                <Checkbox checked={chanConfig.print_err_time} onChange={handleBoolean('print_err_time')}>
                                    <LabelWithTip label="ÊâìÂç∞ÂºÇÂ∏∏Êó∂Èó¥" tip="ËæìÂá∫ÂºÇÂ∏∏ÂèëÁîüÁöÑÊó∂Èó¥‰ø°ÊÅØ" />
                                </Checkbox>
                            </Space>
                            <Space size="small" wrap>
                                <LabelWithTip label="Èîô‰ΩçÂÆπÂøç" tip="ÂÖÅËÆ∏Â≠êÁ∫ßÂà´Èîô‰ΩçÁöÑÊúÄÂ§ßÊ¨°Êï∞" />
                                <InputNumber
                                    size="small"
                                    min={0}
                                    value={chanConfig.max_kl_misalgin_cnt}
                                    onChange={handleNumber('max_kl_misalgin_cnt')}
                                />
                                <LabelWithTip label="‰∏ç‰∏ÄËá¥ÂÆπÂøç" tip="ÂÖÅËÆ∏Â≠êÁ∫ßÂà´‰∏ç‰∏ÄËá¥ÁöÑÊúÄÂ§ßÊ¨°Êï∞" />
                                <InputNumber
                                    size="small"
                                    min={0}
                                    value={chanConfig.max_kl_inconsistent_cnt}
                                    onChange={handleNumber('max_kl_inconsistent_cnt')}
                                />
                            </Space>
                        </Space>
                    ),
                },
                {
                    key: 'metrics',
                    label: 'ÊåáÊ†áÂèÇÊï∞',
                    children: (
                        <Space direction="vertical" size={12} style={{ width: '100%' }}>
                            <Space size="small" wrap>
                                <LabelWithTip label="ÂùáÂÄºÁ™óÂè£" tip="Áî®‰∫éÂùáÂÄºÂ∫èÂàóÁöÑÁ™óÂè£ÈïøÂ∫¶ÔºåÂèØËæìÂÖ•Â§ö‰∏™Êï∞ÂÄº" />
                                <Select
                                    mode="tags"
                                    size="small"
                                    placeholder="Â¶Ç 5,10,20"
                                    style={{ minWidth: 200 }}
                                    value={(chanConfig.mean_metrics || []).map(String)}
                                    onChange={handleMeanMetricsChange}
                                />
                            </Space>
                            <Space size="small" wrap>
                                <LabelWithTip label="Ë∂ãÂäøÁ™óÂè£" tip="Ë∂ãÂäøÊåáÊ†á‰ΩøÁî®ÁöÑÊúÄÂ§ß/ÊúÄÂ∞èÁ™óÂè£ÈïøÂ∫¶" />
                                <Select
                                    mode="tags"
                                    size="small"
                                    placeholder="Â¶Ç 55, 89"
                                    style={{ minWidth: 200 }}
                                    value={(chanConfig.trend_metrics || []).map(String)}
                                    onChange={handleTrendMetricsChange}
                                />
                            </Space>
                            <Space size="small" wrap>
                                <LabelWithTip label="RSIÂë®Êúü" tip="RSI ÊåáÊ†áÁöÑÂë®ÊúüÈïøÂ∫¶" />
                                <InputNumber size="small" min={1} value={chanConfig.rsi_cycle} onChange={handleNumber('rsi_cycle')} disabled={!chanConfig.cal_rsi} />
                                <LabelWithTip label="KDJÂë®Êúü" tip="KDJ ÊåáÊ†áÁöÑÂë®ÊúüÈïøÂ∫¶" />
                                <InputNumber size="small" min={1} value={chanConfig.kdj_cycle} onChange={handleNumber('kdj_cycle')} disabled={!chanConfig.cal_kdj} />
                            </Space>
                            <Space size="small" wrap>
                                <LabelWithTip label="DeMark" tip="DeMark ÊåáÊ†áÂèÇÊï∞Ë∞ÉÊï¥" />
                                <InputNumber size="small" min={1} value={chanConfig.demark.demark_len} onChange={handleDemarkChange('demark_len')} disabled={!chanConfig.cal_demark} />
                                <InputNumber size="small" min={0} value={chanConfig.demark.setup_bias} onChange={handleDemarkChange('setup_bias')} disabled={!chanConfig.cal_demark} />
                                <InputNumber size="small" min={0} value={chanConfig.demark.countdown_bias} onChange={handleDemarkChange('countdown_bias')} disabled={!chanConfig.cal_demark} />
                                <InputNumber size="small" min={1} value={chanConfig.demark.max_countdown} onChange={handleDemarkChange('max_countdown')} disabled={!chanConfig.cal_demark} />
                            </Space>
                            <Space size="small" wrap>
                                <Checkbox checked={chanConfig.demark.tiaokong_st} onChange={handleDemarkToggle('tiaokong_st')} disabled={!chanConfig.cal_demark}>
                                    <LabelWithTip label="Ë∑≥Á©∫ÁÆó Setup" tip="Âú® Setup ËÆ°Êï∞Êó∂Â∞ÜË∑≥Á©∫ËßÜ‰ΩúÊª°Ë∂≥Êù°‰ª∂" />
                                </Checkbox>
                                <Checkbox checked={chanConfig.demark.setup_cmp2close} onChange={handleDemarkToggle('setup_cmp2close')} disabled={!chanConfig.cal_demark}>
                                    <LabelWithTip label="Setup ÊØîËæÉÊî∂Áõò‰ª∑" tip="Setup ÊØîËæÉ‰ΩøÁî®Êî∂Áõò‰ª∑ËÄåÈùûÊúÄÈ´ò/ÊúÄ‰Ωé" />
                                </Checkbox>
                                <Checkbox checked={chanConfig.demark.countdown_cmp2close} onChange={handleDemarkToggle('countdown_cmp2close')} disabled={!chanConfig.cal_demark}>
                                    <LabelWithTip label="Countdown ÊØîËæÉÊî∂Áõò‰ª∑" tip="Countdown ËÆ°Êï∞‰ΩøÁî®Êî∂Áõò‰ª∑ÊØîËæÉ" />
                                </Checkbox>
                            </Space>
                        </Space>
                    ),
                },
            ];

            return (
                <Tabs
                    size="small"
                    defaultActiveKey="basic"
                    items={[
                        { key: 'basic', label: 'Âü∫Á°ÄËÆæÁΩÆ', children: basicContent },
                        { key: 'advanced', label: 'È´òÁ∫ßËÆæÁΩÆ', children: <Collapse ghost defaultActiveKey={[]} items={advancedItems} /> },
                    ]}
                />
            );
        });

        const AlertPanel = memo(() => {
            const { alertHistory, alertConnected, alertError, alertStrategies, refreshAlertHistory } = useApp();
            const severityColorMap = {
                info: 'processing',
                warning: 'warning',
                critical: 'error',
            };

            return (
                <div className="alert-panel">
                    <div className="alert-status">
                        <span className="alert-status-indicator">
                            <span className={`status-dot ${alertConnected ? 'status-dot--online' : 'status-dot--offline'}`} />
                            {alertConnected ? 'ÂÆûÊó∂ËøûÊé•Ê≠£Â∏∏' : 'Á≠âÂæÖÂÆûÊó∂Êï∞ÊçÆ...'}
                        </span>
                        <Button size="small" onClick={refreshAlertHistory}>Âà∑Êñ∞</Button>
                    </div>
                    {alertError && <div className="alert-error-text">{alertError}</div>}
                    <div>
                        <div className="config-section-title">Â∑≤ÂêØÁî®Á≠ñÁï•</div>
                        <div className="alert-strategy-tags">
                            {alertStrategies.length === 0 ? (
                                <div className="chart-info-placeholder">ÊöÇÊó†Á≠ñÁï•</div>
                            ) : (
                                alertStrategies.map(strategy => (
                                    <Tag key={strategy.id}>{strategy.name}</Tag>
                                ))
                            )}
                        </div>
                    </div>
                    <div>
                        <div className="config-section-title">ÂÆûÊó∂Êä•Ë≠¶</div>
                        <div className="alert-history">
                            {alertHistory.length === 0 ? (
                                <div className="chart-info-placeholder">ÊöÇÊó†Êä•Ë≠¶ÔºåÁ≠ñÁï•ËøêË°å‰∏≠...</div>
                            ) : (
                                alertHistory.map((alert, idx) => (
                                    <div key={`${alert.strategy_id}-${alert.created_at}-${idx}`} className="alert-card">
                                        <div className="alert-card-header">
                                            <span className="alert-card-title">{alert.strategy_name || alert.strategy_id}</span>
                                            <Tag color={severityColorMap[alert.severity] || 'default'}>
                                                {(alert.severity || 'info').toUpperCase()}
                                            </Tag>
                                        </div>
                                        <div className="alert-card-message">{alert.message}</div>
                                        <div className="alert-card-meta">
                                            <span>{alert.symbol} ¬∑ {alert.level}</span>
                                            <span>{alert.created_at ? dayjs(alert.created_at).format('MM-DD HH:mm:ss') : '--'}</span>
                                        </div>
                                    </div>
                                ))
                            )}
                        </div>
                    </div>
                </div>
            );
        });

        const RightSidebar = memo(() => (
            <Tabs
                size="small"
                defaultActiveKey="view"
                items={[
                    { key: 'view', label: 'ÊòæÁ§∫ËÆæÁΩÆ', children: <IndicatorConfig /> },
                    { key: 'chan', label: 'Áº†ËÆ∫ÈÖçÁΩÆ', children: <ChanConfigPanel /> },
                    { key: 'alerts', label: 'ÁõØÁõòÊä•Ë≠¶', children: <AlertPanel /> },
                ]}
            />
        ));

        // ============= Chart Grid Component =============
        const ChartGrid = () => (
            <div className="chart-grid chart-grid-1x1">
                <ActiveStockPanel />
            </div>
        );

        // ============= Main App Component =============
        const App = () => {
            const savedConfig = loadConfig();

            const hydrateStocks = (rawStocks = []) => {
                const timestampBase = Date.now();
                return rawStocks
                    .filter(stock => stock && stock.code)
                    .map((stock, idx) => ({
                        id: stock.id ?? (timestampBase + idx),
                        code: stock.code,
                        name: stock.name || '',
                    }));
            };

            const initialStocks = useMemo(() => hydrateStocks(savedConfig?.stocks), []);
            const savedIndicators = sanitizeIndicators(savedConfig?.indicators);

            const [stocks, setStocks] = useState(initialStocks);
            const [activeStockCode, setActiveStockCode] = useState(() => {
                const stored = savedConfig?.ui?.activeStockCode;
                if (stored) {
                    return stored;
                }
                return initialStocks[0]?.code ?? null;
            });
            const [activeLevels, setActiveLevels] = useState(() => {
                const stored = savedConfig?.chart?.activeLevels;
                if (Array.isArray(stored) && stored.length > 0) {
                    return Array.from(new Set(stored));
                }
                return [DEFAULT_LEVEL];
            });
            const [levelLayout, setLevelLayout] = useState(savedConfig?.chart?.layout || 'stack');
            const [indicators, setIndicators] = useState(() => ({
                ...DEFAULT_INDICATORS,
                ...savedIndicators,
            }));
            const [chanConfig, setChanConfig] = useState(() => {
                const savedChan = savedConfig?.chanConfig || {};
                return {
                    ...DEFAULT_CHAN_CONFIG,
                    ...savedChan,
                    macd: {
                        ...DEFAULT_CHAN_CONFIG.macd,
                        ...(savedChan.macd || {}),
                    },
                    demark: {
                        ...DEFAULT_CHAN_CONFIG.demark,
                        ...(savedChan.demark || {}),
                    },
                };
            });
            const [chartData, setChartData] = useState({});
            const [loadingCharts, setLoadingCharts] = useState({});
            const [theme, setTheme] = useState(savedConfig?.theme || 'light');
            const [leftCollapsed, setLeftCollapsed] = useState(savedConfig?.ui?.leftCollapsed || false);
            const [rightCollapsed, setRightCollapsed] = useState(savedConfig?.ui?.rightCollapsed || false);
            const [leftWidth, setLeftWidth] = useState(savedConfig?.ui?.leftWidth || 280);
            const [rightWidth, setRightWidth] = useState(savedConfig?.ui?.rightWidth || 320);
            const [dragging, setDragging] = useState(null);
            const layoutRef = useRef(null);
            const [alertHistory, setAlertHistory] = useState([]);
            const [alertConnected, setAlertConnected] = useState(false);
            const [alertError, setAlertError] = useState(null);
            const [alertStrategies, setAlertStrategies] = useState([]);
            const alertWsRef = useRef(null);
            const reconnectTimerRef = useRef(null);
            const chartRegistryRef = useRef(new Map());
            const syncLockRef = useRef(false);
            const latestRangeRef = useRef(null);

            const activeStock = useMemo(() => {
                if (!activeStockCode) {
                    return null;
                }
                return stocks.find(stock => stock.code === activeStockCode) || null;
            }, [stocks, activeStockCode]);

            useEffect(() => {
                try {
                    const config = {
                        stocks,
                        indicators: sanitizeIndicators(indicators),
                        chanConfig,
                        theme,
                        ui: { leftCollapsed, rightCollapsed, leftWidth, rightWidth, activeStockCode },
                        chart: { activeLevels, layout: levelLayout },
                    };
                    localStorage.setItem('chanlun_config', JSON.stringify(config));
                } catch (e) {
                    console.error('Failed to save config:', e);
                }
            }, [stocks, indicators, chanConfig, theme, leftCollapsed, rightCollapsed, leftWidth, rightWidth, activeStockCode, activeLevels, levelLayout]);

            useEffect(() => {
                if (stocks.length === 0) {
                    if (activeStockCode !== null) {
                        setActiveStockCode(null);
                    }
                    return;
                }
                if (!activeStockCode || !stocks.some(stock => stock.code === activeStockCode)) {
                    setActiveStockCode(stocks[0].code);
                }
            }, [stocks, activeStockCode]);

            const analyzeStock = useCallback(async (code, level, forceRefresh = false) => {
                const key = `${code}-${level}`;

                if (!forceRefresh) {
                    const cachedData = DataCache.get(key);
                    if (cachedData) {
                        setChartData(prev => ({ ...prev, [key]: cachedData }));
                        return;
                    }
                }

                setLoadingCharts(prev => ({ ...prev, [key]: true }));

                try {
                    const params = {
                        code,
                        lv_list: [level],
                        data_src: 'BAO_STOCK',
                        ...indicators,
                        chan_config: chanConfig,
                    };

                    const result = await api.calculateChan(params);
                    setChartData(prev => ({ ...prev, [key]: result }));
                    DataCache.set(key, result);
                } catch (error) {
                    console.error('Analysis failed:', error);
                    message.error(`${code} ${level} ÂàÜÊûêÂ§±Ë¥•: ${error.message}`);
                } finally {
                    setLoadingCharts(prev => ({ ...prev, [key]: false }));
                }
            }, [indicators, chanConfig]);

            const refreshAllCharts = useCallback(() => {
                if (!activeStock) {
                    message.info('ËØ∑ÈÄâÊã©ËÇ°Á•®ÂêéÂÜçÂà∑Êñ∞');
                    return;
                }
                DataCache.clear();
                activeLevels.forEach(level => analyzeStock(activeStock.code, level, true));
                message.info(`Ê≠£Âú®Âà∑Êñ∞ ${activeStock.code}...`);
            }, [activeStock, activeLevels, analyzeStock]);

            const prevIndicatorsRef = useRef(indicators);
            useEffect(() => {
                const prev = prevIndicatorsRef.current;
                const changed = ['plot_bi', 'plot_seg', 'plot_zs', 'plot_bsp', 'plot_ma', 'plot_macd', 'plot_boll', 'plot_kdj', 'plot_rsi', 'plot_volume']
                    .some(key => prev[key] !== indicators[key]);

                if (changed && Object.keys(prev).length > 0 && activeStock) {
                    setTimeout(() => refreshAllCharts(), 100);
                }
                prevIndicatorsRef.current = indicators;
            }, [indicators, activeStock, refreshAllCharts]);

            useEffect(() => {
                if (indicators.indicator_layout !== 'tab') {
                    return;
                }
                const available = LOWER_INDICATOR_KEYS.filter(key => indicators[`plot_${key}`]);
                if (available.length === 0) {
                    if (indicators.indicator_tab) {
                        setIndicators(prev => ({ ...prev, indicator_tab: null }));
                    }
                    return;
                }
                if (!available.includes(indicators.indicator_tab)) {
                    setIndicators(prev => ({ ...prev, indicator_tab: available[0] }));
                }
            }, [indicators.indicator_layout, indicators.plot_macd, indicators.plot_kdj, indicators.plot_rsi, indicators.indicator_tab, setIndicators]);

            const prevChanConfigRef = useRef(chanConfig);
            useEffect(() => {
                if (prevChanConfigRef.current !== chanConfig && activeStock) {
                    console.log('‚öôÔ∏è Chan config changed, refreshing charts...');
                    setTimeout(() => refreshAllCharts(), 120);
                }
                prevChanConfigRef.current = chanConfig;
            }, [chanConfig, activeStock, refreshAllCharts]);

            useEffect(() => {
                if (dragging) {
                    document.body.style.cursor = 'col-resize';
                } else {
                    document.body.style.cursor = '';
                }
                return () => {
                    document.body.style.cursor = '';
                };
            }, [dragging]);

            useEffect(() => {
                api.listAlertStrategies()
                    .then(res => setAlertStrategies(res.items || []))
                    .catch(err => console.warn('‚ö†Ô∏è Failed to load alert strategies:', err));
            }, []);

            const addStock = useCallback((stockInfo = {}) => {
                const code = (stockInfo.code || '').trim();
                if (!code) {
                    message.warning('ËÇ°Á•®‰ª£Á†ÅÊó†Êïà');
                    return 'invalid';
                }

                const displayName = (stockInfo.name || '').trim();
                const existing = stocks.find(s => s.code === code);
                if (existing) {
                    if (displayName && displayName !== existing.name) {
                        setStocks(prev => prev.map(s => s.code === code ? { ...s, name: displayName } : s));
                        return 'updated';
                    }
                    return 'unchanged';
                }

                const newStock = {
                    id: Date.now() + Math.floor(Math.random() * 1000),
                    code,
                    name: displayName,
                };
                setStocks(prev => [...prev, newStock]);
                return 'new';
            }, [stocks]);

            const removeStock = useCallback((stockId) => {
                setStocks(prev => prev.filter(s => s.id !== stockId));
            }, []);

            const toggleLeftSidebar = () => setLeftCollapsed(prev => !prev);
            const toggleRightSidebar = () => setRightCollapsed(prev => !prev);

            const registerChartInstance = useCallback((key, entry) => {
                if (!key || !entry || !entry.chart || typeof entry.getIndexRange !== 'function') {
                    return;
                }
                chartRegistryRef.current.set(key, entry);
                console.log('üìå [Registry] add', key, 'total:', chartRegistryRef.current.size);
                const latest = latestRangeRef.current;
                if (!latest || latest.sourceKey === key) {
                    if (latest) {
                        console.log('‚ÑπÔ∏è [Registry] latest from', latest.sourceKey, 'skipped for', key);
                    }
                    return;
                }
                const range = entry.getIndexRange(latest.fromTs, latest.toTs);
                if (!Array.isArray(range)) {
                    console.warn('‚ö†Ô∏è [Registry] no range when restoring', key, latest);
                    return;
                }
                const [fromIdx, toIdx] = range;
                if (!Number.isFinite(fromIdx) || !Number.isFinite(toIdx)) {
                    console.warn('‚ö†Ô∏è [Registry] invalid range when restoring', key, range);
                    return;
                }
                try {
                    let applied = false;
                    if (typeof entry.applyIndexRange === 'function') {
                        applied = entry.applyIndexRange(fromIdx, toIdx, latest);
                    }
                    if (!applied) {
                        if (typeof entry.chart.scrollToDataIndex === 'function') {
                            if (typeof entry.suppressNextBroadcast === 'function') {
                                entry.suppressNextBroadcast();
                            }
                            entry.chart.scrollToDataIndex(Math.max(fromIdx, toIdx), 0);
                            applied = true;
                        } else if (typeof entry.chart.scrollToTimestamp === 'function' && Number.isFinite(latest.toTs)) {
                            if (typeof entry.suppressNextBroadcast === 'function') {
                                entry.suppressNextBroadcast();
                            }
                            entry.chart.scrollToTimestamp(latest.toTs, 0);
                            applied = true;
                        }
                    }
                    if (applied) {
                        console.log('‚è™ [Registry] restore', key, { fromIdx, toIdx, fromTs: latest.fromTs, toTs: latest.toTs });
                    } else {
                        console.warn('‚ö†Ô∏è [Registry] unable to apply synced range', key);
                    }
                } catch (err) {
                    console.warn('‚ö†Ô∏è Failed to apply synced range on register', err);
                }
            }, []);

            const unregisterChartInstance = useCallback((key) => {
                chartRegistryRef.current.delete(key);
                console.log('üóë [Registry] remove', key, 'total:', chartRegistryRef.current.size);
            }, []);

            const syncVisibleRange = useCallback((sourceKey, fromTs, toTs) => {
                if (!Number.isFinite(fromTs) || !Number.isFinite(toTs)) {
                    return;
                }
                if (syncLockRef.current) {
                    return;
                }
                syncLockRef.current = true;
                console.log('üì° [Sync] broadcast', sourceKey, { fromTs, toTs });
                latestRangeRef.current = { sourceKey, fromTs, toTs };
                try {
                    chartRegistryRef.current.forEach((entry, key) => {
                        if (key === sourceKey) {
                            return;
                        }
                        if (!entry || !entry.chart) {
                            console.warn('‚ö†Ô∏è [Sync] skip chart', key, 'missing instance');
                            return;
                        }
                        const range = entry.getIndexRange(fromTs, toTs);
                        if (!Array.isArray(range)) {
                            console.warn('‚ö†Ô∏è [Sync] no range for target', key, { fromTs, toTs });
                            return;
                        }
                        const [fromIdx, toIdx] = range;
                        if (!Number.isFinite(fromIdx) || !Number.isFinite(toIdx)) {
                            console.warn('‚ö†Ô∏è [Sync] invalid indices for target', key, range);
                            return;
                        }
                        try {
                            let applied = false;
                            if (typeof entry.applyIndexRange === 'function') {
                                applied = entry.applyIndexRange(fromIdx, toIdx, { fromTs, toTs, sourceKey });
                            }
                            if (!applied) {
                                if (typeof entry.chart.scrollToDataIndex === 'function') {
                                    if (typeof entry.suppressNextBroadcast === 'function') {
                                        entry.suppressNextBroadcast();
                                    }
                                    entry.chart.scrollToDataIndex(Math.max(fromIdx, toIdx), 0);
                                    applied = true;
                                } else if (typeof entry.chart.scrollToTimestamp === 'function' && Number.isFinite(toTs)) {
                                    if (typeof entry.suppressNextBroadcast === 'function') {
                                        entry.suppressNextBroadcast();
                                    }
                                    entry.chart.scrollToTimestamp(toTs, 0);
                                    applied = true;
                                }
                            }
                            if (applied) {
                                console.log('üéØ [Sync] apply', key, { fromIdx, toIdx });
                            } else {
                                console.warn('‚ö†Ô∏è [Sync] no method to apply range', key);
                            }
                        } catch (err) {
                            console.warn('‚ö†Ô∏è Failed to sync visible range', err);
                        }
                    });
                } finally {
                    syncLockRef.current = false;
                }
            }, []);

            const startResize = useCallback((side) => (event) => {
                if (side === 'left' && leftCollapsed) return;
                if (side === 'right' && rightCollapsed) return;
                if (!layoutRef.current) return;
                event.preventDefault();
                setDragging(side);

                const handleMove = (e) => {
                    if (!layoutRef.current) return;
                    const currentRect = layoutRef.current.getBoundingClientRect();
                    const minMain = 400;
                    const currentLeftWidth = leftCollapsed ? 0 : (layoutRef.current.querySelector('.left-sidebar')?.getBoundingClientRect().width || leftWidth);
                    const currentRightWidth = rightCollapsed ? 0 : (layoutRef.current.querySelector('.right-sidebar')?.getBoundingClientRect().width || rightWidth);
                    if (side === 'left') {
                        const maxLeft = currentRect.width - currentRightWidth - minMain;
                        const newWidth = clamp(e.clientX - currentRect.left, 200, Math.max(200, maxLeft));
                        setLeftWidth(newWidth);
                    } else {
                        const maxRight = currentRect.width - currentLeftWidth - minMain;
                        const newWidth = clamp(currentRect.right - e.clientX, 220, Math.max(220, maxRight));
                        setRightWidth(newWidth);
                    }
                };

                const handleUp = () => {
                    setDragging(null);
                    window.removeEventListener('mousemove', handleMove);
                    window.removeEventListener('mouseup', handleUp);
                };

                window.addEventListener('mousemove', handleMove);
                window.addEventListener('mouseup', handleUp);
            }, [leftCollapsed, rightCollapsed, rightWidth, leftWidth]);

            const refreshAlertHistory = useCallback(async () => {
                try {
                    const result = await api.getAlertHistory(50);
                    setAlertHistory(Array.isArray(result.items) ? result.items.slice(0, ALERT_HISTORY_LIMIT) : []);
                    setAlertError(null);
                } catch (error) {
                    console.error('‚ö†Ô∏è Failed to fetch alert history:', error);
                    setAlertError('Êó†Ê≥ïËé∑ÂèñÊä•Ë≠¶ÂéÜÂè≤');
                }
            }, []);

            useEffect(() => {
                refreshAlertHistory();
                let shouldReconnect = true;
                const wsUrl = `${API_BASE.replace(/^http/, 'ws')}/api/alerts/stream`;

                const connect = () => {
                    const ws = new WebSocket(wsUrl);
                    alertWsRef.current = ws;

                    ws.onopen = () => {
                        setAlertConnected(true);
                        setAlertError(null);
                    };

                    ws.onmessage = (event) => {
                        try {
                            const payload = JSON.parse(event.data);
                            if (payload.type === 'history') {
                                if (Array.isArray(payload.data)) {
                                    setAlertHistory(payload.data.slice(0, ALERT_HISTORY_LIMIT));
                                }
                            } else if (payload.type === 'alert' && payload.data) {
                                setAlertHistory(prev => {
                                    const next = [payload.data, ...prev];
                                    return next.slice(0, ALERT_HISTORY_LIMIT);
                                });
                            }
                        } catch (err) {
                            console.error('‚ö†Ô∏è Failed to parse alert payload:', err);
                        }
                    };

                    ws.onerror = () => {
                        setAlertError('ÂÆûÊó∂ËøûÊé•ÂºÇÂ∏∏');
                    };

                    ws.onclose = () => {
                        setAlertConnected(false);
                        if (shouldReconnect) {
                            reconnectTimerRef.current = setTimeout(connect, 5000);
                        }
                    };
                };

                connect();

                return () => {
                    shouldReconnect = false;
                    if (alertWsRef.current) {
                        alertWsRef.current.close();
                        alertWsRef.current = null;
                    }
                    if (reconnectTimerRef.current) {
                        clearTimeout(reconnectTimerRef.current);
                        reconnectTimerRef.current = null;
                    }
                };
            }, [refreshAlertHistory]);

            const contextValue = {
                stocks,
                addStock,
                removeStock,
                activeStock,
                activeStockCode,
                setActiveStockCode,
                activeLevels,
                setActiveLevels,
                levelLayout,
                setLevelLayout,
                indicators,
                setIndicators,
                chanConfig,
                setChanConfig,
                chartData,
                loadingCharts,
                analyzeStock,
                refreshAllCharts,
                registerChartInstance,
                unregisterChartInstance,
                syncVisibleRange,
                theme,
                alertHistory,
                alertConnected,
                alertError,
                alertStrategies,
                refreshAlertHistory,
            };

            return (
                <AppContext.Provider value={contextValue}>
                    <Layout ref={layoutRef} className={`app-layout ${theme === 'dark' ? 'dark-theme' : ''}`}>
                        <Header className="app-header">
                            <div className="app-logo">
                                <span>üìà</span>
                                <span>Áº†ËÆ∫Âú®Á∫øÂàÜÊûêÁ≥ªÁªü (KLineChartÁâà)</span>
                            </div>
                            <div className="app-header-actions">
                                <Tooltip title={leftCollapsed ? 'Â±ïÂºÄËá™ÈÄâÈù¢Êùø' : 'Êî∂Ëµ∑Ëá™ÈÄâÈù¢Êùø'}>
                                    <Button size="small" onClick={toggleLeftSidebar}>
                                        {leftCollapsed ? 'üìÇ Â±ïÂºÄ' : 'üìÅ Êî∂Ëµ∑'}
                                    </Button>
                                </Tooltip>
                                <Tooltip title="ÂàáÊç¢‰∏ªÈ¢ò">
                                    <Button
                                        size="small"
                                        onClick={() => setTheme(prev => prev === 'light' ? 'dark' : 'light')}
                                    >
                                        {theme === 'light' ? 'üåô' : '‚òÄÔ∏è'}
                                    </Button>
                                </Tooltip>
                                <Tooltip title="Âà∑Êñ∞ÊâÄÊúâÂõæË°®">
                                    <Button size="small" onClick={refreshAllCharts}>
                                        üîÑ Âà∑Êñ∞
                                    </Button>
                                </Tooltip>
                                <Tooltip title="Ê∏ÖÁ©∫ÊâÄÊúâËÇ°Á•®">
                                    <Button size="small" danger onClick={() => setStocks([])}>
                                        Ê∏ÖÁ©∫
                                    </Button>
                                </Tooltip>
                                <Tooltip title={rightCollapsed ? 'Â±ïÂºÄÊåáÊ†áÈÖçÁΩÆ' : 'Êî∂Ëµ∑ÊåáÊ†áÈÖçÁΩÆ'}>
                                    <Button size="small" onClick={toggleRightSidebar}>
                                        {rightCollapsed ? 'üõ† Â±ïÂºÄ' : 'üõ† Êî∂Ëµ∑'}
                                    </Button>
                                </Tooltip>
                            </div>
                        </Header>
                        <div className="app-content">
                            {!leftCollapsed && (
                                <>
                                    <div className="sidebar left-sidebar" style={{ width: leftWidth }}>
                                        <StockManager />
                                    </div>
                                    <div
                                        className={`sidebar-resizer ${dragging === 'left' ? 'dragging' : ''}`}
                                        onMouseDown={startResize('left')}
                                    />
                                </>
                            )}
                            <div className="main-content">
                                <ChartGrid />
                            </div>
                            {!rightCollapsed && (
                                <>
                                    <div
                                        className={`sidebar-resizer ${dragging === 'right' ? 'dragging' : ''}`}
                                        onMouseDown={startResize('right')}
                                    />
                                    <div className="sidebar right-sidebar" style={{ width: rightWidth }}>
                                        <RightSidebar />
                                    </div>
                                </>
                            )}
                        </div>
                    </Layout>
                </AppContext.Provider>
            );
        };

        // Render app
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
