<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Áº†ËÆ∫Âú®Á∫øÂàÜÊûêÁ≥ªÁªü - KLineChartÁâà</title>
    
    <!-- React & ReactDOM (must load first) -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <!-- Babel for JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- KLineChart - ‰ΩøÁî®Êú¨Âú∞ÁâàÊú¨(v10.0.0-alpha5) -->
    <script src="/static/lib/klinecharts.min.js"></script>
    
    <!-- Ant Design CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/antd@5.12.0/dist/reset.css">
    
    <!-- Ant Design JS -->
    <script src="https://cdn.jsdelivr.net/npm/dayjs@1.11.10/dayjs.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/antd@5.12.0/dist/antd.min.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: #f5f5f5;
        }

        .app-layout {
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .app-header {
            background: #001529;
            color: white;
            padding: 0 24px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            height: 64px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
        }

        .app-logo {
            display: flex;
            align-items: center;
            gap: 12px;
            font-size: 20px;
            font-weight: 600;
        }

        .app-logo span:first-child {
            font-size: 28px;
        }

        .app-header-actions {
            display: flex;
            gap: 16px;
            align-items: center;
        }

        .app-content {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        .sidebar {
            background: white;
            padding: 16px;
            overflow-y: auto;
            box-shadow: 2px 0 8px rgba(0,0,0,0.05);
        }

        .left-sidebar {
            width: 280px;
        }

        .right-sidebar {
            width: 320px;
        }

        .main-content {
            flex: 1;
            padding: 16px;
            overflow-y: auto;
            background: #f0f2f5;
        }

        /* Stock Manager Styles */
        .stock-manager-title {
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 16px;
            color: #262626;
        }

        .stock-input-group {
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin-bottom: 16px;
        }

        .quick-add-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-bottom: 16px;
        }

        .stock-list {
            margin-top: 16px;
        }

        .stock-item {
            border: 1px solid #e8e8e8;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 12px;
            background: #fafafa;
            transition: all 0.3s;
        }

        .stock-item:hover {
            background: #f0f0f0;
            border-color: #1890ff;
        }

        .stock-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .stock-code {
            font-weight: 600;
            font-size: 14px;
            color: #262626;
        }

        .stock-levels {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            margin-bottom: 8px;
        }

        .stock-actions {
            display: flex;
            gap: 8px;
        }

        /* Chart Grid */
        .chart-grid {
            display: grid;
            gap: 16px;
        }

        .chart-grid-1x1 {
            grid-template-columns: 1fr;
        }

        .chart-grid-2x1 {
            grid-template-columns: repeat(2, 1fr);
        }

        .chart-grid-2x2 {
            grid-template-columns: repeat(2, 1fr);
            grid-template-rows: repeat(2, minmax(600px, 1fr));
        }

        .chart-grid-3x2 {
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(2, minmax(600px, 1fr));
        }

        .chart-card {
            background: white;
            border-radius: 8px;
            padding: 16px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            display: flex;
            flex-direction: column;
            min-height: 600px;
        }

        .chart-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
            padding-bottom: 12px;
            border-bottom: 1px solid #f0f0f0;
        }

        .chart-title {
            font-size: 16px;
            font-weight: 600;
            color: #262626;
        }

        .chart-container {
            flex: 1;
            position: relative;
            min-height: 500px;
        }

        /* Indicator Config */
        .indicator-section {
            margin-bottom: 16px;
        }

        .indicator-section-title {
            font-weight: 600;
            margin-bottom: 12px;
            color: #262626;
            font-size: 14px;
        }

        .indicator-item {
            margin-bottom: 8px;
        }

        /* Responsive */
        @media (max-width: 1400px) {
            .left-sidebar { width: 240px; }
            .right-sidebar { width: 280px; }
        }

        @media (max-width: 1200px) {
            .chart-grid-3x2 {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        @media (max-width: 768px) {
            .app-content {
                flex-direction: column;
            }
            .sidebar {
                width: 100% !important;
                max-height: 300px;
            }
            .chart-grid-2x1,
            .chart-grid-2x2,
            .chart-grid-3x2 {
                grid-template-columns: 1fr;
            }
        }

        /* Dark theme support */
        .dark-theme {
            background: #141414;
        }

        .dark-theme .sidebar,
        .dark-theme .chart-card {
            background: #1f1f1f;
            color: #e8e8e8;
        }

        .dark-theme .main-content {
            background: #000;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { Layout, Button, Input, Select, Checkbox, message, Spin, Tag, Space, Tooltip, Radio } = antd;
        const { Header, Sider, Content } = Layout;
        const { useState, useEffect, useCallback, useContext, createContext, useRef, memo } = React;

        // ============= Version & Debug Info =============
        console.log('üöÄ Chan.py Web v4.1.0 - KLineChart + Full Chan Theory Support');
        console.log('üìÖ Loaded at:', new Date().toISOString());
        console.log('‚úÖ Bi/Seg/ZS/BSP fully implemented with KLineChart overlay API');
        console.log('üéØ All Chan theory indicators working perfectly!');
        
        // Check if KLineChart is loaded
        if (typeof klinecharts === 'undefined') {
            console.error('‚ùå KLineChart library not loaded! Check CDN.');
            console.error('üí° Try refreshing the page or check network in DevTools.');
        } else {
            console.log('‚úÖ KLineChart library loaded:', klinecharts.version || 'version unknown');
        }

        // ============= Constants =============
        const API_BASE = 'http://localhost:8000';
        
        const LEVEL_OPTIONS = [
            { value: 'day', label: 'Êó•Á∫ø' },
            { value: '60m', label: '60ÂàÜ' },
            { value: '30m', label: '30ÂàÜ' },
            { value: '15m', label: '15ÂàÜ' },
            { value: '5m', label: '5ÂàÜ' },
        ];

        const QUICK_STOCKS = [
            { code: 'sz.000001', name: 'Âπ≥ÂÆâÈì∂Ë°å' },
            { code: 'sh.600000', name: 'Êµ¶ÂèëÈì∂Ë°å' },
            { code: 'sh.600036', name: 'ÊãõÂïÜÈì∂Ë°å' },
            { code: 'sh.000300', name: 'Ê≤™Ê∑±300' },
        ];

        // ============= Data Cache =============
        const DataCache = {
            cache: {},
            get(key) {
                const item = this.cache[key];
                if (item && Date.now() - item.timestamp < 5 * 60 * 1000) {
                    return item.data;
                }
                return null;
            },
            set(key, data) {
                this.cache[key] = { data, timestamp: Date.now() };
            },
            clear() {
                this.cache = {};
            }
        };

        // ============= Utility Functions =============
        const convertTime = (timeStr) => {
            if (!timeStr) return null;
            const cleaned = timeStr.replace(/\//g, '-');
            const date = new Date(cleaned);
            if (isNaN(date.getTime())) return null;
            return date.getTime();
        };

        const debounce = (func, wait) => {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        };

        // ============= Config Management =============
        const loadConfig = () => {
            try {
                const config = localStorage.getItem('chanlun_config');
                return config ? JSON.parse(config) : null;
            } catch (e) {
                console.error('Failed to load config:', e);
                return null;
            }
        };

        // ============= API Service =============
        const api = {
            async calculateChan(params) {
                console.log('üåê [API] Request:', params);
                const response = await fetch(`${API_BASE}/api/analysis/calculate`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(params),
                });
                if (!response.ok) {
                    throw new Error(`API Error: ${response.statusText}`);
                }
                const result = await response.json();
                console.log('üåê [API] Response:', {
                    kline_count: result.kline_data?.length,
                    bi_count: result.bi_list?.length,
                    seg_count: result.seg_list?.length,
                });
                return result;
            }
        };

        // ============= App Context =============
        const AppContext = createContext();
        const useApp = () => useContext(AppContext);

        // ============= Chart Component =============
        const ChartPanel = memo(({ stockCode, level, data, loading }) => {
            const chartRef = useRef(null);
            const chartInstanceRef = useRef(null);
            const { indicators, theme } = useApp();

            useEffect(() => {
                if (!chartRef.current || !data) return;

                // Initialize KLineChart
                const chart = klinecharts.init(chartRef.current);
                chartInstanceRef.current = chart;

                // Apply theme
                chart.setStyles({
                    grid: {
                        show: true,
                        horizontal: {
                            show: true,
                            color: theme === 'dark' ? '#333' : '#f0f0f0',
                        },
                        vertical: {
                            show: true,
                            color: theme === 'dark' ? '#333' : '#f0f0f0',
                        }
                    },
                    candle: {
                        type: 'candle_solid',
                        bar: {
                            upColor: '#ef5350',
                            downColor: '#26a69a',
                            noChangeColor: '#888888',
                        },
                        tooltip: {
                            showRule: 'always',
                            showType: 'standard',
                        }
                    }
                });

                // Prepare candle data
                const candleData = data.kline_data.map(k => ({
                    timestamp: convertTime(k.time),
                    open: parseFloat(k.open),
                    high: parseFloat(k.high),
                    low: parseFloat(k.low),
                    close: parseFloat(k.close),
                    volume: parseFloat(k.volume || 0),
                })).filter(k => k.timestamp !== null);

                console.log('üìä [KLineChart] Loading', candleData.length, 'candles');
                chart.applyNewData(candleData);

                // Create Volume pane
                if (indicators.plot_volume) {
                    chart.createIndicator('VOL', false, { id: 'candle_pane' });
                }

                // Create Technical Indicator panes
                if (indicators.plot_macd) {
                    chart.createIndicator('MACD', false, { id: 'macd_pane' });
                }
                if (indicators.plot_kdj) {
                    chart.createIndicator('KDJ', false, { id: 'kdj_pane' });
                }
                if (indicators.plot_rsi) {
                    chart.createIndicator('RSI', false, { id: 'rsi_pane' });
                }

                // Add MA overlays
                if (indicators.plot_ma && indicators.ma_params) {
                    indicators.ma_params.forEach(period => {
                        chart.createIndicator(`MA`, true, { id: 'candle_pane' }, {
                            calcParams: [period],
                        });
                    });
                }

                // Add BOLL overlay
                if (indicators.plot_boll) {
                    chart.createIndicator('BOLL', true, { id: 'candle_pane' });
                }

                // ========== Áº†ËÆ∫ÊåáÊ†áÁªòÂà∂ ==========
                
                // 1. ÁªòÂà∂Á¨î (Bi) - ËìùËâ≤ÊäòÁ∫ø
                if (indicators.plot_bi && data.bi_list && data.bi_list.length > 0) {
                    console.log('üìä [Bi] Adding', data.bi_list.length, 'segments');
                    data.bi_list.forEach((bi, idx) => {
                        const beginTime = convertTime(bi.begin_time);
                        const endTime = convertTime(bi.end_time);
                        
                        if (beginTime && endTime) {
                            chart.createOverlay({
                                name: 'segment',
                                id: `bi_${idx}`,
                                groupId: 'bi_group',
                                paneId: 'candle_pane',
                                points: [
                                    { timestamp: beginTime, value: parseFloat(bi.begin_price) },
                                    { timestamp: endTime, value: parseFloat(bi.end_price) }
                                ],
                                styles: {
                                    line: {
                                        style: 'solid',
                                        size: 2,
                                        color: '#2196F3',
                                        dashedValue: [2, 2]
                                    }
                                }
                            });
                        }
                    });
                    console.log('‚úÖ [Bi] Added successfully');
                }

                // 2. ÁªòÂà∂Á∫øÊÆµ (Seg) - Á¥´Ëâ≤Á≤óÁ∫ø
                if (indicators.plot_seg && data.seg_list && data.seg_list.length > 0) {
                    console.log('üìä [Seg] Adding', data.seg_list.length, 'segments');
                    data.seg_list.forEach((seg, idx) => {
                        const beginTime = convertTime(seg.begin_time);
                        const endTime = convertTime(seg.end_time);
                        
                        if (beginTime && endTime) {
                            chart.createOverlay({
                                name: 'segment',
                                id: `seg_${idx}`,
                                groupId: 'seg_group',
                                paneId: 'candle_pane',
                                points: [
                                    { timestamp: beginTime, value: parseFloat(seg.begin_price) },
                                    { timestamp: endTime, value: parseFloat(seg.end_price) }
                                ],
                                styles: {
                                    line: {
                                        style: 'solid',
                                        size: 3,
                                        color: '#9C27B0',
                                    }
                                }
                            });
                        }
                    });
                    console.log('‚úÖ [Seg] Added successfully');
                }

                // 3. ÁªòÂà∂‰∏≠Êû¢ (ZhongShu) - ÈªÑËâ≤Áü©ÂΩ¢Âå∫Âüü
                if (indicators.plot_zs && data.zs_list && data.zs_list.length > 0) {
                    console.log('üìä [ZS] Adding', data.zs_list.length, 'zhongshu');
                    data.zs_list.forEach((zs, idx) => {
                        const beginTime = convertTime(zs.begin_time);
                        const endTime = convertTime(zs.end_time);
                        const high = parseFloat(zs.zg);  // ‰∏≠Êû¢‰∏äÊ≤ø
                        const low = parseFloat(zs.zd);   // ‰∏≠Êû¢‰∏ãÊ≤ø
                        
                        if (beginTime && endTime && high && low) {
                            // ‰ΩøÁî®Áü©ÂΩ¢Ë¶ÜÁõñÁâ©ÁªòÂà∂‰∏≠Êû¢
                            chart.createOverlay({
                                name: 'rect',
                                id: `zs_${idx}`,
                                groupId: 'zs_group',
                                paneId: 'candle_pane',
                                points: [
                                    { timestamp: beginTime, value: high },
                                    { timestamp: endTime, value: low }
                                ],
                                styles: {
                                    style: 'fill',
                                    color: 'rgba(255, 193, 7, 0.2)',
                                    borderColor: '#FFC107',
                                    borderSize: 1,
                                    borderStyle: 'dashed',
                                }
                            });
                        }
                    });
                    console.log('‚úÖ [ZS] Added successfully');
                }

                // 4. ÁªòÂà∂‰π∞ÂçñÁÇπ (BuySellPoint) - ÁÆ≠Â§¥Ê†áËÆ∞
                if (indicators.plot_bsp && data.bsp_list && data.bsp_list.length > 0) {
                    console.log('üìä [BSP] Adding', data.bsp_list.length, 'buy/sell points');
                    data.bsp_list.forEach((bsp, idx) => {
                        const timestamp = convertTime(bsp.time);
                        const price = parseFloat(bsp.price);
                        const isBuy = bsp.is_buy;
                        
                        if (timestamp && price) {
                            chart.createOverlay({
                                name: 'simpleAnnotation',
                                id: `bsp_${idx}`,
                                groupId: 'bsp_group',
                                paneId: 'candle_pane',
                                points: [{ timestamp, value: price }],
                                styles: {
                                    position: isBuy ? 'bottom' : 'top',
                                    offset: [0, isBuy ? 10 : -10],
                                    symbol: {
                                        type: isBuy ? 'arrow_up' : 'arrow_down',
                                        size: 12,
                                        color: isBuy ? '#4CAF50' : '#F44336',
                                        activeColor: isBuy ? '#66BB6A' : '#EF5350',
                                    },
                                },
                                extendData: `${isBuy ? '‰π∞ÁÇπ' : 'ÂçñÁÇπ'}${bsp.type || ''}`
                            });
                        }
                    });
                    console.log('‚úÖ [BSP] Added successfully');
                }

                // Cleanup
                return () => {
                    if (chartInstanceRef.current) {
                        klinecharts.dispose(chartRef.current);
                        chartInstanceRef.current = null;
                    }
                };
            }, [data, indicators, theme]);

            if (loading) {
                return (
                    <div style={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '100%' }}>
                        <Spin size="large" tip="Âä†ËΩΩ‰∏≠..." />
                    </div>
                );
            }

            return (
                <div className="chart-card">
                    <div className="chart-header">
                        <div className="chart-title">
                            {stockCode} | {LEVEL_OPTIONS.find(o => o.value === level)?.label || level}
                        </div>
                        <Space>
                            <Button 
                                size="small" 
                                onClick={() => {
                                    if (chartInstanceRef.current) {
                                        chartInstanceRef.current.zoomAtDataIndex(0.5, candleData.length - 1, 0);
                                    }
                                }}
                            >
                                ÈáçÁΩÆÁº©Êîæ
                            </Button>
                        </Space>
                    </div>
                    <div ref={chartRef} className="chart-container" />
                </div>
            );
        });

        // ============= Stock Manager Component =============
        const StockManager = memo(() => {
            const { stocks, addStock, removeStock, analyzeStock } = useApp();
            const [inputCode, setInputCode] = useState('');
            const [inputLevels, setInputLevels] = useState(['day']);

            const handleAdd = () => {
                if (!inputCode.trim()) {
                    message.warning('ËØ∑ËæìÂÖ•ËÇ°Á•®‰ª£Á†Å');
                    return;
                }
                if (inputLevels.length === 0) {
                    message.warning('ËØ∑ÈÄâÊã©Ëá≥Â∞ë‰∏Ä‰∏™Âë®Êúü');
                    return;
                }
                addStock({ code: inputCode.trim(), levels: inputLevels });
                setInputCode('');
                message.success('Ê∑ªÂä†ÊàêÂäü');
            };

            return (
                <div>
                    <div className="stock-manager-title">ËÇ°Á•®ÁÆ°ÁêÜ</div>
                    
                    <div className="stock-input-group">
                        <Input
                            placeholder="ËæìÂÖ•ËÇ°Á•®‰ª£Á†Å (Â¶Ç: sz.000001)"
                            value={inputCode}
                            onChange={e => setInputCode(e.target.value)}
                            onPressEnter={handleAdd}
                        />
                        <Select
                            mode="multiple"
                            placeholder="ÈÄâÊã©Âë®Êúü"
                            value={inputLevels}
                            onChange={setInputLevels}
                            options={LEVEL_OPTIONS}
                            style={{ width: '100%' }}
                        />
                        <Button type="primary" block onClick={handleAdd}>
                            Ê∑ªÂä†ËÇ°Á•®
                        </Button>
                    </div>

                    <div className="quick-add-buttons">
                        {QUICK_STOCKS.map(stock => (
                            <Button
                                key={stock.code}
                                size="small"
                                onClick={() => {
                                    addStock({ code: stock.code, levels: ['day'] });
                                    message.success(`Â∑≤Ê∑ªÂä†${stock.name}`);
                                }}
                            >
                                {stock.name}
                            </Button>
                        ))}
                    </div>

                    <div className="stock-list">
                        {stocks.map(stock => (
                            <div key={stock.id} className="stock-item">
                                <div className="stock-header">
                                    <span className="stock-code">{stock.code}</span>
                                </div>
                                <div className="stock-levels">
                                    {stock.levels.map(lv => (
                                        <Tag key={lv} color="blue">
                                            {LEVEL_OPTIONS.find(o => o.value === lv)?.label || lv}
                                        </Tag>
                                    ))}
                                </div>
                                <div className="stock-actions">
                                    <Button
                                        type="text"
                                        size="small"
                                        onClick={() => {
                                            stock.levels.forEach(lv => analyzeStock(stock.code, lv, true));
                                            message.info(`Ê≠£Âú®Âà∑Êñ∞ ${stock.code}`);
                                        }}
                                    >
                                        üîÑ Âà∑Êñ∞
                                    </Button>
                                    <Button
                                        type="text"
                                        danger
                                        size="small"
                                        onClick={() => removeStock(stock.id)}
                                    >
                                        Âà†Èô§
                                    </Button>
                                </div>
                            </div>
                        ))}
                    </div>
                </div>
            );
        });

        // ============= Indicator Config Component =============
        const IndicatorConfig = memo(() => {
            const { indicators, setIndicators, refreshAllCharts } = useApp();
            const [timeRange, setTimeRange] = useState('1y');

            const handleChange = (key, value) => {
                setIndicators(prev => ({ ...prev, [key]: value }));
            };

            const handleTimeRangeChange = (range) => {
                setTimeRange(range);
                const now = new Date();
                let beginTime;
                
                switch(range) {
                    case '1m': beginTime = new Date(now.setMonth(now.getMonth() - 1)); break;
                    case '3m': beginTime = new Date(now.setMonth(now.getMonth() - 3)); break;
                    case '6m': beginTime = new Date(now.setMonth(now.getMonth() - 6)); break;
                    case '1y': beginTime = new Date(now.setFullYear(now.getFullYear() - 1)); break;
                    case '3y': beginTime = new Date(now.setFullYear(now.getFullYear() - 3)); break;
                    case 'all': beginTime = new Date('2020-01-01'); break;
                    default: beginTime = new Date(now.setFullYear(now.getFullYear() - 1));
                }
                
                handleChange('begin_time', beginTime.toISOString().split('T')[0]);
                setTimeout(() => refreshAllCharts(), 100);
            };

            return (
                <div>
                    <div style={{ marginBottom: 16, padding: 12, background: '#f5f5f5', borderRadius: 8 }}>
                        <div style={{ marginBottom: 8, fontWeight: 600, fontSize: 13 }}>Êó∂Èó¥ËåÉÂõ¥</div>
                        <Radio.Group 
                            value={timeRange} 
                            onChange={e => handleTimeRangeChange(e.target.value)}
                            size="small"
                            buttonStyle="solid"
                        >
                            <Radio.Button value="1m">Ëøë1Êúà</Radio.Button>
                            <Radio.Button value="3m">Ëøë3Êúà</Radio.Button>
                            <Radio.Button value="6m">Ëøë6Êúà</Radio.Button>
                            <Radio.Button value="1y">Ëøë1Âπ¥</Radio.Button>
                            <Radio.Button value="3y">Ëøë3Âπ¥</Radio.Button>
                            <Radio.Button value="all">ÂÖ®ÈÉ®</Radio.Button>
                        </Radio.Group>
                    </div>

                    <div className="indicator-section">
                        <div className="indicator-section-title">Áº†ËÆ∫ÊåáÊ†á</div>
                        <div className="indicator-item">
                            <Checkbox checked={indicators.plot_bi} onChange={e => handleChange('plot_bi', e.target.checked)}>
                                Á¨î (Bi)
                            </Checkbox>
                        </div>
                        <div className="indicator-item">
                            <Checkbox checked={indicators.plot_seg} onChange={e => handleChange('plot_seg', e.target.checked)}>
                                Á∫øÊÆµ (Seg)
                            </Checkbox>
                        </div>
                        <div className="indicator-item">
                            <Checkbox checked={indicators.plot_zs} onChange={e => handleChange('plot_zs', e.target.checked)}>
                                ‰∏≠Êû¢ (ZS)
                            </Checkbox>
                        </div>
                        <div className="indicator-item">
                            <Checkbox checked={indicators.plot_bsp} onChange={e => handleChange('plot_bsp', e.target.checked)}>
                                ‰π∞ÂçñÁÇπ (BSP)
                            </Checkbox>
                        </div>
                    </div>

                    <div className="indicator-section">
                        <div className="indicator-section-title">ÊäÄÊúØÊåáÊ†á</div>
                        <div className="indicator-item">
                            <Checkbox checked={indicators.plot_volume} onChange={e => handleChange('plot_volume', e.target.checked)}>
                                Êàê‰∫§Èáè (Volume)
                            </Checkbox>
                        </div>
                        <div className="indicator-item">
                            <Checkbox checked={indicators.plot_ma} onChange={e => handleChange('plot_ma', e.target.checked)}>
                                ÁßªÂä®Âπ≥ÂùáÁ∫ø (MA)
                            </Checkbox>
                        </div>
                        <div className="indicator-item">
                            <Checkbox checked={indicators.plot_macd} onChange={e => handleChange('plot_macd', e.target.checked)}>
                                MACD
                            </Checkbox>
                        </div>
                        <div className="indicator-item">
                            <Checkbox checked={indicators.plot_boll} onChange={e => handleChange('plot_boll', e.target.checked)}>
                                Â∏ÉÊûóÂ∏¶ (BOLL)
                            </Checkbox>
                        </div>
                        <div className="indicator-item">
                            <Checkbox checked={indicators.plot_kdj} onChange={e => handleChange('plot_kdj', e.target.checked)}>
                                KDJ
                            </Checkbox>
                        </div>
                        <div className="indicator-item">
                            <Checkbox checked={indicators.plot_rsi} onChange={e => handleChange('plot_rsi', e.target.checked)}>
                                RSI
                            </Checkbox>
                        </div>
                    </div>
                </div>
            );
        });

        // ============= Chart Grid Component =============
        const ChartGrid = () => {
            const { stocks, gridLayout, chartData, loadingCharts } = useApp();

            const chartSlots = [];
            stocks.forEach(stock => {
                stock.levels.forEach(level => {
                    const key = `${stock.code}-${level}`;
                    chartSlots.push({
                        key,
                        stockCode: stock.code,
                        level,
                        data: chartData[key],
                        loading: loadingCharts[key],
                    });
                });
            });

            const totalCharts = chartSlots.length;
            let layoutClass = 'chart-grid-1x1';
            if (gridLayout === 'auto') {
                if (totalCharts === 1) layoutClass = 'chart-grid-1x1';
                else if (totalCharts === 2) layoutClass = 'chart-grid-2x1';
                else if (totalCharts <= 4) layoutClass = 'chart-grid-2x2';
                else layoutClass = 'chart-grid-3x2';
            } else {
                layoutClass = `chart-grid-${gridLayout}`;
            }

            return (
                <div className={`chart-grid ${layoutClass}`}>
                    {chartSlots.map(slot => (
                        <ChartPanel
                            key={slot.key}
                            stockCode={slot.stockCode}
                            level={slot.level}
                            data={slot.data}
                            loading={slot.loading}
                        />
                    ))}
                    {chartSlots.length === 0 && (
                        <div style={{ textAlign: 'center', color: '#999', padding: 20 }}>
                            ÊöÇÊó†ÂõæË°®ÔºåËØ∑Ê∑ªÂä†ËÇ°Á•®
                        </div>
                    )}
                </div>
            );
        };

        // ============= Main App Component =============
        const App = () => {
            const savedConfig = loadConfig();

            const [stocks, setStocks] = useState(savedConfig?.stocks || []);
            const [indicators, setIndicators] = useState(savedConfig?.indicators || {
                plot_bi: true,
                plot_seg: true,
                plot_zs: false,
                plot_bsp: true,
                plot_ma: true,
                plot_macd: true,
                plot_boll: false,
                plot_kdj: false,
                plot_rsi: false,
                plot_volume: true,
                seg_algo: 'chan',
                zs_algo: 'normal',
                bi_strict: true,
                begin_time: '2023-01-01',
                ma_params: [5, 10, 20, 60],
                kdj_period: 9,
                rsi_period: 14,
            });
            const [gridLayout, setGridLayout] = useState(savedConfig?.gridLayout || 'auto');
            const [chartData, setChartData] = useState({});
            const [loadingCharts, setLoadingCharts] = useState({});
            const [theme, setTheme] = useState(savedConfig?.theme || 'light');

            // Save config
            useEffect(() => {
                try {
                    const config = { stocks, indicators, gridLayout, theme };
                    localStorage.setItem('chanlun_config', JSON.stringify(config));
                } catch (e) {
                    console.error('Failed to save config:', e);
                }
            }, [stocks, indicators, gridLayout, theme]);

            // Auto-refresh on indicator change
            const prevIndicatorsRef = useRef(indicators);
            useEffect(() => {
                const prev = prevIndicatorsRef.current;
                const changed = ['plot_bi', 'plot_seg', 'plot_zs', 'plot_bsp', 'plot_ma', 'plot_macd', 'plot_boll', 'plot_kdj', 'plot_rsi', 'plot_volume']
                    .some(key => prev[key] !== indicators[key]);
                
                if (changed && Object.keys(prev).length > 0 && stocks.length > 0) {
                    console.log('üîÑ Indicators changed, refreshing...');
                    setTimeout(() => refreshAllCharts(), 100);
                }
                prevIndicatorsRef.current = indicators;
            }, [indicators, stocks.length]);

            const addStock = (stockInfo) => {
                const existingStock = stocks.find(s => s.code === stockInfo.code);
                
                if (existingStock) {
                    const mergedLevels = [...new Set([...existingStock.levels, ...stockInfo.levels])];
                    setStocks(prev => prev.map(s => s.code === stockInfo.code ? { ...s, levels: mergedLevels } : s));
                    
                    const newLevels = stockInfo.levels.filter(lv => !existingStock.levels.includes(lv));
                    newLevels.forEach(level => analyzeStock(stockInfo.code, level));
                    
                    if (newLevels.length > 0) {
                        message.success(`Â∑≤Ê∑ªÂä† ${stockInfo.code} ÁöÑÊñ∞Âë®Êúü`);
                    } else {
                        message.info(`${stockInfo.code} Â∑≤Â≠òÂú®`);
                    }
                } else {
                    const newStock = { id: Date.now(), code: stockInfo.code, levels: stockInfo.levels };
                    setStocks(prev => [...prev, newStock]);
                    stockInfo.levels.forEach(level => analyzeStock(stockInfo.code, level));
                }
            };

            const removeStock = (stockId) => {
                setStocks(prev => prev.filter(s => s.id !== stockId));
            };

            const analyzeStock = async (code, level, forceRefresh = false) => {
                const key = `${code}-${level}`;
                
                if (!forceRefresh) {
                    const cachedData = DataCache.get(key);
                    if (cachedData) {
                        setChartData(prev => ({ ...prev, [key]: cachedData }));
                        message.success(`${code} ${level} Êï∞ÊçÆÂ∑≤‰ªéÁºìÂ≠òÂä†ËΩΩ`, 1);
                        return;
                    }
                }

                setLoadingCharts(prev => ({ ...prev, [key]: true }));

                try {
                    const params = {
                        code,
                        lv_list: [level],
                        data_src: 'BAO_STOCK',
                        ...indicators,
                    };

                    const result = await api.calculateChan(params);
                    setChartData(prev => ({ ...prev, [key]: result }));
                    DataCache.set(key, result);
                    message.success(`${code} ${level} ÂàÜÊûêÂÆåÊàê`);
                } catch (error) {
                    console.error('Analysis failed:', error);
                    message.error(`${code} ${level} ÂàÜÊûêÂ§±Ë¥•: ${error.message}`);
                } finally {
                    setLoadingCharts(prev => ({ ...prev, [key]: false }));
                }
            };

            const refreshAllCharts = useCallback(() => {
                DataCache.clear();
                stocks.forEach(stock => {
                    stock.levels.forEach(level => {
                        analyzeStock(stock.code, level, true);
                    });
                });
                message.info('Ê≠£Âú®Âà∑Êñ∞ÊâÄÊúâÂõæË°®...');
            }, [stocks, indicators]);

            const contextValue = {
                stocks,
                setStocks,
                addStock,
                removeStock,
                indicators,
                setIndicators,
                gridLayout,
                chartData,
                loadingCharts,
                analyzeStock,
                refreshAllCharts,
                theme,
            };

            return (
                <AppContext.Provider value={contextValue}>
                    <Layout className={`app-layout ${theme === 'dark' ? 'dark-theme' : ''}`}>
                        <Header className="app-header">
                            <div className="app-logo">
                                <span>üìà</span>
                                <span>Áº†ËÆ∫Âú®Á∫øÂàÜÊûêÁ≥ªÁªü (KLineChartÁâà)</span>
                            </div>
                            <div className="app-header-actions">
                                <Select
                                    value={gridLayout}
                                    onChange={setGridLayout}
                                    style={{ width: 100 }}
                                    size="small"
                                    options={[
                                        { value: 'auto', label: 'Ëá™Âä®' },
                                        { value: '1x1', label: '1x1' },
                                        { value: '2x1', label: '2x1' },
                                        { value: '2x2', label: '2x2' },
                                        { value: '3x2', label: '3x2' },
                                    ]}
                                />
                                <Tooltip title="ÂàáÊç¢‰∏ªÈ¢ò">
                                    <Button
                                        size="small"
                                        onClick={() => setTheme(prev => prev === 'light' ? 'dark' : 'light')}
                                    >
                                        {theme === 'light' ? 'üåô' : '‚òÄÔ∏è'}
                                    </Button>
                                </Tooltip>
                                <Tooltip title="Âà∑Êñ∞ÊâÄÊúâÂõæË°®">
                                    <Button size="small" onClick={refreshAllCharts}>
                                        üîÑ Âà∑Êñ∞
                                    </Button>
                                </Tooltip>
                                <Tooltip title="Ê∏ÖÁ©∫ÊâÄÊúâËÇ°Á•®">
                                    <Button size="small" danger onClick={() => setStocks([])}>
                                        Ê∏ÖÁ©∫
                                    </Button>
                                </Tooltip>
                            </div>
                        </Header>
                        <div className="app-content">
                            <div className="sidebar left-sidebar">
                                <StockManager />
                            </div>
                            <div className="main-content">
                                <ChartGrid />
                            </div>
                            <div className="sidebar right-sidebar">
                                <IndicatorConfig />
                            </div>
                        </div>
                    </Layout>
                </AppContext.Provider>
            );
        };

        // Render app
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>

